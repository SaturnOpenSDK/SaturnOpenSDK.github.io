<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Hitachi SuperH Instruction Set Summary</title>

<style>

:root
{
  --table-width: 1490px;
  --details-width: 820px;
}

@media (prefers-color-scheme : light)
{
  .image_filter {} /* no filtering needed */

  :root
  {
    --system-background-color: #FFFFFF;
    --system-text-color: #000000;

    --table-background-color: #FFFFFF;
    --table-text-color: #000000;
    --table-background-hover-color: #F0F0F0;
    --table-image-hover-color: #F0F0F0;

    --header-background-color: #D0D0D0;
    --header-text-color: #000000;

    --grid-inactive-text-color: #C0C0C0;
    --grid-cell-background-color: #F4F4F4;

    --cpu-grid-active-text-color: #404040;
    --cycle-grid-active-text-color: #000000;
  }

  span[title='Ignored']                          { color: goldenrod; }
  span[title='Opcode Identifier']                { color: dodgerblue; }
  span[title='A']                                { color: darkgreen; }
  span[title='D']                                { color: darkmagenta; }
  span[title^='Unsigned Immediate Data']         { color: darkturquoise; }
  span[title^='Signed Immediate Data']           { color: darkturquoise; }
  span[title^='Source Register']                 { color: aquamarine; }
  span[title^='Destination Register']            { color: blueViolet; }
  span[title^='Displacement']                    { color: indigo; }
  span[title^='Multiplier Source Register 1']    { color: cyan; }
  span[title^='Multiplier Source Register 2']    { color: chartreuse; }
  span[title^='Multiplier Destination Register'] { color: darkcyan; }
  span[title^='ALU Source Register 1']           { color: darkmagenta; }
  span[title^='ALU Source Register 2']           { color: darkorange; }
  span[title^='ALU Destination Register']        { color: indianred; }
  span[title^='ALU Destination Register']        { color: forestgreen; }
}

@media (prefers-color-scheme : dark)
{
  .image_filter /* invert colors */
  {
    filter: invert(100%);
  }

  :root
  {
    --system-background-color: #000000;
    --system-text-color: #FFFFFF;

    --table-background-color: #000000;
    --table-text-color: #FFFFFF;
    --table-background-hover-color: #404040;
    --table-image-hover-color: #C0C0C0;

    --header-background-color: #606060;
    --header-text-color: #FFFFFF;

    --grid-inactive-text-color: #707070;
    --grid-cell-background-color: #303030;

    --cpu-grid-active-text-color: #C0C0C0;
    --cycle-grid-active-text-color: #FFFFFF;
  }

  span[title='Ignored']                          { color: gold; }
  span[title='Opcode Identifier']                { color: #55ff55; }
  span[title='A']                                { color: lightseagreen; }
  span[title='D']                                { color: olive; }
  span[title^='Unsigned Immediate Data']         { color: #aaaaff; }
  span[title^='Signed Immediate Data']           { color: #aaaaff; }
  span[title^='Source Register']                 { color: #ffff55; }
  span[title^='Destination Register']            { color: #f92672; }
  span[title^='Displacement']                    { color: coral; }
  span[title^='Multiplier Source Register 1']    { color: cyan; }
  span[title^='Multiplier Source Register 2']    { color: chartreuse; }
  span[title^='Multiplier Destination Register'] { color: darkcyan; }
  span[title^='ALU Source Register 1']           { color: darkorange; }
  span[title^='ALU Source Register 2']           { color: deeppink; }
  span[title^='ALU Destination Register']        { color: darkmagenta; }
  span[title^='ALU Destination Register']        { color: forestgreen; }
}

/*
ALU Arithmetic Logic Unit
ASID Address Space Identifier
CPU Central Processing Unit
FPU Floating Point Unit
ITLB Instruction Translation Look aside Buffer
LRU Least Recently Used
LSB Least Significant Bit
MMU Memory Management Unit
MSB Most Significant Bit
PC Program Counter
PMB Privileged space Mapping Buffer
RISC Reduced Instruction Set Computer
TLB Translation Lookaside Buffer
UBC User Break Controller
UTLB Unified Translation Look aside Buffer



9 8 7 6 5 4 3 2 1 0
M Q I3 I2 I1 I0 S T


S bit: Used by the multiply/accumulate instruction.

Reserved bits: Always reads as 0, and should always be written with 0.

Bits I3–I0: Interrupt mask bits.

M and Q bits: Used by the DIV0U/S and DIV1 instructions.

Global base register (GBR):
Indicates the base address of the indirect
GBR addressing mode. The indirect GBR
addressing mode is used in data transfer
for on-chip peripheral module register
areas and in logic operations.

Vector base register (VBR):
Indicates the base address of the exception
processing vector area.

SR: Status register

T bit: The MOVT, CMP/cond, TAS, TST, BT (BT/S), BF (BF/S), SETT, and CLRT instructions use
       the T bit to indicate true (1) or false (0). The ADDV/C, SUBV/C, DIV0U/S, DIV1, NEGC,
       SHAR/L, SHLR/L, ROTR/L, and ROTCR/L instructions also use bit T to indicate carry/borrow
       or overflow/underflow




DSP status register (DSR)

GT = Signed greater than bit
Z = Zero value bit
N = Negative value bit
V = Overflow bit
CS = Condition select bits
DC = DSP condition bit



*/

body
{
  background-color: var(--system-background-color);
  color: var(--system-text-color);
  font-size: 15px;
  padding-left: calc(50% - var(--table-width) / 2); /* center everything */
  height: 25000px; /* for sticky header */
  margin: 0px;
}

#header
{
  background-color: var(--system-background-color);
  color: var(--system-text-color);
  width: var(--table-width);
}

#table_header
{
  position: sticky !important;
  top: 0px;
  height: 85px;
  z-index: 100;
  font-weight: bold;
  font-style: italic;
  background-color: var(--header-background-color);
  color: var(--header-text-color)
}



input[id="cb_SH1"  ]:checked ~ label.SH1,
input[id="cb_SH2"  ]:checked ~ label.SH2,
input[id="cb_SH2E" ]:checked ~ label.SH2E,
input[id="cb_SH3"  ]:checked ~ label.SH3,
input[id="cb_SH3E" ]:checked ~ label.SH3E,
input[id="cb_DSP"  ]:checked ~ label.DSP,
input[id="cb_SH4"  ]:checked ~ label.SH4,
input[id="cb_SH4A" ]:checked ~ label.SH4A,
input[id="cb_SH2A" ]:checked ~ label.SH2A  { display: inline-grid; }
label.summary { display: none; }

input[id^="cb_" ]
{
  position: sticky;
  z-index: 1000;
  padding-left: 30px;
}

input[id^="cb_" ]::after
{
  content:attr(name);
}

input[type='checkbox'][id^="row"] { display: none; }
input[type='checkbox'][id^="row"]:checked + label > .details
  { display: unset; }

.summary
{
  background-color: var(--table-background-color);
  color: var(--table-text-color);
  clear: both;
}

label.summary > .colorized > span
{
  font-family: monospace;
  display: contents;
}

label.summary > span:not(.details)
{
  padding-right: 20px;
  border-top-width: 1px;
  border-top-style: dotted;
  font-family: monospace;
  font-size: 13px;
}

.summary > span:not(.details):nth-child(2)
{
  white-space: pre-wrap;
}

.summary > span:not(.details):nth-child(1) { padding-left: 10px; }
.summary > span:not(.details):nth-child(3)
{
  white-space: pre-wrap;
  padding-right: 30px;
}


/* links hover events */
label.summary:hover > *,
.details:hover > *,
.details:hover + .summary
{ background-color: var(--table-background-hover-color); }

/* keep images readable */
.details:hover img
{ background-color: var(--table-image-hover-color) !important; }

.summary
{
  display: inline-grid;
  grid-template-columns: 150px 240px 470px 150px 130px 120px 120px 110px;
  grid-template-rows: 50px auto;
}

/* all columns */
.summary > span
{
  vertical-align: middle;
  display: inline-block;
}

.cpu_grid, .cycle_grid
{
  display: inline-grid !important;
  grid-gap: 2px;
  grid-template-columns: 33px 33px 33px;
  grid-template-rows: 13px 13px 13px;
  font-family: monospace;
  font-size: 11px;
  font-weight: unset;
  font-style: unset;
}

.cpu_grid > var, .cycle_grid > var
{
  color: var(--grid-inactive-text-color);
  background-color: var(--grid-cell-background-color);
  display: block;
  text-align: center;
  padding: 0px;
  margin: 0px;
  height: 13px;
}

.cpu_grid > var:nth-of-type(1):before { content:"SH1"  ; }
.cpu_grid > var:nth-of-type(2):before { content:"SH2"  ; }
.cpu_grid > var:nth-of-type(3):before { content:"SH2E" ; }
.cpu_grid > var:nth-of-type(4):before { content:"SH3"  ; }
.cpu_grid > var:nth-of-type(5):before { content:"SH3E" ; }
.cpu_grid > var:nth-of-type(6):before { content:"DSP"  ; }
.cpu_grid > var:nth-of-type(7):before { content:"SH4"  ; }
.cpu_grid > var:nth-of-type(8):before { content:"SH4A" ; }
.cpu_grid > var:nth-of-type(9):before { content:"SH2A" ; }

.summary .cpu_grid > var,
.summary .cycle_grid > var { color: transparent; }

input[id="cb_SH1"  ]:checked ~ .summary .cpu_grid > var:nth-of-type(1),
input[id="cb_SH2"  ]:checked ~ .summary .cpu_grid > var:nth-of-type(2),
input[id="cb_SH2E" ]:checked ~ .summary .cpu_grid > var:nth-of-type(3),
input[id="cb_SH3"  ]:checked ~ .summary .cpu_grid > var:nth-of-type(4),
input[id="cb_SH3E" ]:checked ~ .summary .cpu_grid > var:nth-of-type(5),
input[id="cb_DSP"  ]:checked ~ .summary .cpu_grid > var:nth-of-type(6),
input[id="cb_SH4"  ]:checked ~ .summary .cpu_grid > var:nth-of-type(7),
input[id="cb_SH4A" ]:checked ~ .summary .cpu_grid > var:nth-of-type(8),
input[id="cb_SH2A" ]:checked ~ .summary .cpu_grid > var:nth-of-type(9)
{ color: var(--grid-inactive-text-color); }

input[id="cb_SH1"  ]:checked ~ .summary.SH1  .cpu_grid > var:nth-of-type(1),
input[id="cb_SH2"  ]:checked ~ .summary.SH2  .cpu_grid > var:nth-of-type(2),
input[id="cb_SH2E" ]:checked ~ .summary.SH2E .cpu_grid > var:nth-of-type(3),
input[id="cb_SH3"  ]:checked ~ .summary.SH3  .cpu_grid > var:nth-of-type(4),
input[id="cb_SH3E" ]:checked ~ .summary.SH3E .cpu_grid > var:nth-of-type(5),
input[id="cb_DSP"  ]:checked ~ .summary.DSP  .cpu_grid > var:nth-of-type(6),
input[id="cb_SH4"  ]:checked ~ .summary.SH4  .cpu_grid > var:nth-of-type(7),
input[id="cb_SH4A" ]:checked ~ .summary.SH4A .cpu_grid > var:nth-of-type(8),
input[id="cb_SH2A" ]:checked ~ .summary.SH2A .cpu_grid > var:nth-of-type(9)
{ color: var(--cpu-grid-active-text-color); }

input[id="cb_SH1"  ]:checked ~ .summary.SH1  .cycle_grid > var:nth-of-type(1),
input[id="cb_SH2"  ]:checked ~ .summary.SH2  .cycle_grid > var:nth-of-type(2),
input[id="cb_SH2E" ]:checked ~ .summary.SH2E .cycle_grid > var:nth-of-type(3),
input[id="cb_SH3"  ]:checked ~ .summary.SH3  .cycle_grid > var:nth-of-type(4),
input[id="cb_SH3E" ]:checked ~ .summary.SH3E .cycle_grid > var:nth-of-type(5),
input[id="cb_DSP"  ]:checked ~ .summary.DSP  .cycle_grid > var:nth-of-type(6),
input[id="cb_SH4"  ]:checked ~ .summary.SH4  .cycle_grid > var:nth-of-type(7),
input[id="cb_SH4A" ]:checked ~ .summary.SH4A .cycle_grid > var:nth-of-type(8),
input[id="cb_SH2A" ]:checked ~ .summary.SH2A .cycle_grid > var:nth-of-type(9)
{ color: var(--cycle-grid-active-text-color); }

/* styling for details section */
.summary > .details
{
  border: unset;
  display: none;
  padding: 10px calc(var(--table-width) - var(--details-width) - 30px) 10px 30px;
  width: var(--details-width);
}

.summary > .details > span[title="code"],
.summary > .details > span[title="assembly"]
{
  display: block;
  font-size: 13px;
  font-family: monospace;
  white-space: pre;
  margin: 1em 0;
}

.summary > .details > span[title="section"]
{
  font-style: italic;
  font-weight: bold;
}

span[title='list']
{
  list-style-type: circle;
}
span[title='list'] > var
{
  font-style: unset;
  display: list-item;
}

</style>
</head>
<body>
  <div id="header">
    <span style="font-size:20px;font:bold">Hitachi SuperH Instruction Set Summary</span>
    <div style="float:right">Last updated: May 15 2022 18:01:13</div>
    <br />
    <div style="float:right">
      <a href="mailto:olegendo@gcc.gnu.org?Subject=Renesas%20SH%20Instruction%20Set%20Summary">Contact</a>
      <a href="https://github.com/shared-ptr/sh_insns">Page Source</a>
    </div>
  </div>
  <input type="checkbox" id="cb_SH1" name="SH1" checked /><label for="cb_SH1">SH1</label>
  <input type="checkbox" id="cb_SH2" name="SH2" checked /><label for="cb_SH2">SH2</label>
  <input type="checkbox" id="cb_SH2E" name="SH2E" checked /><label for="cb_SH2E">SH2E</label>
  <input type="checkbox" id="cb_SH2A" name="SH2A" checked /><label for="cb_SH2A">SH2A</label>
  <input type="checkbox" id="cb_SH3" name="SH3" checked /><label for="cb_SH3">SH3</label>
  <input type="checkbox" id="cb_SH3E" name="SH3E" checked /><label for="cb_SH3E">SH3E</label>
  <input type="checkbox" id="cb_SH4" name="SH4" checked /><label for="cb_SH4">SH4</label>
  <input type="checkbox" id="cb_SH4A" name="SH4A" checked /><label for="cb_SH4A">SH4A</label>
  <input type="checkbox" id="cb_DSP" name="DSP" checked /><label for="cb_DSP">DSP</label>
    <span id="table_header" class="summary SH1 SH2 SH2E SH2A SH3 SH3E SH4 SH4A DSP">
    <span>Compatibilty</span>
    <span>Format</span>
    <span>Abstract</span>
    <span>Code</span>
    <span>Bit Flags</span>
    <span>Instruction Group
      <span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
    </span>
    <span>Issue Cycles
      <span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
    </span>
    <span>Latency Cycles
      <span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
    </span>
  </span><br/><br/><br/><b>Data Transfer Instructions</b><br/><br/>
<input type="checkbox" id="row0" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row0">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov	Rm,Rn</span>
<span>Rm → Rn</span>
<span id="0110nnnnmmmm0011" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>MT</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOV (int m, int n)
{
  R[n] = R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov    r0,r1   ! Before execution: r0 = 0xFFFFFFFF, r1 = 0x00000000
      After execution: r1 = 0xFFFFFFFF
</span>
</span>
</label>
<input type="checkbox" id="row1" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row1">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov	#imm,Rn</span>
<span>imm → sign extension → Rn</span>
<span id="1110nnnniiiiiiii" class="colorized"><span title="Opcode Identifier">1110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>MT</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section">Move Constant Value</span>
<br />
<br />Stores immediate data, sign-extended to longword, in general register Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVI (int i, int n)
{
  if ((i & 0x80) == 0)
    R[n] = (0x000000FF & i);
  else
    R[n] = (0xFFFFFF00 | i);

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">      1000 mov #0x80,r1 ! r1 = 0xFFFFFF80
      1002 mov.w imm,r2 ! r2 = 0xFFFF9ABC, IMM means @(0x08,PC)
      1004 add #–1,r0 ! 
      1006 tst r0,r0 ! ← PC location used for address calculation for the
mov.w  instruction
      1008 movt r13 ! 
      100a bra next ! Delayed branch instruction
      100c mov.l @(4,pc),r3 ! r3 = 0x12345678
      100e imm
.data.w 0x9abc  ! 
      1010
.data.w 0x1234  ! 
      1012 next jmp @r3 ! Branch destination of the BRA instruction
      1014 cmp/eq #0,r0 ! ← PC location used for address calculation for the
      MOV.L instruction
.align 4       ! 
      1018
.data.l 0x12345678 ! 
</span>
</span>
</label>
<input type="checkbox" id="row2" />
<label class="summary SH2A" for="row2">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movi20	#imm20,Rn</span>
<span>imm → sign extension → Rn</span>
<span id="0000nnnniiii0000_iiiiiiiiiiiiiiii" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Unsigned Immediate Data (20 bits)">iiii</span><span title="Opcode Identifier">0000</span> <span title="Unsigned Immediate Data (20 bits)">iiiiiiiiiiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores immediate data that has been sign-extended to longword in general
register Rn.
<br /><img alt="Move Immediate Data operation" src="movi20.svg" height="140" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVI20 (int i, int n)
{
  if (i & 0x00080000) == 0)
    R[n] = (0x000FFFFF & (long)i);
  else
    R[n] = (0xFFF00000 | (long)i);

  PC += 4;
}

</span>
</span>
</label>
<input type="checkbox" id="row3" />
<label class="summary SH2A" for="row3">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movi20s	#imm20,Rn</span>
<span>imm &lt;&lt; 8 → sign extension → Rn</span>
<span id="0000nnnniiii0001_iiiiiiiiiiiiiiii" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Unsigned Immediate Data (20 bits)">iiii</span><span title="Opcode Identifier">0001</span> <span title="Unsigned Immediate Data (20 bits)">iiiiiiiiiiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Shifts immediate data 8 bits to the left and performs sign extension to
longword, then stores the resulting data in general register Rn. Using an OR or
ADD instruction as the next instruction enables a 28-bit absolute address to be
generated.
<br /><img alt="Move Immediate Data operation" src="movi20s.svg" height="150" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVI20S (int i, int n)
{
  if (i & 0x00080000) == 0)
    R[n] = (0x000FFFFF & (long)i);
  else
    R[n] = (0xFFF00000 | (long)i);

  R[n] &lt;&lt;= 8;
  PC += 4;
}
</span>
</span>
</label>
<input type="checkbox" id="row4" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row4">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mova	@(disp,PC),R0</span>
<span>(disp × 4) + (PC & 0xFFFFFFFC) + 4 → R0</span>
<span id="11000111dddddddd" class="colorized"><span title="Opcode Identifier">11000111</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the effective address of the source operand into general
register R0.  The 8-bit displacement is zero-extended and quadrupled.
Consequently, the relative interval from the operand is PC + 1020 bytes.  The PC
is the address four bytes after this instruction, but the lowest two bits of the
PC are fixed at 00.
<br /><br />
<span title="section">Note</span>
<br />
<br />SH1*, SH2*, SH3*:<br />
If this instruction is placed immediately after a delayed branch instruction,
the PC must point to an address specified by (the starting address of the branch
destination) + 2.<br /><br />

SH4*:<br />
If this instruction is executed in a delay slot, a slot illegal instruction
exception will be generated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVA (int d)
{
  unsigned int disp;
  disp = (unsigned int)(0x000000FF & d);
  R[0] = (PC & 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">.org   0x1006
      1006 mova str,r0 ! Address of STR → r0
      1008 mov.b @r0,r1 ! r1 = “X” ← PC location after correcting the lowest two bits
      100a add r4,r5 ! ← Original PC location for address calculation for the MOVA instruction
.align 4
      100c str:
.sdata “xyzp12”
...............
      2002 bra trget ! Delayed branch instruction
      2004 mova @(0,pc),r0 ! Address of TRGET + 2 → r0
      2006 nop ! 
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction</var>
</span>
</span>
</label>
<input type="checkbox" id="row5" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row5">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@(disp,PC),Rn</span>
<span>(disp × 2 + PC + 4) → sign extension → Rn</span>
<span id="1001nnnndddddddd" class="colorized"><span title="Opcode Identifier">1001</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Constant Value</span>
<br />
<br />Stores immediate data, sign-extended to longword, in general register Rn.
The data is stored from memory address (PC + 4 + displacement × 2).
The 8-bit displacement is multiplied by two after zero-extension, and so the
relative distance from the table is in the range up to PC + 4 + 510 bytes. The
PC value is the address of this instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWI (int d, int n)
{
  unsigned int disp = (0x000000FF & d);
  R[n] = Read_16 (PC + 4 + (disp &lt;&lt; 1));
  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Slot illegal instruction exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row6" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row6">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@(disp,PC),Rn</span>
<span>(disp × 4 + (PC & 0xFFFFFFFC) + 4) → sign extension → Rn</span>
<span id="1101nnnndddddddd" class="colorized"><span title="Opcode Identifier">1101</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Constant Value</span>
<br />
<br />Stores immediate data, sign-extended to longword, in general register Rn.
The data is stored from memory address (PC + 4 + displacement × 4).
The 8-bit displacement is multiplied by four after zero-extension, and so the
relative distance from the operand is in the range up to PC + 4 + 1020 bytes.
The PC value is the address of this instruction. A value with the lower 2 bits
adjusted to 00 is used in address calculation.
<br /><br />
<span title="section">Note</span>
<br />
<br />If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLI (int d, int n)
{
  unsigned int disp = (0x000000FF & d);
  R[n] = Read_32 ((PC & 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2));
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Slot illegal instruction exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row7" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row7">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@Rm,Rn</span>
<span>(Rm) → sign extension → Rn</span>
<span id="0110nnnnmmmm0000" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Note</span>
<br />
<br />MOV.B @R0,R1 ;Before execution: @R0 = H'80, R1 = H'00000000
;After execution: R1 = H'FFFFFF80
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBL (int m, int n)
{
  R[n] = Read_8 (R[m]);
  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row8" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row8">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@Rm,Rn</span>
<span>(Rm) → sign extension → Rn</span>
<span id="0110nnnnmmmm0001" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWL (int m, int n)
{
  R[n] = Read_16 (R[m]);
  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row9" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row9">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@Rm,Rn</span>
<span>(Rm) → Rn</span>
<span id="0110nnnnmmmm0010" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLL (int m, int n)
{
  R[n] = Read_32 (R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row10" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row10">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	Rm,@Rn</span>
<span>Rm → (Rn)</span>
<span id="0010nnnnmmmm0000" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBS (int m, int n)
{
  Write_8 (R[n], R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row11" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row11">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	Rm,@Rn</span>
<span>Rm → (Rn)</span>
<span id="0010nnnnmmmm0001" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWS (int m, int n)
{
  Write_16 (R[n], R[m]);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.w  r0,@r1  ! Before execution: r0 = 0xFFFF7F80
      After execution: @r1 = 0x7F80
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row12" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row12">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	Rm,@Rn</span>
<span>Rm → (Rn)</span>
<span id="0010nnnnmmmm0010" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLS (int m, int n)
{
  Write_32 (R[n], R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row13" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row13">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@Rm+,Rn</span>
<span>(Rm) → sign extension → Rn, Rm+1 → Rm</span>
<span id="0110nnnnmmmm0100" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBP (int m, int n)
{
  R[n] = Read_8 (R[m]);
  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  if (n != m)
    R[m] += 1;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row14" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row14">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@Rm+,Rn</span>
<span>(Rm) → sign extension → Rn, Rm+2 → Rm</span>
<span id="0110nnnnmmmm0101" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWP (int m, int n)
{
  R[n] = Read_16 (R[m]);
  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  if (n != m)
    R[m] += 2;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row15" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row15">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@Rm+,Rn</span>
<span>(Rm) → Rn, Rm+4 → Rm</span>
<span id="0110nnnnmmmm0110" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />MOV.L @R0+,R1 ;Before execution: R0 = H'12345670
;After execution: R0 = H'12345674, R1 = @H'12345670
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLP (int m, int n)
{
  R[n] = Read_32 (R[m]);

  if (n != m)
    R[m] += 4;

  PC += 2;
}

</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row16" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row16">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	Rm,@-Rn</span>
<span>Rn-1 → Rn, Rm → (Rn)</span>
<span id="0010nnnnmmmm0100" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBM (int m, int n)
{
  Write_8 (R[n] - 1, R[m]);
  R[n] -= 1;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row17" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row17">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	Rm,@-Rn</span>
<span>Rn-2 → Rn, Rm → (Rn)</span>
<span id="0010nnnnmmmm0101" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWM (int m, int n)
{
  Write_16 (R[n] - 2, R[m]);
  R[n] -= 2;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.w  r0,@–r1 ! Before execution: r0 = 0xAAAAAAAA, r1 = 0xFFFF7F80
      After execution: r1 = 0xFFFF7F7E, @r1 = 0xAAAA
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row18" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row18">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	Rm,@-Rn</span>
<span>Rn-4 → Rn, Rm → (Rn)</span>
<span id="0010nnnnmmmm0110" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLM (int m, int n)
{
  Write_32 (R[n] - 4, R[m]);
  R[n] -= 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row19" />
<label class="summary SH2A" for="row19">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@-Rm,R0</span>
<span>Rm-1 → Rm, (Rm) → sign extension → R0</span>
<span id="0100mmmm11001011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11001011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRSBM (int m)
{
  R[m] -= 1;
  R[0] = Read_16 (R[m]);

  if ((R[0] & 0x80) == 0)
    R[0] &= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC+=2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row20" />
<label class="summary SH2A" for="row20">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@-Rm,R0</span>
<span>Rm-2 → Rm, (Rm) → sign extension → R0</span>
<span id="0100mmmm11011011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11011011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRSWM (int m)
{
  R[m]-= 2;
  R[0] = Read_16 (R[m]);

  if ((R[0] & 0x8000) == 0)
    R[0] &= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row21" />
<label class="summary SH2A" for="row21">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@-Rm,R0</span>
<span>Rm-4 → Rm, (Rm) → R0</span>
<span id="0100mmmm11101011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11101011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRSLM (int m)
{
  R[m] -= 4;
  R[0] = Read_32 (R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row22" />
<label class="summary SH2A" for="row22">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	R0,@Rn+</span>
<span>R0 → (Rn), Rn+1 → Rn</span>
<span id="0100nnnn10001011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10001011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRSBP (int n)
{
  Write_8 (R[n], R[0]);
  R[n] += 1;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row23" />
<label class="summary SH2A" for="row23">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	R0,@Rn+</span>
<span>R0 → (Rn), Rn+2 → Rn</span>
<span id="0100nnnn10011011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10011011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRSWP (int n)
{
  Write_16 (R[n], R[0]);
  R[n] += 2;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row24" />
<label class="summary SH2A" for="row24">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	R0,@Rn+</span>
<span>R0 → (Rn), Rn+4 → Rn</span>
<span id="0100nnnn10101011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10101011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRSLP (int n)
{
  Write_32 (R[n], R[0]);
  R[n] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row25" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row25">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@(disp,Rm),R0</span>
<span>(disp + Rm) → sign extension → R0</span>
<span id="10000100mmmmdddd" class="colorized"><span title="Opcode Identifier">10000100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Displacement (4 bits)">dddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Structure Data</span>
<br />
<br />Transfers the source operand to the destination.
The 4-bit displacement is only zero-extended, so a range up to +15 bytes
can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can
be used instead.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBL4 (int m, int d)
{
  long disp = (0x0000000F & (long)d);
  R[0] = Read_8 (R[m] + disp);

  if ((R[0] & 0x80) == 0)
    R[0] &= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row26" />
<label class="summary SH2A" for="row26">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@(disp12,Rm),Rn</span>
<span>(disp + Rm) → sign extension → Rn</span>
<span id="0011nnnnmmmm0001_0100dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0100</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_8 (R[m] + disp);

  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 4;
}

</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row27" />
<label class="summary SH2A" for="row27">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movu.b	@(disp12,Rm),Rn</span>
<span>(disp + Rm) → zero extension → Rn</span>
<span id="0011nnnnmmmm0001_1000dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">1000</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers a source operand to a destination, performing unsigned data transfer.
This instruction is ideal for data access in a structure or the stack.
The loaded data is zero-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBUL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_8 (R[m] + disp);
  R[n] &= 0x000000FF;
  PC += 4;
}
</span>
</span>
</label>
<input type="checkbox" id="row28" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row28">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@(disp,Rm),R0</span>
<span>(disp × 2 + Rm) → sign extension → R0</span>
<span id="10000101mmmmdddd" class="colorized"><span title="Opcode Identifier">10000101</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Displacement (4 bits)">dddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Structure Data</span>
<br />
<br />Transfers the source operand to the destination.
The 4-bit displacement is multiplied by two after zero-extension, enabling a
range up to +30 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWL4 (int m, int d)
{
  long disp = (0x0000000F & (long)d);
  R[0] = Read_16 (R[m] + (disp &lt;&lt; 1));

  if ((R[0] & 0x8000) == 0)
    R[0] &= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row29" />
<label class="summary SH2A" for="row29">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@(disp12,Rm),Rn</span>
<span>(disp × 2 + Rm) → sign extension → Rn</span>
<span id="0011nnnnmmmm0001_0101dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0101</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));

  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row30" />
<label class="summary SH2A" for="row30">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movu.w	@(disp12,Rm),Rn</span>
<span>(disp × 2 + Rm) → zero extension → Rn</span>
<span id="0011nnnnmmmm0001_1001dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">1001</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers a source operand to a destination, performing unsigned data transfer.
This instruction is ideal for data access in a structure or the stack.
The loaded data is zero-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWUL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));
  R[n] &= 0x0000FFFF;
  PC += 4;
}
</span>
</span>
</label>
<input type="checkbox" id="row31" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row31">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@(disp,Rm),Rn</span>
<span>(disp × 4 + Rm) → Rn</span>
<span id="0101nnnnmmmmdddd" class="colorized"><span title="Opcode Identifier">0101</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Displacement (4 bits)">dddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Structure Data</span>
<br />
<br />Transfers the source operand to the destination.
The 4-bit displacement is multiplied by four after zero-extension, enabling a
range up to +60 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLL4 (int m, int d, int n)
{
  long disp = (0x0000000F & (long)d);
  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  @(2,r0),r1 ! Before execution: @(r0 + 8) = 0x12345670
      After execution: r1 = 0x12345670
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row32" />
<label class="summary SH2A" for="row32">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@(disp12,Rm),Rn</span>
<span>(disp × 4 + Rm) → Rn</span>
<span id="0011nnnnmmmm0001_0110dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0110</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row33" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row33">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	R0,@(disp,Rn)</span>
<span>R0 → (disp + Rn)</span>
<span id="10000000nnnndddd" class="colorized"><span title="Opcode Identifier">10000000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Displacement (4 bits)">dddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Move Structure Data</span>
<br />
<br />Transfers the source operand to the destination.
The 4-bit displacement is only zero-extended, so a range up to +15 bytes
can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can
be used instead.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBS4 (int d, int n)
{
  long disp = (0x0000000F & (long)d);
  Write_8 (R[n] + disp, R[0]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row34" />
<label class="summary SH2A" for="row34">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	Rm,@(disp12,Rn)</span>
<span>Rm → (disp + Rn)</span>
<span id="0011nnnnmmmm0001_0000dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0000</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBS12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  Write_8 (R[n] + disp, R[m]);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row35" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row35">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	R0,@(disp,Rn)</span>
<span>R0 → (disp × 2 + Rn)</span>
<span id="10000001nnnndddd" class="colorized"><span title="Opcode Identifier">10000001</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Displacement (4 bits)">dddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Move Structure Data</span>
<br />
<br />Transfers the source operand to the destination.
The 4-bit displacement is multiplied by two after zero-extension, enabling a
range up to +30 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWS4 (int d, int n)
{
  long disp = (0x0000000F & (long)d);
  Write_16 (R[n] + (disp &lt;&lt; 1), R[0]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row36" />
<label class="summary SH2A" for="row36">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	Rm,@(disp12,Rn)</span>
<span>Rm → (disp × 2 + Rn)</span>
<span id="0011nnnnmmmm0001_0001dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0001</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWS12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  Write_16 (R[n] + (disp &lt;&lt; 1), R[m]);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row37" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row37">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	Rm,@(disp,Rn)</span>
<span>Rm → (disp × 4 + Rn)</span>
<span id="0001nnnnmmmmdddd" class="colorized"><span title="Opcode Identifier">0001</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Displacement (4 bits)">dddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Move Structure Data</span>
<br />
<br />Transfers the source operand to the destination.
The 4-bit displacement is multiplied by four after zero-extension, enabling a
range up to +60 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLS4 (int m, int d, int n)
{
  long disp = (0x0000000F & (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  r0,@(0xf,r1) ! Before execution: r0 = 0xFFFF7F80
      After execution: @(r1 + 60) = 0xFFFF7F80
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row38" />
<label class="summary SH2A" for="row38">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	Rm,@(disp12,Rn)</span>
<span>Rm → (disp × 4 + Rn)</span>
<span id="0011nnnnmmmm0001_0010dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0010</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLS12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row39" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row39">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@(R0,Rm),Rn</span>
<span>(R0 + Rm) → sign extension → Rn</span>
<span id="0000nnnnmmmm1100" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBL0 (int m, int n)
{
  R[n] = Read_8 (R[m] + R[0]);

  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else R[n] |= 0xFFFFFF00;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row40" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row40">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@(R0,Rm),Rn</span>
<span>(R0 + Rm) → sign extension → Rn</span>
<span id="0000nnnnmmmm1101" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWL0 (int m, int n)
{
  R[n] = Read_16 (R[m] + R[0]);

  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.w  @(r0,r2),r1 ! Before execution: r2 = 0x00000004, r0 = 0x10000000
      After execution: r1 = @0x10000004
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row41" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row41">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@(R0,Rm),Rn</span>
<span>(R0 + Rm) → Rn</span>
<span id="0000nnnnmmmm1110" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLL0 (int m, int n)
{
  R[n] = Read_32 (R[m] + R[0]);
  PC += 2;
}

</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row42" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row42">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	Rm,@(R0,Rn)</span>
<span>Rm → (R0 + Rn)</span>
<span id="0000nnnnmmmm0100" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBS0 (int m, int n)
{
  Write_8 (R[n] + R[0], R[m]);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.b  r1,@(r0,r2) ! Before execution: r2 = 0x00000004, r0 = 0x10000000
      After execution: r1 = @0x10000004
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row43" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row43">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	Rm,@(R0,Rn)</span>
<span>Rm → (R0 + Rn)</span>
<span id="0000nnnnmmmm0101" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWS0 (int m, int n)
{
  Write_16 (R[n] + R[0], R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row44" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row44">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	Rm,@(R0,Rn)</span>
<span>Rm → (R0 + Rn)</span>
<span id="0000nnnnmmmm0110" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand to the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLS0 (int m, int n)
{
  Write_32 (R[n] + R[0], R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row45" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row45">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	@(disp,GBR),R0</span>
<span>(disp + GBR) → sign extension → R0</span>
<span id="11000100dddddddd" class="colorized"><span title="Opcode Identifier">11000100</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Global Data</span>
<br />
<br />Transfers the source operand to the destination.
The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be
specified.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBLG (int d)
{
  unsigned int disp = (0x000000FF & d);
  R[0] = Read_8 (GBR + disp);

  if ((R[0] & 0x80) == 0)
    R[0] &= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row46" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row46">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	@(disp,GBR),R0</span>
<span>(disp × 2 + GBR) → sign extension → R0</span>
<span id="11000101dddddddd" class="colorized"><span title="Opcode Identifier">11000101</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Global Data</span>
<br />
<br />Transfers the source operand to the destination.
The 8-bit displacement is multiplied by two after zero-extension, enabling a
range up to +510 bytes to be specified.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWLG (int d)
{
  unsigned int disp = (0x000000FF & d);
  R[0] = Read_16 (GBR + (disp &lt;&lt; 1));

  if ((R[0] & 0x8000) == 0)
    R[0] &= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row47" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row47">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	@(disp,GBR),R0</span>
<span>(disp × 4 + GBR) → R0</span>
<span id="11000110dddddddd" class="colorized"><span title="Opcode Identifier">11000110</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Move Global Data</span>
<br />
<br />Transfers the source operand to the destination.
The 8-bit displacement is multiplied by four after zero-extension, enabling a
range up to +1020 bytes to be specified.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLLG (int d)
{
  unsigned int disp = (0x000000FF & d);
  R[0] = Read_32 (GBR + (disp &lt;&lt; 2));
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row48" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row48">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b	R0,@(disp,GBR)</span>
<span>R0 → (disp + GBR)</span>
<span id="11000000dddddddd" class="colorized"><span title="Opcode Identifier">11000000</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Move Global Data</span>
<br />
<br />Transfers the source operand to the destination.
The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be
specified.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVBSG (int d)
{
  unsigned int disp = (0x000000FF & d);
  Write_8 (GBR + disp, R[0]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row49" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row49">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w	R0,@(disp,GBR)</span>
<span>R0 → (disp × 2 + GBR)</span>
<span id="11000001dddddddd" class="colorized"><span title="Opcode Identifier">11000001</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Move Global Data</span>
<br />
<br />Transfers the source operand to the destination.
The 8-bit displacement is multiplied by two after zero-extension, enabling a
range up to +510 bytes to be specified.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVWSG (int d)
{
  unsigned int disp = (0x000000FF & d);
  Write_16 (GBR + (disp &lt;&lt; 1), R[0]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row50" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row50">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l	R0,@(disp,GBR)</span>
<span>R0 → (disp × 4 + GBR)</span>
<span id="11000010dddddddd" class="colorized"><span title="Opcode Identifier">11000010</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Move Global Data</span>
<br />
<br />Transfers the source operand to the destination.
The 8-bit displacement is multiplied by four after zero-extension, enabling a
range up to +1020 bytes to be specified.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLSG (int d)
{
  unsigned int disp = (0x000000FF & (long)d);
  Write_32 (GBR + (disp &lt;&lt; 2), R[0]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row51" />
<label class="summary SH4A" for="row51">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movco.l	R0,@Rn</span>
<span>LDST → T
If (T == 1): R0 → Rn
0 → LDST</span>
<span id="0000nnnn01110011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01110011</span></span>
<span>LDST → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />MOVCO is used in combination with MOVLI to realize an atomic read-modify-write
operation in a single processor.<br /><br />
This instruction copies the value of the LDST flag to the T bit. When the T bit
is set to 1, the value of R0 is stored at the address in Rm. If the T bit is
cleared to 0, the value is not stored at the address in Rm. Finally, the LDST
flag is cleared to 0. Since the LDST flag is cleared by an instruction or
exception, storage by the MOVCO instruction only proceeds when no interrupt or
exception has occurred between the execution of the MOVLI and MOVCO instructions.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVCO (int n)
{
  T = LDST;
  if (T == 1)
    Write_32 (R[n], R[0]);

  LDST = 0;
  PC += 2
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row52" />
<label class="summary SH4A" for="row52">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movli.l	@Rm,R0</span>
<span>1 → LDST
(Rm) → R0
When interrupt/exception occured: 0 → LDST</span>
<span id="0000mmmm01100011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01100011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />MOVLI is used in combination with MOVCO to realize an atomic read-modify-write
operation in a single processor.<br /><br />
This instruction sets the LDST flag to 1 and reads the four bytes of data
indicated by Rm into R0. If, however, an interrupt or exception occurs, LDST is
cleared to 0. Storage by the MOVCO instruction only proceeds when the
instruction is executed after the LDST bit has been set by the MOVLI instruction
and not cleared by an interrupt or other exception.  When LDST has been cleared
to 0, the MOVCO instruction clears the T bit and does not proceed with storage.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLINK (int m)
{
  LDST = 1;
  R[0] = Read_32 (R[m]);
  PC += 2
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row53" />
<label class="summary SH4A" for="row53">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movua.l	@Rm,R0</span>
<span>(Rm) → R0
Load non-boundary alignment data</span>
<span id="0100mmmm10101001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">10101001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Loads the longword of data from the effective address indicated
by the contents of Rm in memory to R0. The address is not restricted to longword
boundaries address (4n).  This instruction allows loading from
non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error
exceptions do not occur when access is to non-longword-boundary addresses
(4n + 1, 4n + 2, and 4n + 3).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVUAL (int m)
{
  Read_Unaligned_32 (R0, R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error (when the privileged area is accessed from user mode)</var>
</span>
</span>
</label>
<input type="checkbox" id="row54" />
<label class="summary SH4A" for="row54">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movua.l	@Rm+,R0</span>
<span>(Rm) → R0, Rm + 4 → Rm
Load non-boundary alignment data</span>
<span id="0100mmmm11101001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11101001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Loads the longword of data from the effective address indicated
by the contents of Rm in memory to R0. The address is not restricted to longword
boundaries address (4n).  This instruction allows loading from
non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error
exceptions do not occur when access is to non-longword-boundary addresses
(4n + 1, 4n + 2, and 4n + 3).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVUALP (int m)
{
  Read_Unaligned_32 (R0,R[m]);

  if (m != 0)
    R[m] += 4;

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error (when the privileged area is accessed from user mode)</var>
</span>
</span>
</label>
<input type="checkbox" id="row55" />
<label class="summary SH2A" for="row55">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movml.l	Rm,@-R15</span>
<span>R15-4 → R15, Rm → (R15)
R15-4 → R15, Rm-1 → (R15)
...
...
R15 - 4 → R15, R0 → (R15)
Note: When Rm = R15, read Rm as PR</span>
<span id="0100mmmm11110001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11110001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1-16</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1-16</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (R0 to Rn/Rm) not exceeding the specified
register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, PR is transferred instead of R15. That is, when
nnnn(mmmm) = 1111 is specified, R0 to R14 and PR are the general registers
subject to transfer.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLMML (int m)
{
  for (int i = m; i &gt;= 0; i--)
  {
    if (i == 15)
      Write_32 (R[15] - 4, PR);
    else
      Write_32 (R[15] - 4, R[i]);

    R[15] -= 4;
  }

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row56" />
<label class="summary SH2A" for="row56">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movml.l	@R15+,Rn</span>
<span>(R15) → R0, R15+4 → R15
(R15) → R1, R15+4 → R15
...
...
(R15) → Rn
Note: When Rn = R15, read Rn as PR</span>
<span id="0100nnnn11110101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11110101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1-16</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2-17</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (R0 to Rn/Rm) not exceeding the specified
register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, PR is transferred instead of R15. That is, when
nnnn(mmmm) = 1111 is specified, R0 to R14 and PR are the general registers
subject to transfer.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLPML (int n)
{
  for (int i = 0; i &lt;= n; i++)
  {
    if (i == 15)
      PR = Read_32 (R[15]);
    else
      R[i] = Read_32 (R[15]);

    R[15] += 4;
  }

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row57" />
<label class="summary SH2A" for="row57">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movmu.l	Rm,@-R15</span>
<span>R15-4 → R15, PR → (R15)
R15-4 → R15, R14 → (R15)
...
...
R15-4 → R15, Rm → (R15)
Note: When Rm = R15, read Rm as PR</span>
<span id="0100mmmm11110000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11110000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1-16</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1-16</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (Rn/Rm to R14, PR) not lower than the
specified register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, PR is transferred instead of R15.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLMMU (int m)
{
  Write_32 (R[15] - 4, PR);
  R[15] -= 4;

  for (int i = 14; i &gt;= m; i--)
  {
    Write_32 (R[15] - 4, R[i]);
    R[15] -= 4;
  }

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row58" />
<label class="summary SH2A" for="row58">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movmu.l	@R15+,Rn</span>
<span>(R15) → Rn, R15+4 → R15
(R15) → Rn+1, R15+4 → R15
...
...
(R15) → R14, R15+4 → R15
(R15) → PR
Note: When Rn = R15, read Rn as PR</span>
<span id="0100nnnn11110100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11110100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1-16</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2-17</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (Rn/Rm to R14, PR) not lower than the
specified register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, PR is transferred instead of R15.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVLPMU (int n)
{
  for (int i = n; i &lt;= 14; i++)
  {
    R[i] = Read_32 (R[15]);
    R[15] += 4;
  }

  PR = Read_32 (R[15]);
  R[15] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row59" />
<label class="summary SH2A" for="row59">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movrt	Rn</span>
<span>~T → Rn</span>
<span id="0000nnnn00111001" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00111001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Reverses the T bit and then stores the resulting value in general register Rn.
The value of Rn is 0 when T = 1 and 1 when T = 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVRT (int n)
{
  if (T == 1)
    R[n] = 0x00000000;
  else
    R[n] = 0x00000001;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row60" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row60">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movt	Rn</span>
<span>T → Rn</span>
<span id="0000nnnn00101001" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00101001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the T bit in general register Rn.
The value of Rn is 1 when T = 1 and 0 when T = 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVT (int n)
{
  if (T == 1)
    R[n] = 0x00000001;
  else
    R[n] = 0x00000000;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">xor    r2,r2   ! r2 = 0
cmp   /pz r2   ! T = 1
movt   r0      ! r0 = 1
clrt           ! T = 0
movt   r1      ! r1 = 0
</span>
</span>
</label>
<input type="checkbox" id="row61" />
<label class="summary SH2A" for="row61">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nott</span>
<span>~T → T</span>
<span id="0000000001101000" class="colorized"><span title="Opcode Identifier">0000000001101000</span></span>
<span>~T → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts the T bit, then stores the resulting value in the T bit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void NOTT (void)
{
  if (T == 1)
    T = 0;
  else
    T = 1;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row62" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row62">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>swap.b	Rm,Rn</span>
<span>Rm → swap lower 2 bytes → Rn</span>
<span id="0110nnnnmmmm1000" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Swaps the upper and lower parts of the contents of general register Rm and
stores the result in Rn.
The 8 bits from bit 15 to bit 8 of Rm are swapped with the 8 bits from bit 7 to
bit 0. The upper 16 bits of Rm are transferred directly to the upper 16 bits of
Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SWAPB (int m, int n)
{
  unsigned long temp0, temp1;
  temp0 = R[m] & 0xFFFF0000;
  temp1 = (R[m] & 0x000000FF) &lt;&lt; 8;
  R[n] = (R[m] & 0x0000FF00) &gt;&gt; 8;
  R[n] = R[n] | temp1 | temp0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">swap.b r0,r1   ! Before execution: r0 = 0x12345678
      After execution: r1 = 0x12347856
</span>
</span>
</label>
<input type="checkbox" id="row63" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row63">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>swap.w	Rm,Rn</span>
<span>Rm → swap upper/lower words → Rn</span>
<span id="0110nnnnmmmm1001" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Swaps the upper and lower parts of the contents of general register Rm and
stores the result in Rn.
The 16 bits from bit 31 to bit 16 of Rm are swapped with the 16 bits from bit
15 to bit 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SWAPW (int m, int n)
{
  unsigned long temp;
  temp = (R[m] &gt;&gt; 16) & 0x0000FFFF;
  R[n] = R[m] &lt;&lt; 16;
  R[n] |= temp;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">swap.w r0,r1   ! Before execution: r0 = 0x12345678
      After execution: r1 = 0x5678123
</span>
</span>
</label>
<input type="checkbox" id="row64" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row64">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xtrct	Rm,Rn</span>
<span>Rm:Rn middle 32 bits → Rn</span>
<span id="0010nnnnmmmm1101" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Extracts the middle 32 bits from the 64-bit contents of linked general registers
Rm and Rn, and stores the result in Rn.
<br /><img alt="Extract operation" src="xtrct.svg" height="110" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void XTRCT (int m, int n)
{
  unsigned long high = (R[m] &lt;&lt; 16) & 0xFFFF0000;
  unsigned long low = (R[n] &gt;&gt; 16) & 0x0000FFFF;
  R[n] = high | low;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">xtrct  r0,r1   ! Before execution: r0 = 0x01234567, r1 = 0x89ABCDEF
      After execution: r1 = 0x456789AB
</span>
</span>
</label>
<br/><br/><br/><b>Bit Manipulation Instructions</b><br/><br/>
<input type="checkbox" id="row65" />
<label class="summary SH2A" for="row65">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>band.b     #imm3,@disp12,Rn</span>
<span>(imm of (disp+Rn)) & T → T</span>
<span id="0011nnnn0iii1001_0100dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0100</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs a specified bit in memory at the address indicated by (disp + Rn) with the
T bit, and stores the result in the T bit. The bit number is specified by 3-bit
immediate data. With this instruction, data is read from memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BANDM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 0) || (assignbit == 0))
    T = 0;
  else
    T = 1;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row66" />
<label class="summary SH2A" for="row66">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bandnot.b  #imm3,@(disp12,Rn)</span>
<span>~(imm of (disp+Rn)) & T → T</span>
<span id="0011nnnn0iii1001_1100dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">1100</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the value obtained by inverting a specified bit of memory at the address
indicated by (disp + Rn) with the T bit, and stores the result in the T bit.
The bit number is specified by 3-bit immediate data. With this instruction, data
is read from memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BANDNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 1) && (assignbit == 0))
    T = 1;
  else
    T = 0;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row67" />
<label class="summary SH2A" for="row67">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bclr.b     #imm3,@(disp12,Rn)</span>
<span>0 → (imm of (disp+Rn))</span>
<span id="0011nnnn0iii1001_0000dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0000</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears a specified bit of memory at the address indicated by (disp + Rn).
The bit number is specified by 3-bit immediate data. After data is read from
memory as a byte unit, clearing of the specified bit is executed and the
resulting data is then written to memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BCLRM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  temp &= (~(0x00000001 &lt; &lt;imm));
  Write_8 (R[n] + disp, temp);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row68" />
<label class="summary SH2A" for="row68">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bclr       #imm3,Rn</span>
<span>0 → imm of Rn</span>
<span id="10000110nnnn0iii" class="colorized"><span title="Opcode Identifier">10000110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears a specified bit of the LSB 8 bits of a general register Rn.
The bit number is specified by 3-bit immediate data.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLR (int i, int n)
{
  long imm, temp;
  imm = (0x00000007 & (long)i);
  R[n] &= (~(0x00000001 &lt;&lt; imm));
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row69" />
<label class="summary SH2A" for="row69">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bld.b      #imm3,@(disp12,Rn)</span>
<span>(imm of (disp+Rn)) → T</span>
<span id="0011nnnn0iii1001_0011dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0011</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a specified bit of memory at the address indicated by (disp + Rn) in the
T bit. The bit number is specified by 3-bit immediate data. Data is read from
memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BLDM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if (assignbit == 0)
    T = 0;
  else
    T = 1;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row70" />
<label class="summary SH2A" for="row70">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bld        #imm3,Rn</span>
<span>imm of Rn → T</span>
<span id="10000111nnnn1iii" class="colorized"><span title="Opcode Identifier">10000111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">1</span><span title="Unsigned Immediate Data (3 bits)">iii</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a specified bit of the LSB 8 bits of a general register Rn in the T bit.
The bit number is specified by 3-bit immediate data.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BLD (int i, int n)
{
  long imm, assignbit;
  imm = (0x00000007 & (long)i);
  assignbit = (0x00000001 &lt;&lt; imm) & R[n];

  if (assignbit == 0)
    T = 0;
  else
    T = 1;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row71" />
<label class="summary SH2A" for="row71">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bldnot.b   #imm3,@(disp12,Rn)</span>
<span>~(imm of (disp+Rn)) → T</span>
<span id="0011nnnn0iii1001_1011dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">1011</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts a specified bit of memory at the address indicated by (disp + Rn), and
stores the resulting value in the T bit. The bit number is specified by 3-bit
immediate data. Data is read from memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BLDNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if (assignbit == 0)
    T = 1;
  else
    T = 0;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row72" />
<label class="summary SH2A" for="row72">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bor.b      #imm3,@(disp12,Rn)</span>
<span>(imm of (disp+Rn)) | T → T</span>
<span id="0011nnnn0iii1001_0101dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0101</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ORs a specified bit in memory at the address indicated by (disp + Rn) with the
T bit, and stores the result in the T bit. The bit number is specified by 3-bit
immediate data. Data is read from memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BORM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 0) && (assignbit == 0))
    T = 0;
  else
    T = 1;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row73" />
<label class="summary SH2A" for="row73">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bornot.b   #imm3,@(disp12,Rn)</span>
<span>~(imm of (disp+Rn)) | T → T</span>
<span id="0011nnnn0iii1001_1101dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">1101</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ORs the value obtained by inverting a specified bit of memory at the address
indicated by (disp + Rn) with the T bit, and stores the result in the T bit.
The bit number is specified by 3-bit immediate data. With this instruction,
data is read from memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BORNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 1) || (assignbit == 0))
    T = 1;
  else
    T = 0;

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row74" />
<label class="summary SH2A" for="row74">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bset.b     #imm3,@(disp12,Rn)</span>
<span>1 → (imm of (disp+Rn))</span>
<span id="0011nnnn0iii1001_0001dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0001</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sets to 1 a specified bit of memory at the address indicated by (disp + Rn).
The bit number is specified by 3-bit immediate data. After data is read from
memory as a byte unit, the specified bit is set to 1, and the resulting data is
then written to memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BSETM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  temp |= (0x00000001 &lt;&lt; imm);
  Write_8 (R[n] + disp, temp);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row75" />
<label class="summary SH2A" for="row75">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bset       #imm3,Rn</span>
<span>1 → imm of Rn</span>
<span id="10000110nnnn1iii" class="colorized"><span title="Opcode Identifier">10000110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">1</span><span title="Unsigned Immediate Data (3 bits)">iii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sets to 1 a specified bit of the LSB 8 bits of a general register Rn. The bit
number is specified by 3-bit immediate data.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BSET (int i, int n)
{
  long imm, temp;
  imm = (0x00000007 & (long)i);
  R[n] |= (0x00000001 &lt;&lt; imm);
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row76" />
<label class="summary SH2A" for="row76">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bst.b      #imm3,@(disp12,Rn)</span>
<span>T → (imm of (disp+Rn))</span>
<span id="0011nnnn0iii1001_0010dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0010</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the contents of the T bit to a specified 1-bit location of memory at
the address indicated by (disp + Rn). The bit number is specified by 3-bit
immediate data. After data is read from memory as a byte unit, transfer from the
T bit to the specified bit is executed, and the resulting data is then written
to memory as a byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BSTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);

  if (T == 0)
    temp &= (~(0x00000001 &lt;&lt; imm));
  else
    temp |= (0x00000001 &lt;&lt; imm);

  Write_8 (R[n] + disp, temp);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row77" />
<label class="summary SH2A" for="row77">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bst        #imm3,Rn</span>
<span>T → imm of Rn</span>
<span id="10000111nnnn0iii" class="colorized"><span title="Opcode Identifier">10000111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the contents of the T bit to a specified 1-bit location of the
LSB 8 bits of a general register Rn. The bit number is specified by 3-bit
immediate data.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BST (int i, int n)
{
  long disp, imm;
  disp = (0x00000FFF & (long)d);
  imm = (0x00000007 & (long)i);

  if (T == 0)
    R[n] &= (~(0x00000001 &lt;&lt; imm));
  else
    R[n] |= (0x00000001 &lt;&lt; imm);

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row78" />
<label class="summary SH2A" for="row78">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bxor.b     #imm3,@(disp12,Rn)</span>
<span>(imm of (disp+Rn)) ^ T → T</span>
<span id="0011nnnn0iii1001_0110dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">0</span><span title="Unsigned Immediate Data (3 bits)">iii</span><span title="Opcode Identifier">1001</span> <span title="Opcode Identifier">0110</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Exclusive-ORs a specified bit in memory at the address indicated by (disp + Rn)
with the T bit, and stores the result in the T bit. The bit number is specified
by 3-bit immediate data. With this instruction, data is read from memory as a
byte unit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BXORM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if (assignbit == 0)
  {
    if (T == 0)
      T = 0;
    else
      T = 1;
  }
  else
  {
    if (T == 0)
      T = 1;
    else
      T = 0;
  }

  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<br/><br/><br/><b>Arithmetic Operation Instructions</b><br/><br/>
<input type="checkbox" id="row79" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row79">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>add	Rm,Rn</span>
<span>Rn + Rm → Rn</span>
<span id="0011nnnnmmmm1100" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds together the contents of general registers Rn and Rm and stores the
result in Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ADD (int m, int n)
{
  R[n] += R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">add    r0,r1   ! Before execution: r0 = 0x7FFFFFFF, r1 = 0x00000001
      After execution: r1 = 0x80000000
</span>
</span>
</label>
<input type="checkbox" id="row80" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row80">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>add	#imm,Rn</span>
<span>Rn + (sign extension)imm</span>
<span id="0111nnnniiiiiiii" class="colorized"><span title="Opcode Identifier">0111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds together the contents of general register Rn and the immediate value
and stores the result in Rn.  The 8-bit immediate value is sign-extended to
32 bits, which allows it to be used for immediate subtraction or decrement
operations.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ADDI (int i, int n)
{
  if ((i & 0x80) == 0)
    R[n] += (0x000000FF & (long)i);
  else
    R[n] += (0xFFFFFF00 | (long)i);

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">add    #0x01,r2 ! Before execution: r2 = 0x00000000
      After execution: r2 = 0x00000001
add    #0xfe,r3 ! Before execution: r3 = 0x00000001
      After execution: r3 = 0xFFFFFFFF
</span>
</span>
</label>
<input type="checkbox" id="row81" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row81">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>addc	Rm,Rn</span>
<span>Rn + Rm + T → Rn, carry → T</span>
<span id="0011nnnnmmmm1110" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1110</span></span>
<span>Carry → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds together the contents of general registers Rn and Rm and the T bit, and
stores the result in Rn.  A carry resulting from the operation is reflected in
the T bit.  This instruction can be used to implement additions exceeding 32
bits.

<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ADDC (int m, int n)
{
  unsigned long tmp0, tmp1;
  tmp1 = R[n] + R[m];
  tmp0 = R[n];
  R[n] = tmp1 + T;

  if (tmp0&gt;tmp1)
    T = 1;
  else
    T = 0;

  if (tmp1 &gt; R[n])
    T = 1;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">clrt           ! r0:r1 (64 bits) + r2:r3 (64 bits) = r0:r1 (64 bits)
addc   r3,r1   ! Before execution: T = 0, r1 = 0x00000001, r3 = 0xFFFFFFFF
      After execution: T = 1, r1 = 0x00000000
addc   r2,r0   ! Before execution: T = 1, r0 = 0x00000000, r2 = 0x00000000
      After execution: T = 0, r0 = 0x00000001
</span>
</span>
</label>
<input type="checkbox" id="row82" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row82">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>addv	Rm,Rn</span>
<span>Rn + Rm → Rn, overflow → T</span>
<span id="0011nnnnmmmm1111" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1111</span></span>
<span>Overflow → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds together the contents of general registers Rn and Rm and stores the result
in Rn.  If overflow occurs, the T bit is set.

<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ADDV (int m, int n)
{
  long dest, src, ans;

  if ((long)R[n] &gt;= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)R[m] &gt;= 0)
    src = 0;
  else
    src = 1;

  src += dest;
  R[n] += R[m];

  if ((long)R[n] &gt;= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (src == 0 || src == 2)
  {
    if (ans == 1)
      T = 1;
    else
      T = 0;
  }
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">addv   r0,r1   ! Before execution: r0 = 0x00000001, r1 = 0x7FFFFFFE, T = 0
      After execution: r1 = 0x7FFFFFFF, T = 0
addv   r0,r1   ! Before execution: r0 = 0x00000002, r1 = 0x7FFFFFFE, T = 0
      After execution: r1 = 0x80000000, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row83" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row83">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/eq	#imm,R0</span>
<span>If R0 = (sign extension)imm: 1 → T
Else: 0 → T</span>
<span id="10001000iiiiiiii" class="colorized"><span title="Opcode Identifier">10001000</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general register R0 and the sign-extended 8-bit immediate data and sets
the T bit if the values are equal.  If they are not equal the T bit is cleared.
The contents of R0 are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPIM (int i)
{
  long imm;

  if ((i & 0x80) == 0)
    imm = (0x000000FF & (long i));
  else
    imm = (0xFFFFFF00 | (long i));

  if (R[0] == imm)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row84" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row84">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/eq	Rm,Rn</span>
<span>If Rn = Rm: 1 → T
Else: 0 → T</span>
<span id="0011nnnnmmmm0000" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0000</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general registers Rn and Rm, and sets the T bit if they are equal.
The contents of Rn and Rm are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPEQ (int m, int n)
{
  if (R[n] == R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row85" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row85">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/hs	Rm,Rn</span>
<span>If Rn &ge; Rm (unsigned): 1 → T
Else: 0 → T</span>
<span id="0011nnnnmmmm0010" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0010</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general registers Rn and Rm, and sets the T bit if Rn is greater or
equal Rm.  The values for the comparison are interpreted as unsigned integer
values.  The contents of Rn and Rm are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPHI (int m, int n)
{
  if ((unsigned long)R[n] &gt;= (unsigned long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row86" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row86">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/ge	Rm,Rn</span>
<span>If Rn &ge; Rm (signed): 1 → T
Else: 0 → T</span>
<span id="0011nnnnmmmm0011" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0011</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general registers Rn and Rm, and sets the T bit if Rn is greater or
equal Rm.  The values for the comparison are interpreted as signed integer
values.  The contents of Rn and Rm are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPGE (int m, int n)
{
  if ((long)R[n] &gt;= (long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row87" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row87">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/hi	Rm,Rn</span>
<span>If Rn &gt; Rm (unsigned): 1 → T
Else: 0 → T</span>
<span id="0011nnnnmmmm0110" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general registers Rn and Rm, and sets the T bit if Rn is greater Rm.
The values for the comparison are interpreted as unsigned integer values.
The contents of Rn and Rm are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPHI (int m, int n)
{
  if ((unsigned long)R[n] &gt; (unsigned long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row88" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row88">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/gt	Rm,Rn</span>
<span>If Rn &gt; Rm (signed): 1 → T
Else: 0 → T</span>
<span id="0011nnnnmmmm0111" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0111</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general registers Rn and Rm, and sets the T bit if Rn is greater Rm.
The values for the comparison are interpreted as signed integer values.
The contents of Rn and Rm are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPGT (int m, int n)
{
  if ((long)R[n] &gt; (long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row89" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row89">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/pl	Rn</span>
<span>If Rn &gt; 0 (signed): 1 → T
Else: 0 → T</span>
<span id="0100nnnn00010101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00010101</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general register Rn and sets the T bit if Rn is greater 0.  The value
in Rn for the comparison is interpreted as signed integer.  The contents of Rn
are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPPL (int n)
{
  if ((long)R[n] &gt; 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row90" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row90">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/pz	Rn</span>
<span>If Rn &ge; 0 (signed): 1 → T
Else: 0 → T</span>
<span id="0100nnnn00010001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00010001</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general register Rn and sets the T bit if Rn is greater or equal 0.
The value in Rn for the comparison is interpreted as signed integer.  The
contents of Rn are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPPZ (int n)
{
  if ((long)R[n] &gt;= 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row91" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row91">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/str	Rm,Rn</span>
<span>If Rn and Rm have an equal byte: 1 → T
Else: 0 → T</span>
<span id="0010nnnnmmmm1100" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1100</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Compares general registers Rn and Rm, and sets the T bit if any of the 4 bytes
in Rn are equal to the corresponding byte in Rm. The contents of Rn and Rm are
not changed.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can be used to speed up some string operations such as
finding the string length of a zero terminated string or string matching.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CMPSTR (int m, int n)
{
  unsigned long temp;
  long HH, HL, LH, LL;
  temp = R[n] ^ R[m];
  HH = (temp & 0xFF000000) &gt;&gt; 24;
  HL = (temp & 0x00FF0000) &gt;&gt; 16;
  LH = (temp & 0x0000FF00) &gt;&gt; 8;
  LL = temp & 0x000000FF;
  HH = HH && HL && LH && LL;

  if (HH == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">cmp   /str  r2,r3    ! r2 = "abcd", r3 = "xycz"
bt           target   ! t = 1, so branch is taken.
</span>
</span>
</label>
<input type="checkbox" id="row92" />
<label class="summary SH2A" for="row92">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clips.b	Rn</span>
<span>If Rn &gt; 0x0000007F: 0x0000007F → Rn, 1 → CS
If Rn &lt; 0xFFFFFF80: 0xFFFFFF80 → Rn, 1 → CS</span>
<span id="0100nnnn10010001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10010001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Determines saturation. Signed data is used with this instruction. The saturation
upper-limit value is stored in general register Rn if the contents of Rn exceed
the saturation upper-limit value, or the saturation lower-limit value is stored
in Rn if the contents of Rn are less than the saturation lower-limit value, and
the CS bit is set to 1.
The saturation upper-limit value is 0x0000007F (127).
The saturation lower-limit value is 0xFFFFFF80 (-128).
<br /><br />
<span title="section">Note</span>
<br />
<br />The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value or are not less than the saturation
lower-limit value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLIPSB (int n)
{
  if (R[n] &gt; 0x0000007F)
  {
    R[n] = 0x0000007F;
    CS = 1;
  }
  else if (R[n] &lt; 0xFFFFFF80)
  {
    R[n] = 0xFFFFFF80;
    CS = 1;
  }

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row93" />
<label class="summary SH2A" for="row93">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clips.w	Rn</span>
<span>If Rn &gt; 0x00007FFF: 0x00007FFF → Rn, 1 → CS
If Rn &lt; 0xFFFF8000: 0xFFFF8000 → Rn, 1 → CS</span>
<span id="0100nnnn10010101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10010101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Determines saturation. Signed data is used with this instruction. The saturation
upper-limit value is stored in general register Rn if the contents of Rn exceed
the saturation upper-limit value, or the saturation lower-limit value is stored
in Rn if the contents of Rn are less than the saturation lower-limit value, and
the CS bit is set to 1.
The saturation upper-limit value is 0x00007FFF (32767).
The saturation lower-limit value is 0xFFFF8000 (-32768).
<br /><br />
<span title="section">Note</span>
<br />
<br />The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value or are not less than the saturation
lower-limit value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLIPSW (int n)
{
  if (R[n] &gt; 0x00007FFF)
  {
    R[n] = 0x00007FFF;
    CS = 1;
  }
  else if (R[n] &lt; 0xFFFF8000)
  {
    R[n] = 0xFFFF8000;
    CS = 1;
  }

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row94" />
<label class="summary SH2A" for="row94">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clipu.b	Rn</span>
<span>If Rn &gt; 0x000000FF: 0x000000FF → Rn, 1 → CS</span>
<span id="0100nnnn10000001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Determines saturation. Unsigned data is used with this instruction. If the
contents of general register Rn exceed the saturation value, the saturation
value is stored in Rn and the CS bit is set to 1.
The saturation value is 0x000000FF (255).
<br /><br />
<span title="section">Note</span>
<br />
<br />The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLIPUB (int n)
{
  if (R[n] &gt; 0x000000FF)
  {
    R[n] = 0x000000FF;
    CS = 1;
  }

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row95" />
<label class="summary SH2A" for="row95">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clipu.w	Rn</span>
<span>If Rn &gt; 0x0000FFFF: 0x0000FFFF → Rn, 1 → CS</span>
<span id="0100nnnn10000101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Determines saturation. Unsigned data is used with this instruction. If the
contents of general register Rn exceed the saturation value, the saturation
value is stored in Rn and the CS bit is set to 1.
The saturation value is 0x0000FFFF (65535).
<br /><br />
<span title="section">Note</span>
<br />
<br />The CS bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLIPUW (int n)
{
  if (R[n] &gt; 0x0000FFFF)
  {
    R[n] = 0x0000FFFF;
    CS = 1;
  }

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row96" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row96">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>div0s	Rm,Rn</span>
<span>MSB of Rn → Q, MSB of Rm → M, M ^ Q → T</span>
<span id="0010nnnnmmmm0111" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0111</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs initial settings for signed division. This instruction is followed by
a DIV1 instruction that executes 1-digit division, for example, and repeated
division steps are executed to find the quotient. See the description of the
DIV1 instruction for details.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be used to compare the signs of Rm and Rn.  If the
signs of Rm and Rn are equal, T will be set to 0.  If the signs of Rm and Rn
are not equal, T will be set to 1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DIV0S (int m, int n)
{
  if ((R[n] & 0x80000000) == 0)
    Q = 0;
  else
    Q = 1;

  if ((R[m] & 0x80000000) == 0)
    M = 0;
  else
    M = 1;

  T = ! (M == Q);
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row97" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row97">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>div0u</span>
<span>0 → M, 0 → Q, 0 → T</span>
<span id="0000000000011001" class="colorized"><span title="Opcode Identifier">0000000000011001</span></span>
<span>0 → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs initial settings for unsigned division. This instruction is followed by
a DIV1 instruction that executes 1-digit division, for example, and repeated
division steps are executed to find the quotient. See the description of the
DIV1 instruction for details.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DIV0U (void)
{
  M = Q = T = 0;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row98" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row98">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>div1	Rm,Rn</span>
<span>1-step division (Rn / Rm)</span>
<span id="0011nnnnmmmm0100" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0100</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 1-digit division (1-step division) of the 32-bit contents of general
register Rn (dividend) by the contents of Rm (divisor).
The quotient is obtained by repeated execution of this instruction alone or in
combination with other instructions. The specified registers and the M, Q, and
T bits must not be modified during these repeated executions.
<br /><br />
In 1-step division, the dividend is shifted 1 bit to the left, the divisor is
subtracted from this, and the quotient bit is reflected in the Q bit according
to whether the result is positive or negative.
<br /><br />
Detection of division by zero or overflow is not provided. Check for division by
zero and overflow division before executing the division. A remainder operation
is not provided. Find the remainder by finding the product of the divisor and
the obtained quotient, and subtracting this value from the dividend:
<br /><br />
<code>remainder = dividend - (divisor × quotient)</code>
<br /><br />
Initial settings should first be made with the DIV0S or DIV0U instruction. DIV1
is executed once for each bit of the divisor. If a quotient of more than 17
bits is required, place an ROTCL instruction before the DIV1 instruction. See
the examples for details of the division sequence.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DIV1 (int m, int n)
{
  unsigned long tmp0, tmp2;
  unsigned char old_q, tmp1;

  old_q = Q;
  Q = (0x80000000 & R[n]) != 0;
  tmp2 = R[m];
  R[n] &lt;&lt;= 1;
  R[n] |= (unsigned long)T;

  if (old_q == 0)
  {
    if (M == 0)
    {
      tmp0 = R[n];
      R[n] -= tmp2;
      tmp1 = R[n] &gt; tmp0;

      if (Q == 0)
        Q = tmp1;
      else if (Q == 1)
        Q = tmp1 == 0;
    }

    else if (M == 1)
    {
      tmp0 = R[n];
      R[n] += tmp2;
      tmp1 = R[n] &lt; tmp0;

      if (Q == 0)
        Q = tmp1 == 0;
      else if (Q == 1)
        Q = tmp1;
    }
  }

  else if (old_q == 1)
  {
    if (M == 0)
    {
      tmp0 = R[n];
      R[n] += tmp2;
      tmp1 = R[n] &lt; tmp0;

      if (Q == 0)
        Q = tmp1;
      else if (Q == 1)
        Q = tmp1 == 0;
    }

    else if (M == 1)
    {
       tmp0 = R[n];
       R[n] -= tmp2;
       tmp1 = R[n] &gt; tmp0;

       if (Q == 0)
         Q = tmp1 == 0;
       else if (Q == 1)
         Q = tmp1;
    }
  }

  T = (Q == M);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
! r1 (32 bits) / r0 (16 bits) = r1 (16 bits)  (unsigned)

shll16  r0        ! Set divisor in upper 16 bits, clear lower 16 bits to 0

tst     r0,r0     ! Check for division by zero
bt      zero_div

cmp/hs  r0,r1     ! Check for overflow
bt      over_div

div0u             ! Flag initialization

.rept 16
div1    r0,r1     ! Repeat 16 times
.endr

rotcl   r1
extu.w  r1,r1     ! r1 = quotient

- - - - - - - - - - - - - - - -

! r1:r2 (64 bits) / r0 (32 bits) = r2 (32 bits)  (unsigned)

tst     r0,r0     ! Check for division by zero
bt      zero_div

cmp/hs  r0,r1     ! Check for overflow
bt      over_div

div0u             ! Flag initialization

.rept 32
rotcl   r2        ! Repeat 32 times
div1    r0,r1
.endr

rotcl   r2        ! r2 = quotient

- - - - - - - - - - - - - - - -

! r1 (16 bits) / r0 (16 bits) = r1 (16 bits)  (signed)

shll16  r0        ! Set divisor in upper 16 bits, clear lower 16 bits to 0
exts.w  r1,r1     ! Dividend sign-extended to 32 bits
mov     #0,r2
mov     r1,r3
rotcl   r3
subc    r2,r1     ! If dividend is negative, subtract 1
div0s   r0,r1     ! Flag initialization

.rept 16
div1    r0,r1     ! Repeat 16 times
.endr

exts.w  r1,r1
rotcl   r1        ! r1 = quotient (one's complement notation)
addc    r2,r1     ! If MSB of quotient is 1, add 1 to convert to two's complement notation
exts.w  r1,r1     ! r1 = quotient (two's complement notation)

- - - - - - - - - - - - - - - -

! r2 (32 bits) / r0 (32 bits) = r2 (32 bits)  (signed)

mov     r2,r3
rotcl   r3
subc    r1,r1     ! Dividend sign-extended to 64 bits (r1:r2)
mov     #0,r3
subc    r3,r2     ! If dividend is negative, subtract 1 to convert to one's complement notation
div0s   r0,r1     ! Flag initialization

.rept 32
rotcl   r2        ! Repeat 32 times
div1    r0,r1
.endr

rotcl   r2        ! r2 = quotient (one's complement notation)
addc    r3,r2     ! If MSB of quotient is 1, add 1 to convert to two's complement notation
                  ! r2 = quotient (two's complement notation)

- - - - - - - - - - - - - - - -
! r4 (8 bits) / r5 (8 bits) = r0 (8 bits)  (unsigned)

extu.b  r4,r4     ! Optional, not needed if value is known to be zero extended.
extu.b  r5,r5     ! Optional, not needed if value is known to be zero extended.
shll8   r5
div0u

.rept 8
div1    r5,r4     ! Repeat 8 times
.endr

rotcl   r4
extu.b  r4,r0
</span>
</span>
</label>
<input type="checkbox" id="row99" />
<label class="summary SH2A" for="row99">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>divs	R0,Rn</span>
<span>Signed, Rn / R0 → Rn
32 / 32 → 32 bits</span>
<span id="0100nnnn10010100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10010100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>36</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>36</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Executes division of the 32-bit contents of a general register Rn (dividend) by
the contents of R0 (divisor). This instruction executes signed division and
finds the quotient only. A remainder operation is not provided. To obtain the
remainder, find the product of the divisor and the obtained quotient, and
subtract this value from the dividend. The sign of the remainder will be the
same as that of the dividend.
<br /><br />
<span title="section">Note</span>
<br />
<br />An overflow exception will occur if the negative maximum value (0x00000000) is
divided by -1. If division by zero is performed a division by zero exception
will occur.
<br /><br />
If an interrupt is generated while this instruction is being executed, execution
will be halted. The return address will be the start address of this instruction,
and this instruction will be re-executed.  This avoids increased interrupt
latency.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DIVS (int n)
{
  R[n] = R[n] / R[0];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Overflow exception</var>
  <var>Division by zero exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row100" />
<label class="summary SH2A" for="row100">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>divu	R0,Rn</span>
<span>Unsigned, Rn / R0 → Rn
32 / 32 → 32 bits</span>
<span id="0100nnnn10000100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>36</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>36</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Executes division of the 32-bit contents of a general register Rn (dividend) by
the contents of R0 (divisor). This instruction executes unsigned division and
finds the quotient only. A remainder operation is not provided. To obtain the
remainder, find the product of the divisor and the obtained quotient, and
subtract this value from the dividend.
<br /><br />
<span title="section">Note</span>
<br />
<br />A division by zero exception will occur if division by zero is performed.
<br /><br />
If an interrupt is generated while this instruction is being executed, execution
will be halted. The return address will be the start address of this instruction,
and this instruction will be re-executed.  This avoids increased interrupt
latency.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DIVU (int n)
{
  R[n]= (unsigned long)R[n] / (unsigned long)R[0];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Division by zero exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row101" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row101">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dmuls.l	Rm,Rn</span>
<span>Signed, Rn × Rm → MACH:MACL
32 × 32 → 64 bits</span>
<span id="0011nnnnmmmm1101" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var></var><var>2-5</var><var></var><var></var><var>4/4</var><var>2</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 32-bit multiplication of the contents of general register Rn by the
contents of Rm, and stores the 64-bit result in the MACH and MACL registers.
The multiplication is performed as a signed arithmetic operation.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DMULS (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;
  long tempm, tempn, fnLmL;

  tempn = (long)R[n];
  tempm = (long)R[m];

  if (tempn &lt; 0)
    tempn = 0 - tempn;

  if (tempm &lt; 0)
    tempm = 0 - tempm;

  if ((long)(R[n] ^ R[m]) &lt; 0)
    fnLmL = -1;
  else
    fnLmL = 0;

  temp1 = (unsigned long)tempn;
  temp2 = (unsigned long)tempm;

  RnL = temp1 & 0x0000FFFF;
  RnH = (temp1 &gt;&gt; 16) & 0x0000FFFF;

  RmL = temp2 & 0x0000FFFF;
  RmH = (temp2 &gt;&gt; 16) & 0x0000FFFF;

  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0;
  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) & 0xFFFF0000;
  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) & 0x0000FFFF) + temp3;

  if (fnLmL &lt; 0)
  {
    Res2 = ~Res2;
    if (Res0 == 0)
      Res2++;
    else
      Res0 = (~Res0) + 1;
  }

  MACH = Res2;
  MACL = Res0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">dmuls.l r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555
      After execution: MACH = 0xFFFFFFFF, MACL = 0xFFFF5556
sts    mach,r0 ! Operation result (top)
sts    macl,r0 ! Operation result (bottom)
</span>
</span>
</label>
<input type="checkbox" id="row102" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row102">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dmulu.l	Rm,Rn</span>
<span>Unsigned, Rn × Rm → MACH:MACL
32 × 32 → 64 bits</span>
<span id="0011nnnnmmmm0101" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var></var><var>2-5</var><var></var><var></var><var>4/4</var><var>2</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 32-bit multiplication of the contents of general register Rn by the
contents of Rm, and stores the 64-bit result in the MACH and MACL registers.
The multiplication is performed as an unsigned arithmetic operation.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DMULU (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;

  RnL = R[n] & 0x0000FFFF;
  RnH = (R[n] &gt;&gt; 16) & 0x0000FFFF;

  RmL = R[m] & 0x0000FFFF;
  RmH = (R[m] &gt;&gt; 16) & 0x0000FFFF;

  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0
  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) & 0xFFFF0000;
  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) & 0x0000FFFF) + temp3;

  MACH = Res2;
  MACL = Res0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">dmulu.l r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555
      After execution: MACH = 0xFFFFFFFF, MACL = 0xFFFF5556
sts    mach,r0 ! Operation result (top)
sts    macl,r0 ! Operation result (bottom
</span>
</span>
</label>
<input type="checkbox" id="row103" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row103">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dt	Rn</span>
<span>Rn-1 → Rn
If Rn = 0: 1 → T
Else: 0 → T</span>
<span id="0100nnnn00010000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00010000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Decrements the contents of general register Rn by 1 and compares the result
with zero. If the result is zero, the T bit is set to 1.
If the result is nonzero, the T bit is cleared to 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void DT (int n)
{
  R[n]--;

  if (R[n] == 0)
    T = 1;
  else T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
    mov   #4,r4      ! Set loop count
loop:
    add   r0,r1
    dt    r5         ! Decrement r5 value and check for 0.
    bf    loop       ! if T = 0 branch to loop
                     ! (in this example, 4 loop iterations are executed)
</span>
</span>
</label>
<input type="checkbox" id="row104" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row104">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>exts.b	Rm,Rn</span>
<span>Rm sign-extended from byte → Rn</span>
<span id="0110nnnnmmmm1110" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sign-extends the contents of general register Rm and stores the result in Rn.
The value of Rm bit 7 is transferred to Rn bits 8 to 31.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void EXTSB (int m, int n)
{
  R[n] = R[m];

  if ((R[m] & 0x00000080) == 0)
    R[n] & = 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">exts.b r0,r1   ! Before execution: r0 = 0x00000080
      After execution: r1 = 0xFFFFFF80
</span>
</span>
</label>
<input type="checkbox" id="row105" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row105">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>exts.w	Rm,Rn</span>
<span>Rm sign-extended from word → Rn</span>
<span id="0110nnnnmmmm1111" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sign-extends the contents of general register Rm and stores the result in Rn.
The value of Rm bit 15 is transferred to Rn bits 16 to 31.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void EXTSW (int m, int n)
{
  R[n] = R[m];

  if ((R[m] & 0x00008000) == 0)
    R[n] & = 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">exts.w r0,r1   ! Before execution: r0 = 0x00008000
      After execution: r1 = 0xFFFF8000
</span>
</span>
</label>
<input type="checkbox" id="row106" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row106">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>extu.b	Rm,Rn</span>
<span>Rm zero-extended from byte → Rn</span>
<span id="0110nnnnmmmm1100" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Zero-extends the contents of general register Rm and stores the result in Rn.
0 is transferred to Rn bits 8 to 31.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void EXTUB (int m, int n)
{
  R[n] = R[m];
  R[n] &= 0x000000FF;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">extu.b r0,r1   ! Before execution: r0 = 0xFFFFFF80
      After execution: r1 = 0x00000080
</span>
</span>
</label>
<input type="checkbox" id="row107" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row107">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>extu.w	Rm,Rn</span>
<span>Rm zero-extended from word → Rn</span>
<span id="0110nnnnmmmm1101" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Zero-extends the contents of general register Rm and stores the result in Rn.
0 is transferred to Rn bits 16 to 31.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void EXTUW (int m, int n)
{
  R[n] = R[m];
  R[n] &= 0x0000FFFF;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">extu.w r0,r1   ! Before execution: r0 = 0xFFFF8000
      After execution: r1 = 0x00008000
</span>
</span>
</label>
<input type="checkbox" id="row108" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row108">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mac.l	@Rm+,@Rn+</span>
<span>Signed, (Rn) × (Rm) + MAC → MAC
32 × 32 + 64 → 64 bits</span>
<span id="0000nnnnmmmm1111" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>2</var><var>4</var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var></var><var>2-5</var><var></var><var></var><var>2/4</var><var>5</var><var>5</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs signed multiplication of the 32-bit operands whose addresses are the
contents of general registers Rm and Rn, adds the 64-bit result to the MAC
register contents, and stores the result in the MAC register.
Operands Rm and Rn are each incremented by 4 each time they are read.
<br /><br />
When the S bit is cleared to 0, the 64-bit result is stored in the coupled MACH
and MACL registers.
<br /><br />
When bit S is set to 1, addition to the MAC register is a saturation operation
of 48 bits starting from the LSB. For the saturation operation, only the lower
48 bits of the MACL register are enabled and the result is limited to a range
of 0xFFFF800000000000 (minimum) and 0x00007FFFFFFFFFFF (maximum).
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.  In the case of consecutive executions of
MAC.W/MAC.L, the latency is decreased to 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MACL (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;
  long tempm, tempn, fnLmL;

  tempn = Read_32 (R[n]);
  R[n] += 4;
  tempm = Read_32 (R[m]);
  R[m] += 4;

  if ((long)(tempn ^ tempm) &lt; 0)
    fnLmL = -1;
  else
    fnLmL = 0;

  if (tempn &lt; 0)
    tempn = 0 - tempn;
  if (tempm &lt; 0)
    tempm = 0 - tempm;

  temp1 = (unsigned long)tempn;
  temp2 = (unsigned long)tempm;

  RnL = temp1 & 0x0000FFFF;
  RnH = (temp1 &gt;&gt; 16) & 0x0000FFFF;
  RmL = temp2 & 0x0000FFFF;
  RmH = (temp2 &gt;&gt; 16) & 0x0000FFFF;
  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0;

  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) & 0xFFFF0000;

  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) & 0x0000FFFF) + temp3;

  if(fnLmL &lt; 0)
  {
    Res2 = ~Res2;
    if (Res0 == 0)
      Res2++;
    else
      Res0 = (~Res0) + 1;
  }

  if (S == 1)
  {
    Res0 = MACL + Res0;
    if (MACL &gt; Res0)
      Res2++;

    Res2 += MACH & 0x0000FFFF;

    if (((long)Res2 &lt; 0) && (Res2 &lt; 0xFFFF8000))
    {
      Res2 = 0xFFFF8000;
      Res0 = 0x00000000;
    }

    if (((long)Res2 &gt; 0) && (Res2 &gt; 0x00007FFF))
    {
      Res2 = 0x00007FFF;
      Res0 = 0xFFFFFFFF;
    }

    MACH = (Res2 & 0x0000FFFF) | (MACH & 0xFFFF0000);
    MACL = Res0;
  }
  else
  {
    Res0 = MACL + Res0;
    if (MACL &gt; Res0)
      Res2 ++;

    Res2 += MACH;
    MACH = Res2;
    MACL = Res0;
  }

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mova   tblm,r0 ! Table address
mov    r0,r1   ! 
mova   tbln,r0 ! Table address
clrmac         ! MAC register initialization
mac.l  @r0+,@r1+ ! 
mac.l  @r0+,@r1+ ! 
sts    macl,r0 ! Store result into r0
...............
.align 2       ! 
tblm  
.data.l 0x1234abcd ! 
.data.l 0x5678ef01 ! 
tbln  
.data.l 0x0123abcd ! 
.data.l 0x4567def0 ! 
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row109" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row109">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mac.w	@Rm+,@Rn+</span>
<span>Signed, (Rn) × (Rm) + MAC → MAC
SH1: 16 × 16 + 42 → 42 bits
Other: 16 × 16 + 64 → 64 bits</span>
<span id="0100nnnnmmmm1111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>2</var><var>3</var></span>
<span class="cycle_grid"><var>2-3</var><var>2-3</var><var></var><var>2-5</var><var></var><var></var><var>2/4</var><var>4</var><var>4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs signed multiplication of the 16-bit operands whose addresses are the
contents of general registers Rm and Rn, adds the 32-bit result to the MAC
register contents, and stores the result in the MAC register.
Operands Rm and Rn are each incremented by 2 each time they are read.
<br /><br />
If the S bit is 0, a 16 × 16 + 64 → 64-bit multiply-and-accumulate operation
is performed, and the 64-bit result is stored in the linked MACH and MACL
registers.
<br /><br />
If the S bit is 1, a 16 × 16 + 32 → 32-bit multiply-and-accumulate operation is
performed, and the addition to the MAC register contents is a saturation
operation. In a saturation operation, only the MACL register is valid, and the
result range is limited to 0x80000000 (minimum value) to 0x7FFFFFFF
(maximum value). If overflow occurs, the LSB of the MACH register is set to 1.
0x80000000 (minimum value) is stored in the MACL register if the result
overflows in the negative direction, and 0x7FFFFFFF (maximum value) is stored
if the result overflows in the positive direction
<br /><br />
<span title="section">Note</span>
<br />
<br />When the S bit is 0, the SH2 and SH-DSP CPU perform a 16 × 16 + 64 → 64 bit
multiply and accumulate operation and the SH1 CPU performs a 16 × 16 + 42 →
42 bit multiply and accumulate operation.
<br /><br />
On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.  In the case of consecutive executions of
MAC.W/MAC.L, the latency is decreased to 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MACW (int m, int n)
{
  long tempm, tempn, dest, src, ans;
  unsigned long templ;

  tempn = Read_16 (R[n]);
  R[n] += 2;
  tempm = Read_16 (R[m]);
  R[m] += 2;

  templ = MACL;
  tempm = ((long)(short)tempn * (long)(short)tempm);

  if ((long)MACL &gt;= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)tempm &gt;= 0)
  {
    src = 0;
    tempn = 0;
  }
  else
  {
    src = 1;
    tempn = 0xFFFFFFFF;
  }

  src += dest;
  MACL += tempm;

  if ((long)MACL &gt;= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (S == 1)
  {
    if (ans == 1)
    {
      #if SH1
      if (src == 0 || src == 2)
        MACH |= 0x00000001;
      #endif

      if (src == 0)
        MACL = 0x7FFFFFFF;
      if (src == 2)
        MACL = 0x80000000;
    }
  }
  else
  {
    MACH += tempn;
    if (templ &gt; MACL)
      MACH += 1;

    #if SH1
    if ((MACH & 0x00000200) == 0)
      MACH &= 0x000003FF;
    else
      MACH |= 0xFFFFFC00;
    #endif
  }

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mova   tblm,r0 ! Table address
mov    r0,r1   ! 
mova   tbln,r0 ! Table address
clrmac         ! MAC register initialization
mac.w  @r0+,@r1+ ! 
mac.w  @r0+,@r1+ ! 
sts    macl,r0 ! Store result into r0
...............
.align 2       ! 
tblm  
.data.w 0x1234  ! 
.data.w 0x5678  ! 
tbln  
.data.w 0x0123  ! 
.data.w 0x4567  ! 
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row110" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row110">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mul.l	Rm,Rn</span>
<span>Rn × Rm → MACL
32 × 32 → 32 bits</span>
<span id="0000nnnnmmmm0111" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var></var><var>2-4</var><var></var><var></var><var>4/4</var><var>2</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 32-bit multiplication of the contents of general registers Rn and Rm,
and stores the lower 32 bits of the result in the MACL register. The contents
of MACH are not changed.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MULL (int m, int n)
{
  MACL = R[n] * R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mull   r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555
      After execution: MACL = 0xFFFF5556
sts    macl,r0 ! Operation result
</span>
</span>
</label>
<input type="checkbox" id="row111" />
<label class="summary SH2A" for="row111">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mulr	R0,Rn</span>
<span>R0 × Rn → Rn
32 × 32 → 32 bits</span>
<span id="0100nnnn10000000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 32-bit multiplication of the contents of general register R0 by Rn,
and stores the lower 32 bits of the result in general register Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MULR (int n)
{
  R[n] = R[0] * R[n];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row112" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row112">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>muls.w	Rm,Rn</span>
<span>Signed, Rn × Rm → MACL
16 × 16 → 32 bits</span>
<span id="0010nnnnmmmm1111" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1-3</var><var>1-3</var><var></var><var>1-3</var><var></var><var></var><var>4/4</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 16-bit multiplication of the contents of general registers Rn and Rm,
and stores the 32-bit result in the MACL register. The multiplication is
performed as a signed arithmetic operation. The contents of MACH are not
changed.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MULS (int m, int n)
{
  MACL = ((long)(short)R[n] * (long)(short)R[m]);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">muls   r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555
      After execution: MACL = 0xFFFF5556
sts    macl,r0 ! Operation result
</span>
</span>
</label>
<input type="checkbox" id="row113" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row113">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mulu.w	Rm,Rn</span>
<span>Unsigned, Rn × Rm → MACL
16 × 16 → 32 bits</span>
<span id="0010nnnnmmmm1110" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1-3</var><var>1-3</var><var></var><var>1-3</var><var></var><var></var><var>4/4</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs 16-bit multiplication of the contents of general registers Rn and Rm,
and stores the 32-bit result in the MACL register. The multiplication is
performed as an unsigned arithmetic operation. The contents of MACH are not
changed.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the
latency of MAC*/MUL* is 5 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MULU (int m, int n)
{
  MACL = ((unsigned long)(unsigned short)R[n]* (unsigned long)(unsigned short)R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mulu   r0,r1   ! Before execution: r0 = 0x00000002, r1 = 0xFFFFAAAA
      After execution: MACL = 0x00015554
sts    macl,r0 ! Operation result
</span>
</span>
</label>
<input type="checkbox" id="row114" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row114">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>neg	Rm,Rn</span>
<span>0 - Rm → Rn</span>
<span id="0110nnnnmmmm1011" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds the two's complement of the contents of general register Rm and stores
the result in Rn. That is, it subtracts Rm from 0 and stores the result in Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void NEG (int m, int n)
{
  R[n] = 0 - R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">neg    r0,r1   ! Before execution: r0 = 0x00000001
      After execution: r1 = 0xFFFFFFFF
</span>
</span>
</label>
<input type="checkbox" id="row115" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row115">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>negc	Rm,Rn</span>
<span>0 - Rm - T → Rn, borrow → T</span>
<span id="0110nnnnmmmm1010" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1010</span></span>
<span>Borrow → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of general register Rm and the T bit from 0 and stores
the result in Rn. A borrow resulting from the operation is reflected in the
T bit. This instruction can be  used for sign inversion of a value exceeding
32 bits.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be used to efficiently store the reversed T bit value
in a general register, if the MOVRT instruction is not available.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void NEGC (int m, int n)
{
  unsigned long temp;
  temp = 0 - R[m];
  R[n] = temp - T;

  if (0 &lt; temp)
    T = 1;
  else
    T = 0;

  if (temp &lt; R[n])
    T = 1;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">

! Sign inversion of r0:r1 (64 bits)

clrt
negc   r1,r1    ! Before execution: r1 = 0x00000001, T = 0
                ! After execution: r1 = 0xFFFFFFFF, T = 1
negc   r0,r0    ! Before execution: r0 = 0x00000000, T = 1
                ! After execution: r0 = 0xFFFFFFFF, T = 1

- - - - - - - - - - - - - - - -

! Store reversed T bit in r0

mov    #-1,r1
negc   r1,r0    ! r0 = 0 - (-1) - T
                ! r0 = 1 - T
                ! Notice that T bit will be modified by the negc operation.
                ! In this case, T will be always set to 1.
</span>
</span>
</label>
<input type="checkbox" id="row116" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row116">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sub	Rm,Rn</span>
<span>Rn - Rm → Rn</span>
<span id="0011nnnnmmmm1000" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of general register Rm from the contents of general
register Rn and stores the result in Rn. For immediate data subtraction,
ADD #imm,Rn should be used.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SUB (int m, int n)
{
  R[n] -= R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sub    r0,r1   ! Before execution: r0 = 0x00000001, r1 = 0x80000000
      After execution: r1 = 0x7FFFFFFF
</span>
</span>
</label>
<input type="checkbox" id="row117" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row117">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>subc	Rm,Rn</span>
<span>Rn - Rm - T → Rn, borrow → T</span>
<span id="0011nnnnmmmm1010" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1010</span></span>
<span>Borrow → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of general register Rm and the T bit from the contents of
general register Rn, and stores the result in Rn. A borrow resulting from the
operation is reflected in the T bit. This instruction is used for subtractions
exceeding 32 bits.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be used to store the T bit to all the bits of a
general register.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SUBC (int m, int n)
{
  unsigned long tmp0, tmp1;
  tmp1 = R[n] - R[m];
  tmp0 = R[n];
  R[n] = tmp1 - T;

  if (tmp0 &lt; tmp1)
    T = 1;
  else
    T = 0;

  if (tmp1 &lt; R[n])
    T = 1;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">

! r0:r1(64 bits) - r2:r3(64 bits) = r0:r1(64 bits)

clrt
subc   r3,r1    ! Before execution: T = 0, r1 = 0x00000000, r3 = 0x00000001
                ! After execution: T = 1, r1 = 0xFFFFFFFF
subc   r2,r0    ! Before execution: T = 1, r0 = 0x00000000, r2 = 0x00000000
                ! After execution: T = 1, r0 = 0xFFFFFFFF

- - - - - - - - - - - - - - - -

! Store T bit to all bits of r0

subc   r0,r0    ! r0 = r0 - r0 - T
                ! r0 = 0 - T
                ! Notice that the T bit is modified by the subc operation.
</span>
</span>
</label>
<input type="checkbox" id="row118" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row118">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>subv	Rm,Rn</span>
<span>Rn - Rm → Rn, underflow → T</span>
<span id="0011nnnnmmmm1011" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1011</span></span>
<span>Underflow → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of general register Rm from the contents of general
register Rn, and stores the result in Rn. If underflow occurs, the T bit is set.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SUBV (int m, int n)
{
  long dest, src, ans;

  if ((long)R[n] &gt;= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)R[m] &gt;= 0)
    src = 0;
  else
    src = 1;

  src += dest;
  R[n] -= R[m];

  if ((long)R[n] &gt;= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (src == 1)
  {
    if (ans == 1)
      T = 1;
    else
      T = 0;
  }
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
subv   r0,r1    ! Before execution: r0 = 0x00000002, r1 = 0x80000001
                ! After execution: r1 = 0x7FFFFFFF, T = 1

subv   r2,r3    ! Before execution: r2 = 0xFFFFFFFE, r3 = 0x7FFFFFFE
                ! After execution r3 = 0x80000000, T = 1
</span>
</span>
</label>
<br/><br/><br/><b>Logic Operation Instructions</b><br/><br/>
<input type="checkbox" id="row119" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row119">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>and	Rm,Rn</span>
<span>Rn & Rm → Rn</span>
<span id="0010nnnnmmmm1001" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the contents of general registers Rn and Rm and stores the result in Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void AND (int m, int n)
{
  R[n] &= R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">and    r0,r1   ! Before execution: r0 = 0xAAAAAAAA, r1 = 0x55555555
      After execution: r1 = 0x00000000
</span>
</span>
</label>
<input type="checkbox" id="row120" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row120">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>and	#imm,R0</span>
<span>R0 & (zero extend)imm → R0</span>
<span id="11001001iiiiiiii" class="colorized"><span title="Opcode Identifier">11001001</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.
<br /><br />
<span title="section">Note</span>
<br />
<br />Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
always cleared to zero.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ANDI (int i)
{
  R[0] &= (0x000000FF & (long)i);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">and    #0x0f,r0 ! Before execution: r0 = 0xFFFFFFFF
      After execution: r0 = 0x0000000F
</span>
</span>
</label>
<input type="checkbox" id="row121" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row121">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>and.b	#imm,@(R0,GBR)</span>
<span>(R0 + GBR) & (zero extend)imm → (R0 + GBR)</span>
<span id="11001101iiiiiiii" class="colorized"><span title="Opcode Identifier">11001101</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>4</var><var>3</var><var>3</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>3</var><var></var><var></var><var>4</var><var>3</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the contents of the memory byte indicated by the indirect GBR address with
the immediate value and writes the result back to the memory byte.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ANDM (long i)
{
  long temp = Read_8 (GBR + R[0]);
  temp &= 0x000000FF & (long)i;
  Write_8 (GBR + R[0], temp);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">and.b  #0x80,@(r0,gbr) ! Before execution: @(r0,GBR) = 0xA5
      After execution: @(r0,GBR) = 0x80
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input type="checkbox" id="row122" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row122">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>not	Rm,Rn</span>
<span>~Rm → Rn</span>
<span id="0110nnnnmmmm0111" class="colorized"><span title="Opcode Identifier">0110</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds the one's complement of the contents of general register Rm and stores
the result in Rn. That is, it inverts the Rm bits and stores the result in Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void NOT (int m, int n)
{
  R[n] = ~R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">not    r0,r1   ! Before execution: r0 = 0xAAAAAAAA
      After execution: r1 = 0x55555555
</span>
</span>
</label>
<input type="checkbox" id="row123" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row123">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>or	Rm,Rn</span>
<span>Rn | Rm → Rn</span>
<span id="0010nnnnmmmm1011" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ORs the contents of general registers Rn and Rm and stores the result in Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void OR (int m, int n)
{
  R[n] |= R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">or     r0,r1   ! Before execution: r0 = 0xAAAA5555, r1 = 0x55550000
      After execution: r1 = 0xFFFF5555
</span>
</span>
</label>
<input type="checkbox" id="row124" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row124">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>or	#imm,R0</span>
<span>R0 | (zero extend)imm → R0</span>
<span id="11001011iiiiiiii" class="colorized"><span title="Opcode Identifier">11001011</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ORs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.
<br /><br />
<span title="section">Note</span>
<br />
<br />Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
not modified.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ORI (int i)
{
  R[0] |= (0x000000FF & (long)i);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">or     #0xf0,r0 ! Before execution: r0 = 0x00000008
      After execution: r0 = 0x000000F8
</span>
</span>
</label>
<input type="checkbox" id="row125" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row125">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>or.b	#imm,@(R0,GBR)</span>
<span>(R0 + GBR) | (zero extend)imm → (R0 + GBR)</span>
<span id="11001111iiiiiiii" class="colorized"><span title="Opcode Identifier">11001111</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>4</var><var>3</var><var>3</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>3</var><var></var><var></var><var>4</var><var>3</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ORs the contents of the memory byte indicated by the indirect GBR address with
the immediate value and writes the result back to the memory byte.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ORM (int i)
{
  long temp = Read_8 (GBR + R[0]);
  temp |= (0x000000FF & (long)i);
  Write_8 (GBR + R[0], temp);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">or.b   #0x50,@(r0,gbr) ! Before execution: @(r0,GBR) = 0xA5
      After execution: @(r0,GBR) = 0xF5
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input type="checkbox" id="row126" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row126">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tas.b	@Rn</span>
<span>If (Rn) = 0: 1 → T
Else: 0 → T
1 → MSB of (Rn)</span>
<span id="0100nnnn00011011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00011011</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>5</var><var>4</var><var>3</var></span>
<span class="cycle_grid"><var>4</var><var>4</var><var></var><var>3/4</var><var></var><var></var><var>5</var><var>4</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Reads byte data from the address specified by general register Rn, and sets the
T bit to 1 if the data is 0, or clears the T bit to 0 if the data is not 0.
Then, data bit 7 is set to 1, and the data is written to the address specified
by Rn. During this operation, the bus is not released.
<br /><br />

On SH4 and SH4A this instruction purges the cache block corresponding to the
memory area specified by the contents of general register Rn.
The purge operation is executed as follows.<br />
In a purge operation, data is accessed using the contents of general register Rn
as the effective address. If there is a cache hit and the corresponding cache
block is dirty (U bit = 1), the contents of that cache block are written back to
external memory, and the cache block is then invalidated (by clearing the V bit
to 0). If there is a cache hit and the corresponding cache block is clean (U bit
= 0), the cache block is simply invalidated (by clearing the V bit to 0). A
purge is not executed in the event of a cache miss, or if the accessed memory
location is non-cacheable.
<br /><br />
<span title="section">Note</span>
<br />
<br />The two TAS.B memory accesses are executed automatically. Another memory access
is not executed between the two TAS.B accesses.
<br /><br />
On SH3 the destination of the TAS instruction should be placed in a
non-cacheable space when the cache is enabled.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void TAS (int n)
{
  int temp = Read_8 (R[n]); // Bus Lock

  if (temp == 0)
    T = 1;
  else
    T = 0;

  temp |= 0x00000080;
  Write_8 (R[n], temp);  // Bus unlock
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">      _loop: tas.b @r7 ! r7 = 1000
bf     _loop   ! Loops until data in address 1000 is 0
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input type="checkbox" id="row127" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row127">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tst	Rm,Rn</span>
<span>If Rn & Rm = 0: 1 → T
Else: 0 → T</span>
<span id="0010nnnnmmmm1000" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1000</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the contents of general registers Rn and Rm, and sets the T bit if the
result is zero. If the result is nonzero, the T bit is cleared. The contents of
Rn are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void TST (int m, int n)
{
  if ((R[n] & R[m]) == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">tst    r0,r0   ! Before execution: r0 = 0x00000000
      After execution: T = 1
</span>
</span>
</label>
<input type="checkbox" id="row128" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row128">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tst	#imm,R0</span>
<span>If R0 & (zero extend)imm = 0: 1 → T
Else: 0 → T</span>
<span id="11001000iiiiiiii" class="colorized"><span title="Opcode Identifier">11001000</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the contents of general register R0 and the zero-extended immediate value
and sets the T bit if the result is zero. If the result is nonzero, the T bit
is cleared. The contents of Rn are not changed.
<br /><br />
<span title="section">Note</span>
<br />
<br />Since the 8-bit immediate value is zero-extended, this instruction can only be
used to test the lower 8 bits of R0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void TSTI (int i)
{
  long temp = R[0] & (0x000000FF & (long)i);

  if (temp == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">tst    #0x80,r0 ! Before execution: r0 = 0xFFFFFF7F
      After execution: T = 1
</span>
</span>
</label>
<input type="checkbox" id="row129" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row129">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tst.b	#imm,@(R0,GBR)</span>
<span>If (R0 + GBR) & (zero extend)imm = 0: 1 → T
Else 0: → T</span>
<span id="11001100iiiiiiii" class="colorized"><span title="Opcode Identifier">11001100</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>3</var><var>3</var><var>3</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>3</var><var></var><var></var><var>3</var><var>3</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />ANDs the contents of the memory byte indicated by the indirect GBR address with
the zero-extended immediate value and sets the T bit if the result is zero.
If the result is nonzero, the T bit is cleared.
The contents of the memory byte are not changed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void TSTM (int i)
{
  long temp = Read_8 (GBR + R[0]);
  temp &= (0x000000FF & (long)i);

  if (temp == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">tst.b  #0xa5,@(r0,gbr) ! Before execution: @(r0,GBR) = 0xA5
      After execution: T = 0
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input type="checkbox" id="row130" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row130">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xor	Rm,Rn</span>
<span>Rn ^ Rm → Rn</span>
<span id="0010nnnnmmmm1010" class="colorized"><span title="Opcode Identifier">0010</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />XORs the contents of general registers Rn and Rm and stores the result in Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void XOR (long m, long n)
{
  R[n] ^= R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">xor    r0,r1   ! Before execution: r0 = 0xAAAAAAAA, r1 = 0x55555555
      After execution: r1 = 0xFFFFFFFF
</span>
</span>
</label>
<input type="checkbox" id="row131" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row131">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xor	#imm,R0</span>
<span>R0 ^ (zero extend)imm → R0</span>
<span id="11001010iiiiiiii" class="colorized"><span title="Opcode Identifier">11001010</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />XORs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.
<br /><br />
<span title="section">Note</span>
<br />
<br />Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
not modified.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void XORI (int i)
{
  R[0] ^= (0x000000FF & (long)i);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">xor    #0xf0,r0 ! Before execution: r0 = 0xFFFFFFFF
      After execution: r0 = 0xFFFFFF0F
</span>
</span>
</label>
<input type="checkbox" id="row132" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row132">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xor.b	#imm,@(R0,GBR)</span>
<span>(R0 + GBR) ^ (zero extend)imm → (R0 + GBR)</span>
<span id="11001110iiiiiiii" class="colorized"><span title="Opcode Identifier">11001110</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>4</var><var>3</var><var>3</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>3</var><var></var><var></var><var>4</var><var>3</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />XORs the contents of the memory byte indicated by the indirect GBR address with
the immediate value and writes the result back to the memory byte.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void XORM (int i)
{
  int temp = Read_8 (GBR + R[0]);
  temp ^= (0x000000FF & (long)i);
  Write_8 (GBR + R[0], temp);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">xor.b  #0xa5,@(r0,gbr) ! Before execution: @(r0,GBR) = 0xA5
      After execution: @(r0,GBR) = 0x00
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<br/><br/><br/><b>Shift Instructions</b><br/><br/>
<input type="checkbox" id="row133" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row133">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotcl	Rn</span>
<span>T &lt;&lt; Rn &lt;&lt; T</span>
<span id="0100nnnn00100100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100100</span></span>
<span>MSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Rotates the contents of general register Rn one bit to the left through the
T bit, and stores the result in Rn. The bit rotated out of the operand is
transferred to the T bit.
<br /><img alt="Rotate with Carry Left operation" src="rotcl.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ROTCL (int n)
{
  long temp;

  if ((R[n] & 0x80000000) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &lt;&lt;= 1;

  if (T == 1)
    R[n] |= 0x00000001;
  else
    R[n] &= 0xFFFFFFFE;

  if (temp == 1)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">rotcl  r0      ! Before execution: r0 = 0x80000000, T = 0
      After execution: r0 = 0x00000000, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row134" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row134">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotcr	Rn</span>
<span>T &gt;&gt; Rn &gt;&gt; T</span>
<span id="0100nnnn00100101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100101</span></span>
<span>LSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Rotates the contents of general register Rn one bit to the right through the
T bit, and stores the result in Rn. The bit rotated out of the operand is
transferred to the T bit.
<br /><img alt="Rotate with Carry Right" src="rotcr.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ROTCR (int n)
{
  long temp;

  if ((R[n] & 0x00000001) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &gt;&gt;= 1;

  if (T == 1)
    R[n] |= 0x80000000;
  else
    R[n] &= 0x7FFFFFFF;

  if (temp == 1)
    T = 1;
  else
    T = 0;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">rotcr  r0      ! Before execution: r0 = 0x00000001, T = 1
      After execution: r0 = 0x80000000, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row135" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row135">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotl	Rn</span>
<span>T &lt;&lt; Rn &lt;&lt; MSB</span>
<span id="0100nnnn00000100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000100</span></span>
<span>MSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Rotates the contents of general register Rn one bit to the left, and stores the
result in Rn. The bit rotated out of the operand is transferred to the T bit.
<br /><img alt="Rotate Left operation" src="rotl.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ROTL (int n)
{
  if ((R[n] & 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;

  if (T == 1)
    R[n] |= 0x00000001;
  else
    R[n] &= 0xFFFFFFFE;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">rotl   r0      ! Before execution: r0 = 0x80000000, T = 0
      After execution: r0 = 0x00000001, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row136" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row136">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotr	Rn</span>
<span>LSB &gt;&gt; Rn &gt;&gt; T</span>
<span id="0100nnnn00000101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000101</span></span>
<span>LSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Rotates the contents of general register Rn one bit to the right, and stores the
result in Rn. The bit rotated out of the operand is transferred to the T bit.
<br /><img alt="Rotate Right operation" src="rotr.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ROTR (int n)
{
  if ((R[n] & 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  R[n] &gt;&gt;= 1;

  if (T == 1)
    R[n] |= 0x80000000;
  else
    R[n] &= 0x7FFFFFFF;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">rotr   r0      ! Before execution: r0 = 0x00000001, T = 0
      After execution: r0 = 0x80000000, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row137" />
<label class="summary SH3 SH4 SH4A SH2A" for="row137">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shad	Rm,Rn</span>
<span>If Rm &gt;= 0: Rn &lt;&lt; Rm → Rn
If Rm &lt; 0: Rn &gt;&gt; |Rm| → [MSB → Rn]</span>
<span id="0100nnnnmmmm1100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically shifts the contents of general register Rn. General register Rm
specifies the shift direction and the number of bits to be shifted.
<br /><br />
Rn register contents are shifted to the left if the Rm register value is
positive, and to the right if negative. In a shift to the right, the MSB is
added at the upper end.
<br /><br />
The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)
of the Rm register. If the value is negative (MSB = 1), the Rm register is
represented as a two's complement. The left shift range is 0 to 31, and the
right shift range, 1 to 32.
<br /><img alt="" class="image_filter" src="shad.svg" height="220" />
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, if there is a load of the shift amount immediately before an SHAD/SHLD
instruction, the latency of the load is increased by 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHAD (int m, int n)
{
  int sgn = R[m] & 0x80000000;

  if (sgn == 0)
    R[n] &lt;&lt;= (R[m] & 0x1F);
  else if ((R[m] & 0x1F) == 0)
  {
    if ((R[n] & 0x80000000) == 0)
      R[n] = 0;
    else
      R[n] = 0xFFFFFFFF;
  }
  else
    R[n] = (long)R[n] &gt;&gt; ((~R[m] & 0x1F) + 1);

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row138" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row138">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shal	Rn</span>
<span>T &lt;&lt; Rn &lt;&lt; 0</span>
<span id="0100nnnn00100000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100000</span></span>
<span>MSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically shifts the contents of general register Rn one bit to the left
and stores the result in Rn. The bit shifted out of the operand is transferred
to the T bit.
<br /><img alt="Shift Arithmetic Left operation" src="shal.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHAL (int n)
{
  if ((R[n] & 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shal   r0      ! Before execution: r0 = 0x80000001, T = 0
      After execution: r0 = 0x00000002, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row139" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row139">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shar	Rn</span>
<span>MSB &gt;&gt; Rn &gt;&gt; T</span>
<span id="0100nnnn00100001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100001</span></span>
<span>LSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically shifts the contents of general register Rn one bit to the right
and stores the result in Rn. The bit shifted out of the operand is transferred
to the T bit.
<br /><img alt="Shift Arithmetic Right operation" src="shar.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHAR (int n)
{
  long temp;

  if ((R[n] & 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  if ((R[n] & 0x80000000) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &gt;&gt;= 1;

  if (temp == 1)
    R[n] |= 0x80000000;
  else
    R[n] &= 0x7FFFFFFF;

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shar   r0      ! Before execution: r0 = 0x80000001, T = 0
      After execution: r0 = 0xC0000000, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row140" />
<label class="summary SH3 SH4 SH4A SH2A" for="row140">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shld	Rm,Rn</span>
<span>If Rm &gt;= 0: Rn &lt;&lt; Rm → Rn
If Rm &lt; 0: Rn &gt;&gt; |Rm| → [0 → Rn]</span>
<span id="0100nnnnmmmm1101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn. General register Rm
specifies the shift direction and the number of bits to be shifted.
<br /><br />
Rn register contents are shifted to the left if the Rm register value is
positive, and to the right if negative. In a shift to the right, 0s are added
at the upper end.
<br /><br />
The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)
of the Rm register. If the value is negative (MSB = 1), the Rm register is
represented as a two's complement. The left shift range is 0 to 31, and the
right shift range, 1 to 32.
<br /><img alt="" class="image_filter" src="shld.svg" height="220" />
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, if there is a load of the shift amount immediately before an SHAD/SHLD
instruction, the latency of the load is increased by 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLD (int m, int n)
{
  int sgn = R[m] & 0x80000000;

  if (sgn == 0)
    R[n] &lt;&lt;= (R[m] & 0x1F);
  else if ((R[m] & 0x1F) == 0)
    R[n] = 0;
  else
    R[n] = (unsigned)R[n] &gt;&gt; ((~R[m] & 0x1F) + 1);

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row141" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row141">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll	Rn</span>
<span>T &lt;&lt; Rn &lt;&lt; 0</span>
<span id="0100nnnn00000000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000000</span></span>
<span>MSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn one bit to the left and
stores the result in Rn. The bit shifted out of the operand is transferred to
the T bit.
<br /><img alt="Shift Logical Left operation" src="shll.svg" height="100" />
<br /><br />
<span title="section">Note</span>
<br />
<br />Effectively, the operation performed is the same as the SHAL instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLL (int n)
{
  if ((R[n] & 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shll   r0      ! Before execution: r0 = 0x80000001, T = 0
      After execution: r0 = 0x00000002, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row142" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row142">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll2	Rn</span>
<span>Rn &lt;&lt; 2 → Rn</span>
<span id="0100nnnn00001000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00001000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn 2 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Left 2 Bits operation" src="shll2.svg" height="120" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLL2 (int n)
{
  R[n] &lt;&lt;= 2;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shll  2 r0     ! Before execution: r0 = 0x12345678
      After execution: r0 = 0x48D159E0
</span>
</span>
</label>
<input type="checkbox" id="row143" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row143">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll8	Rn</span>
<span>Rn &lt;&lt; 8 → Rn</span>
<span id="0100nnnn00011000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00011000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn 8 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Left 8 Bits operation" src="shll8.svg" height="120" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLL8 (int n)
{
  R[n] &lt;&lt;= 8;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shll  8 r0     ! Before execution: r0 = 0x12345678
      After execution: r0 = 0x34567800
</span>
</span>
</label>
<input type="checkbox" id="row144" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row144">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll16	Rn</span>
<span>Rn &lt;&lt; 16 → Rn</span>
<span id="0100nnnn00101000" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00101000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn 16 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Left 16 Bits operation" src="shll16.svg" height="120" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLL16 (int n)
{
  R[n] &lt;&lt;= 16;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shll  16 r0    ! Before execution: r0 = 0x12345678
      After execution: r0 = 0x56780000
</span>
</span>
</label>
<input type="checkbox" id="row145" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row145">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr	Rn</span>
<span>0 &gt;&gt; Rn &gt;&gt; T</span>
<span id="0100nnnn00000001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000001</span></span>
<span>LSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn one bit to the right and
stores the result in Rn. The bit shifted out of the operand is transferred to
the T bit.
<br /><img alt="Shift Logical Right operation" src="shlr.svg" height="100" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLR (int n)
{
  if ((R[n] & 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  R[n] &gt;&gt;= 1;
  R[n] &= 0x7FFFFFFF;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shlr   r0      ! Before execution: r0 = 0x80000001, T = 0
      After execution: r0 = 0x40000000, T = 1
</span>
</span>
</label>
<input type="checkbox" id="row146" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row146">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr2	Rn</span>
<span>Rn &gt;&gt; 2 → [0 → Rn]</span>
<span id="0100nnnn00001001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00001001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn 2 bits to the right, and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Right 2 Bits operation" src="shlr2.svg" height="120" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLR2 (int n)
{
  R[n] &gt;&gt;= 2;
  R[n] &= 0x3FFFFFFF;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shlr  2 r0     ! Before execution: r0 = 0x12345678
      After execution: r0 = 0x048D159E
</span>
</span>
</label>
<input type="checkbox" id="row147" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row147">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr8	Rn</span>
<span>Rn &gt;&gt; 8 → [0 → Rn]</span>
<span id="0100nnnn00011001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00011001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn 8 bits to the right, and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Right 8 Bits operation" src="shlr8.svg" height="120" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLR8 (int n)
{
  R[n] &gt;&gt;= 8;
  R[n] &= 0x00FFFFFF;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shlr  8 r0     ! Before execution: r0 = 0x12345678
      After execution: r0 = 0x00123456
</span>
</span>
</label>
<input type="checkbox" id="row148" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row148">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr16	Rn</span>
<span>Rn &gt;&gt; 16 → [0 → Rn]</span>
<span id="0100nnnn00101001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00101001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the contents of general register Rn 16 bits to the right and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Right 16 Bits operation" src="shlr16.svg" height="120" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SHLR16 (int n)
{
  R[n] &gt;&gt;= 16;
  R[n] &= 0x0000FFFF;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">shlr  16 r0    ! Before execution: r0 = 0x12345678
      After execution: r0 = 0x00001234
</span>
</span>
</label>
<br/><br/><br/><b>Branch Instructions</b><br/><br/>
<input type="checkbox" id="row149" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row149">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bf	label</span>
<span>If T = 0: disp × 2 + PC + 4 → PC
Else: nop</span>
<span id="10001011dddddddd" class="colorized"><span title="Opcode Identifier">10001011</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1-3</var><var>1/3</var></span>
<span class="cycle_grid"><var>1/3</var><var>1/3</var><var></var><var>1/3</var><var></var><var></var><var>1/2</var><var>1</var><var>1/3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This is a conditional branch instruction that references the T bit. The branch
is taken if T = 0, and not taken if T = 1. The branch destination is address
(PC + 4 + displacement × 2).  The PC source value is the BF instruction address.
As the 8-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -256 to +254 bytes from the BF
instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />If the branch destination cannot be reached, the branch must be handled by using
BF in combination with a BRA or JMP instruction, for example.
<br /><br />
On some SH4 implementations a branch with a displacement value of zero does not
cause the pipeline I-stage to be stalled even if the branch is taken.  This can
be utilized for efficient conditional operations.
<br /><br />
On some SH2E implementations (SH7055) there is an FPU related hardware bug
which affects this instruction.  The recommended workaround is to use bt/s with
a nop in the delay slot.
See also documents "sh2eoc.pdf" and "win_update_a.pdf".
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BF (int d)
{
  int disp;
  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 0)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">clrt           ! T is always cleared to 0
bt     trget_t ! Does not branch, because T = 0
bf     trget_f ! Branches to TRGET_F, because T = 0
nop            ! 
nop            ! ← The PC location is used to calculate the branch destination
..........         !   address of the BF instruction
trget _f:      ! ← Branch destination of the BF instruction
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row150" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row150">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bf/s	label</span>
<span>If T = 0: disp × 2 + PC + 4 → PC
Else: nop
(Delayed branch)</span>
<span id="10001111dddddddd" class="colorized"><span title="Opcode Identifier">10001111</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1-3</var><var>1/2</var></span>
<span class="cycle_grid"><var></var><var>1/2</var><var></var><var>1/2</var><var></var><var></var><var>1/2</var><var>1</var><var>1/2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This is a delayed conditional branch instruction that references the T bit.
If T = 1, the next instruction is executed and the branch is not taken.
If T = 0, the branch is taken after execution of the next instruction.
<br /><br />
The branch destination is address (PC + 4 + displacement × 2). The PC source
value is the BF/S instruction address.  As the 8-bit displacement is multiplied
by two after sign-extension, the branch destination can be located in the range
from -256 to +254 bytes from the BF/S instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, when the branch condition is satisfied,
the instruction following this instruction is executed before the branch
destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
If this instruction is located in the delay slot immediately following a delayed
branch instruction, it is identified as a slot illegal instruction.
<br /><br />
If the branch destination cannot be reached, the branch must be handled by using
BF/S in combination with a BRA or JMP instruction, for example.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BFS (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;
  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 0)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 4;

  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">clrt           ! T is always 0
bt    /s trget_t ! Does not branch, because T = 0
nop            ! 
bf    /s trget_f ! Branches to TRGET_F, because T = 0
add    r0,r1   ! Executed before branch .
nop            ! ← The PC location is used to calculate the branch destination
..........         !   address of the BF/S instruction
trget _f:      ! ← Branch destination of the BF/S instruction
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row151" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row151">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bt	label</span>
<span>If T = 1: disp × 2 + PC + 4 → PC
Else: nop</span>
<span id="10001001dddddddd" class="colorized"><span title="Opcode Identifier">10001001</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1-3</var><var>1/3</var></span>
<span class="cycle_grid"><var>1/3</var><var>1/3</var><var></var><var>1/3</var><var></var><var></var><var>1/2</var><var>1</var><var>1/3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This is a conditional branch instruction that references the T bit. The branch
is taken if T = 1, and not taken if T = 0.  The branch destination is address
(PC + 4 + displacement × 2). The PC source value is the BT instruction address.
As the 8-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -256 to +254 bytes from the BT
instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />If the branch destination cannot be reached, the branch must be handled by using
BT in combination with a BRA or JMP instruction, for example.
<br /><br />
On some SH4 implementations a branch with a displacement value of zero does not
cause the pipeline I-stage to be stalled even if the branch is taken.  This can
be utilized for efficient conditional operations.
<br /><br />
On some SH2E implementations (SH7055) there is an FPU related hardware bug
which affects this instruction.  The recommended workaround is to use bt/s with
a nop in the delay slot.
See also documents "sh2eoc.pdf" and "win_update_a.pdf".
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BT (int d)
{
  int disp;
  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 1)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sett           ! T is always 1
bf     trget_f ! Does not branch, because T = 1
bt     trget_t ! Branches to TRGET_T, because T = 1
nop            ! 
nop            ! ← The PC location is used to calculate the branch destination
..........         !   address of the BT instruction
trget _t:      ! ← Branch destination of the BT instruction
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row152" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row152">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bt/s	label</span>
<span>If T = 1: disp × 2 + PC + 4 → PC
Else: nop
(Delayed branch)</span>
<span id="10001101dddddddd" class="colorized"><span title="Opcode Identifier">10001101</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1-3</var><var>1/2</var></span>
<span class="cycle_grid"><var></var><var>1/2</var><var></var><var>1/2</var><var></var><var></var><var>1/2</var><var>1</var><var>1/2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This is a conditional branch instruction that references the T bit. The branch
is taken if T = 1, and not taken if T = 0.  The PC source value is the BT/S
instruction address. As the 8-bit displacement is multiplied by two after
sign-extension, the branch destination can be located in the range from -256 to
+254 bytes from the BT/S instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, when the branch condition is satisfied,
the instruction following this instruction is executed before the branch
destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
If the branch destination cannot be reached, the branch must be handled by using
BT/S in combination with a BRA or JMP instruction, for example.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BTS (int d)
{
  int disp;
  unsigned temp;
  temp = PC;

  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 1)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 4;

  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sett           ! T is always 1
bf    /s target_f ! Does not branch, because T = 1
nop            ! 
bt    /s target_t ! Branches to TARGET, because T = 1
add    r0,r1   ! Executes before branching.
nop            ! ← The PC location is used to calculate the branch destination
..........         !   address of the BT/S instruction
target_t:      ! ← Branch destination of the BT/S instruction
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row153" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row153">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bra	label</span>
<span>disp × 2 + PC + 4 → PC
(Delayed branch)</span>
<span id="1010dddddddddddd" class="colorized"><span title="Opcode Identifier">1010</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1-3</var><var>2</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This is an unconditional branch instruction. The branch destination is address
(PC + 4 + displacement × 2). The PC source value is the BRA instruction address.
As the 12-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -4096 to +4094 bytes from the BRA
instruction. If the branch destination cannot be reached, this branch can be
performed with a JMP instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BRA (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;

  if ((d & 0x800) == 0)
    disp = (0x00000FFF & d);
  else
    disp = (0xFFFFF000 | d);

  PC = PC + 4 + (disp &lt;&lt; 1);
  Delay_Slot(temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">bra    trget   ! Branches to TRGET
add    r0,r1   ! Executes ADD before branching
nop            ! ← The PC location is used to calculate the branch destination
..........         ! address of the BRA instruction
trget :        ! ← Branch destination of the BRA instruction
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row154" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row154">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>braf	Rm</span>
<span>Rm + PC + 4 → PC
(Delayed branch)</span>
<span id="0000mmmm00100011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00100011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>4</var><var>2</var></span>
<span class="cycle_grid"><var></var><var>2</var><var></var><var>2</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This is an unconditional branch instruction. The branch destination is address
(PC + 4 + Rm).
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BRAF (int m)
{
  unsigned int temp;
  temp = PC;
  PC = PC + 4 + R[m];
  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  #(target-bsrf_pc),r0 ! Sets displacement.
bra    trget   ! Branches to TARGET
add    r0,r1   ! Executes ADD before branching
braf  _pc:     ! ← The PC location is used to calculate the
      branch destination address of the BRAF
      instruction
nop   
....................
target:        ! ← Branch destination of the BRAF instruction
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row155" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row155">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bsr	label</span>
<span>PC + 4 → PR, disp × 2 + PC + 4 → PC
(Delayed branch)</span>
<span id="1011dddddddddddd" class="colorized"><span title="Opcode Identifier">1011</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1-3</var><var>2</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Branches to address (PC + 4 + displacement × 2), and stores address (PC + 4) in
PR. The PC source value is the BSR instruction address.
As the 12-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -4096 to +4094 bytes from the BSR
instruction. If the branch destination cannot be reached, this branch can be
performed with a JSR instruction.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BSR (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;

  if ((d & 0x800) == 0)
    disp = (0x00000FFF & d);
  else
    disp = (0xFFFFF000 | d);

  PR = PC + 4;
  PC = PC + 4 + (disp &lt;&lt; 1);
  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">bsr    trget   ! Branches to TRGET
mov    r3,r4   ! Executes the MOV instruction before branching
add    r0,r1   ! ← The PC location is used to calculate the branch destination
      address of the BSR instruction (return address for when the
      subroutine procedure is completed (PR data))
.......
.......
trget :        ! ← Procedure entrance
mov    r2,r3   ! 
rts            ! Returns to the above ADD instruction
mov    #1,r0   ! Executes MOV before branching
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row156" />
<label class="summary SH2 SH3 SH4 SH4A SH2A" for="row156">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bsrf	Rm</span>
<span>PC + 4 → PR, Rm + PC + 4 → PC
(Delayed branch)</span>
<span id="0000mmmm00000011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00000011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>4</var><var>2</var></span>
<span class="cycle_grid"><var></var><var>2</var><var></var><var>2</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Branches to address (PC + 4 + Rm), and stores address (PC + 4) in PR. The PC
source value is the BSRF instruction address. The branch destination address is
the result of adding the 32-bit contents of general register Rm to PC + 4.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void BSRF (int m)
{
  unsigned int temp;
  temp = PC;
  PR = PC + 4;
  PC = PC + 4 + R[m];
  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  #(target-bsrf_pc),r0 ! Sets displacement.
brsf   r0      ! Branches to TARGET
mov    r3,r4   ! Executes the MOV instruction before
branching
bsrf  _pc:     ! ← The PC location is used to calculate the
        branch destination with BSRF.
add    r0,r1
..... 
..... 
target:        ! ←Procedure entrance
mov    r2,r3   ! 
rts            ! Returns to the above ADD instruction
mov    #1,r0   ! Executes MOV before branching
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row157" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row157">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jmp	@Rm</span>
<span>Rm → PC
(Delayed branch)</span>
<span id="0100mmmm00101011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00101011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>4</var><var>2</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Unconditionally makes a delayed branch to the address specified by Rm.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void JMP (int m)
{
  unsigned int temp;
  temp = PC;
  PC = R[m];
  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  jmp_table,r0 ! Address of r0 = TRGET
jmp    @r0     ! Branches to TRGET
mov    r0,r1   ! Executes MOV before branching
.align 4
jmp   _table:
.data.l trget   ! Jump table
.................
trget : add #1,r1 ! ← Branch destination
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row158" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row158">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jsr	@Rm</span>
<span>PC + 4 → PR, Rm → PC
(Delayed branch)</span>
<span id="0100mmmm00001011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00001011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>4</var><var>2</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Makes a delayed branch to the subroutine procedure at the specified address
after execution of the following instruction. Return address (PC + 4) is saved
in PR, and a branch is made to the address indicated by general register Rm.
JSR is used in combination with RTS for subroutine procedure calls.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void JSR (int m)
{
  unsigned int temp;
  temp = PC;
  PR = PC + 4;
  PC = R[m];
  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  jsr_table,r0 ! Address of r0 = TRGET
jsr    @r0     ! Branches to TRGET
xor    r1,r1   ! Executes XOR before branching
add    r0,r1   ! ← Return address for when the subroutine
        procedure is completed (PR data)
...........
.align 4
jsr   _table:
.data.l trget   ! Jump table
trget : nop    ! ← Procedure entrance
mov    r2,r3   ! 
rts            ! Returns to the above ADD instruction
mov    #70,r1  ! Executes MOV before RTS
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row159" />
<label class="summary SH2A" for="row159">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jsr/n	@Rm</span>
<span>PC + 2 → PR, Rm → PC</span>
<span id="0100mmmm01001011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01001011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Branches to a subroutine procedure at the designated address. The contents of
PC are stored in PR and execution branches to the address indicated by the
contents of general register Rm as 32-bit data. The stored contents of PC
indicate the starting address of the second instruction after the present
instruction. This instruction is used with RTS as a subroutine procedure call.
<br /><br />
<span title="section">Note</span>
<br />
<br />This is not a delayed branch instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void JSRN (int m)
{
  unsigned long temp;
  temp = PC;
  PR = PC + 2;
  PC = R[m];
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row160" />
<label class="summary SH2A" for="row160">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jsr/n	@@(disp8,TBR)</span>
<span>PC + 2 → PR, (disp × 4 + TBR) → PC</span>
<span id="10000011dddddddd" class="colorized"><span title="Opcode Identifier">10000011</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>5</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>5</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Branches to a subroutine procedure at the designated address. The contents of PC
are stored in PR and execution branches to the address indicated by the address
read from memory address (disp × 4 + TBR). The stored contents of PC indicate
the starting address of the second instruction after the present instruction.
This instruction is used with RTS as a subroutine procedure call.
<br /><br />
<span title="section">Note</span>
<br />
<br />This is not a delayed branch instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void JSRNM (int d)
{
  long disp = (0x000000FF & d);
  PR = PC + 2;
  PC = Read_32 (TBR + (disp &lt;&lt; 2));
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row161" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row161">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rts</span>
<span>PR → PC
Delayed branch</span>
<span id="0000000000001011" class="colorized"><span title="Opcode Identifier">0000000000001011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1-4</var><var>2</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Returns from a subroutine procedure by restoring the PC from PR. Processing
continues from the address indicated by the restored PC value. This instruction
can be used to return from a subroutine procedure called by a BSR or JSR
instruction to the source of the call.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a
slot illegal instruction.
<br /><br />
The instruction that restores PR must be executed before the RTS instruction.
This restore instruction cannot be in the RTS delay slot.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void RTS (void)
{
  unsigned int temp;
  temp = PC;
  PC = PR;
  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">mov.l  table,r3 ! r3 = Address of TRGET
jsr    @r3     ! Branches to TRGET
nop            ! Executes NOP before branching
add    r0,r1   ! ← Return address for when the subroutine procedure is
completed (pr data)
.............
table : .data.l trget ! Jump table
.............
trget : mov r1,r0 ! ← Procedure entrance
rts            ! PR data → PC
mov    #12,r0  ! Executes MOV before branching
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row162" />
<label class="summary SH2A" for="row162">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rts/n</span>
<span>PR → PC</span>
<span id="0000000001101011" class="colorized"><span title="Opcode Identifier">0000000001101011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs a return from a subroutine procedure. That is, the PC is restored from
PR, and processing is resumed from the address indicated by the PC. This
instruction enables a return to be made from a subroutine procedure called by a
BSR or JSR instruction to the origin of the call.
<br /><br />
<span title="section">Note</span>
<br />
<br />This is not a delayed branch instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void RTSN (void)
{
  PC = PR;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row163" />
<label class="summary SH2A" for="row163">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rtv/n	Rm</span>
<span>Rm → R0, PR → PC</span>
<span id="0000mmmm01111011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01111011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Performs a return from a subroutine procedure after a transfer from specified
general register Rm to R0. That is, after the Rm value is stored in R0, the PC
is restored from PR, and processing is resumed from the address indicated by the
PC. This instruction enables a return to be made from a subroutine procedure
called by a BSR or JSR instruction to the origin of the call.
<br /><br />
<span title="section">Note</span>
<br />
<br />This is not a delayed branch instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void RTVN (int m)
{
  R[0] = R[m];
  PC = PR;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<br/><br/><br/><b>System Control Instructions</b><br/><br/>
<input type="checkbox" id="row164" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row164">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clrmac</span>
<span>0 → MACH, 0 → MACL</span>
<span id="0000000000101000" class="colorized"><span title="Opcode Identifier">0000000000101000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears the MACH and MACL registers.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLRMAC (void)
{
  MACH = 0;
  MACL = 0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">clrmac         ! Clears and initializes the MAC register
mac.w  @r0+,@r1+ ! Multiply and accumulate operation
mac.w  @r0+,@r1+ ! 
</span>
</span>
</label>
<input type="checkbox" id="row165" />
<label class="summary SH3 SH4 SH4A" for="row165">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clrs</span>
<span>0 → S</span>
<span id="0000000001001000" class="colorized"><span title="Opcode Identifier">0000000001001000</span></span>
<span>0 → S</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears the S bit to 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLRS (void)
{
  S = 0;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row166" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row166">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clrt</span>
<span>0 → T</span>
<span id="0000000000001000" class="colorized"><span title="Opcode Identifier">0000000000001000</span></span>
<span>0 → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears the T bit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void CLRT (void)
{
  T = 0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">clrt           ! Before execution: T = 1
      After execution: T = 0
</span>
</span>
</label>
<input type="checkbox" id="row167" />
<label class="summary SH4A" for="row167">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>icbi	@Rn</span>
<span>Invalidate instruction cache block indicated by logical address</span>
<span id="0000nnnn11100011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11100011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>16</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>13</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Accesses the instruction cache at the effective address indicated by the
contents of Rn. When the cache is hit, the corresponding cache block is
invalidated (the V bit is cleared to 0). At this time, write-back is not
performed. No operation is performed in the case of a cache miss or access to
a non-cache area.
<br /><br />
<span title="section">Note</span>
<br />
<br />When a program is overwriting RAM to modify its own execution, the corresponding
block of the instruction cache should be invalidated by the ICBI instruction.
This prevents execution of the program from the instruction cache, where the
non-overwritten instructions are stored.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void ICBI (int n)
{
  invalidate_instruction_cache_block (R[n]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Instruction TLB multiple-hit exception</var>
  <var>Instruction TLB miss exception</var>
  <var>Instruction TLB protection violation exception</var>
  <var>Instruction address error</var>
  <var>Slot illegal instruction exception</var>
  <var>Exceptions may occur when invalidation is not performed.</var>
</span>
</span>
</label>
<input type="checkbox" id="row168" />
<label class="summary SH2A" for="row168">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldbank	@Rm,R0</span>
<span>(Specified register bank entry) → R0</span>
<span id="0100mmmm11100101" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11100101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>6</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>5</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />The register bank entry indicated by the contents of general register Rm is
transferred to general register R0. The register bank number and register stored
in the bank are specified by general register Rm.
<br /><img alt="" class="image_filter" src="ldbank.svg" height="400" />
<br /><br />
<span title="section">Note</span>
<br />
<br />The architecture supports a maximum of 512 banks. However, the number of banks
differs depending on the product.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDBANK (int m)
{
  R[0] = Read_Bank_32 (R[m]);
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row169" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row169">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,SR</span>
<span>Rm → SR</span>
<span id="0100mmmm00001110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00001110</span></span>
<span>LSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>4</var><var>7</var><var>3</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>5</var><var></var><var></var><var>4</var><var>4</var><var>2</var></span>
<span class="details">
<span title="section">Load to Control Register</span>
<br />
<br />Stores the source operand in the control register SR.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCSR (int m)
{
  #if SH1 || SH2 || SH2 || SH3
  SR = R[m] & 0x0FFF0FFF;

  #elif SH2A
  SR = R[m] & 0x000063F3;

  #elif SH4 || SH4A
  SR = R[m] & 0x700083F3;

  #endif

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">ldc    r0,sr   ! Before execution: r0 = 0xFFFFFFFF, SR = 0x00000000
      After execution: SR = 0x0FFF0FFF
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row170" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row170">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,SR</span>
<span>(Rm) → SR, Rm+4 → Rm</span>
<span id="0100mmmm00000111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00000111</span></span>
<span>LSB → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>2</var><var></var><var></var><var>4</var><var>9</var><var>5</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>7</var><var></var><var></var><var>4/4</var><var>4</var><var>4</var></span>
<span class="details">
<span title="section">Load to Control Register</span>
<br />
<br />Stores the source operand in the control register SR.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMSR (int m)
{
  #if SH1 || SH2 || SH2 || SH3
  SR = Read_32 (R[m]) & 0x0FFF0FFF;

  #elif SH2A
  SR = Read_32 (R[m]) & 0x000063F3;

  #elif SH4 || SH4A
  SR = Read_32 (R[m]) & 0x700083F3;

  #endif

  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row171" />
<label class="summary SH2A" for="row171">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,TBR</span>
<span>Rm → TBR</span>
<span id="0100mmmm01001010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01001010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register TBR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCTBR (int m)
{
  TBR = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row172" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row172">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,GBR</span>
<span>Rm → GBR</span>
<span id="0100mmmm00011110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00011110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1/3</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register GBR.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be issued in user mode.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCGBR (int m)
{
  GBR = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row173" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row173">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,GBR</span>
<span>(Rm) → GBR, Rm+4 → Rm</span>
<span id="0100mmmm00010111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00010111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>1/5</var><var></var><var></var><var>3/3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register GBR.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be issued in user mode.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMGBR (int m)
{
  GBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">ldc.l  @r15+,gbr ! Before execution: r15 = 0x10000000
      After execution: r15 = 0x10000004, GBR = @0x10000000
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row174" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row174">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,VBR</span>
<span>Rm → VBR</span>
<span id="0100mmmm00101110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00101110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1/3</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register VBR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCVBR (int m)
{
  VBR = R[m];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row175" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row175">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,VBR</span>
<span>(Rm) → VBR, Rm+4 → Rm</span>
<span id="0100mmmm00100111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00100111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>1/5</var><var></var><var></var><var>1/3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register VBR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMVBR (int m)
{
  VBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row176" />
<label class="summary DSP" for="row176">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,MOD</span>
<span>Rm → MOD</span>
<span id="0100mmmm01011110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01011110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register MOD.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMOD (int m)
{
  MOD = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row177" />
<label class="summary DSP" for="row177">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,MOD</span>
<span>(Rm) → MOD, Rm+4 → Rm</span>
<span id="0100mmmm01010111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01010111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register MOD.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 3 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMMOD (int m)
{
  MOD = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row178" />
<label class="summary DSP" for="row178">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,RE</span>
<span>Rm → RE</span>
<span id="0100mmmm01111110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01111110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register RE.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCRE (int m)
{
  RE = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row179" />
<label class="summary DSP" for="row179">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,RE</span>
<span>(Rm) → RE, Rm+4 → Rm</span>
<span id="0100mmmm01110111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01110111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register RE.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 3 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMRE (int m)
{
  RE = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row180" />
<label class="summary DSP" for="row180">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,RS</span>
<span>Rm → RS</span>
<span id="0100mmmm01101110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01101110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register RS.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCRS (int m)
{
  RS = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row181" />
<label class="summary DSP" for="row181">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,RS</span>
<span>(Rm) → RS, Rm+4 → Rm</span>
<span id="0100mmmm01100111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01100111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register RS.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 3 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMRS (int m)
{
  RS = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row182" />
<label class="summary SH4A" for="row182">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,SGR</span>
<span>Rm → SGR</span>
<span id="0100mmmm00111010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register SGR.
<br /><br />
<span title="section">Note</span>
<br />
<br />Not sure whether it is also available on SH4.
It is not marked as new instruction for SH4A but is also not listed in SH4
manuals.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCSGR (int m)
{
  SGR = R[m];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row183" />
<label class="summary SH4A" for="row183">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,SGR</span>
<span>(Rm) → SGR, Rm+4 → Rm</span>
<span id="0100mmmm00110110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00110110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register SGR.
<br /><br />
<span title="section">Note</span>
<br />
<br />Not sure whether it is also available on SH4.
It is not marked as new instruction for SH4A but is also not listed in SH4
manuals.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMSGR (int m)
{
  SGR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row184" />
<label class="summary SH3 SH4 SH4A" for="row184">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,SSR</span>
<span>Rm → SSR</span>
<span id="0100mmmm00111110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00111110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/3</var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register SSR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCSSR (int m)
{
  SSR = R[m],
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row185" />
<label class="summary SH3 SH4 SH4A" for="row185">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,SSR</span>
<span>(Rm) → SSR, Rm+4 → Rm</span>
<span id="0100mmmm00110111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00110111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register SSR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMSSR (int m)
{
  SSR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row186" />
<label class="summary SH3 SH4 SH4A" for="row186">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,SPC</span>
<span>Rm → SPC</span>
<span id="0100mmmm01001110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01001110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/3</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register SPC.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCSPC (int m)
{
  SPC = R[m];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row187" />
<label class="summary SH3 SH4 SH4A" for="row187">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,SPC</span>
<span>(Rm) → SPC, Rm+4 → Rm</span>
<span id="0100mmmm01000111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01000111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register SPC.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMSPC (int m)
{
  SPC = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row188" />
<label class="summary SH4 SH4A" for="row188">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,DBR</span>
<span>Rm → DBR</span>
<span id="0100mmmm11111010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register DBR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCDBR (int m)
{
  DBR = R[m];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row189" />
<label class="summary SH4 SH4A" for="row189">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,DBR</span>
<span>(Rm) → DBR, Rm+4 → Rm</span>
<span id="0100mmmm11110110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">11110110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/3</var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in control register DBR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMDBR (int m)
{
  DBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row190" />
<label class="summary SH3 SH4 SH4A" for="row190">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc	Rm,Rn_BANK</span>
<span>Rm → Rn_BANK (n = 0-7)</span>
<span id="0100mmmm1nnn1110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">1110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/3</var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in banked general register.
Rn_BANK0 is accessed when the RB bit in the SR register is 1, and Rn_BANK1 is
accessed when this bit is 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCRn_BANK (int m)
{
  Rn_BANK = R[m];
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row191" />
<label class="summary SH3 SH4 SH4A" for="row191">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l	@Rm+,Rn_BANK</span>
<span>(Rm) → Rn_BANK, Rm+4 → Rm</span>
<span id="0100mmmm1nnn0111" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a source operand in banked general register.
Rn_BANK0 is accessed when the RB bit in the SR register is 1, and Rn_BANK1 is
accessed when this bit is 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDCMRn_BANK (int m)
{
  Rn_BANK = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row192" />
<label class="summary DSP" for="row192">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldre	@(disp,PC)</span>
<span>disp × 2 + PC → RE</span>
<span id="10001110dddddddd" class="colorized"><span title="Opcode Identifier">10001110</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the effective address of the source operand in the repeat end register
RE. The effective address is an address specified by PC + displacement. The PC
is the address four bytes after this instruction. The 8-bit displacement is
sign-extended and doubled. Consequently, the relative interval from the branch
destination is -256 to +254 bytes.
<br /><br />
<span title="section">Note</span>
<br />
<br />The effective address value designated for the RE reregister is different from
the actual repeat end address. Refer to RS and RE Design Rules, for more
information.
<br /><br />
When this instruction is arranged immediately after the delayed
branch instruction, PC becomes the "first address +2" of the branch destination.
<br /><br />
On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDRE (int d)
{
  long disp;

  if ((d & 0x80) == 0)
    disp = (0x000000FF & (long)d);
  else
    disp = (0xFFFFFF00 | (long)d);

  RE = PC + (disp &lt;&lt; 1);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...
</span>
</span>
</label>
<input type="checkbox" id="row193" />
<label class="summary DSP" for="row193">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldrs	@(disp,PC)</span>
<span>disp × 2 + PC → RS</span>
<span id="10001100dddddddd" class="colorized"><span title="Opcode Identifier">10001100</span><span title="Displacement (8 bits)">dddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the effective address of the source operand in the repeat start register
RS. The effective address is an address specified by PC + displacement. The PC
is the address four bytes after this instruction. The 8-bit displacement is
sign-extended and doubled. Consequently, the relative interval from the branch
destination is -256 to +254 bytes.
<br /><br />
<span title="section">Note</span>
<br />
<br />When the instructions of the repeat (loop) program are below 3, the effective
address value designated for the RS register is different from the actual repeat
start address. Refer to "RS and RE setting rule", for more information. If this
<br /><br />
instruction is arranged immediately after the delayed branch instruction, the PC
becomes "the first address +2" of the branch destination.
<br /><br />
On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDRS (int d)
{
  long disp;

  if ((d & 0x80) == 0)
    disp = (0x000000FF & (long)d);
  else
    disp = (0xFFFFFF00 | (long)d);

  RS = PC + (disp &lt;&lt; 1);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...
</span>
</span>
</label>
<input type="checkbox" id="row194" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row194">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,MACH</span>
<span>Rm → MACH</span>
<span id="0100mmmm00001010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00001010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the system register MACH.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH1, only the lower 10 bits are stored in MACH.
<br /><br />
On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMACH (int m)
{
  MACH = R[m];

  #if SH1
  if ((MACH & 0x00000200) == 0)
    MACH &= 0x000003FF;
  else
    MACH |= 0xFFFFFC00;
  #endif

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row195" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row195">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,MACH</span>
<span>(Rm) → MACH, Rm+4 → Rm</span>
<span id="0100mmmm00000110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00000110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the system register MACH.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMMACH (int m)
{
  MACH = Read_32 (R[m]);

  #if SH1
  if ((MACH & 0x00000200) == 0)
    MACH &= 0x000003FF;
  else
    MACH |= 0xFFFFFC00;
  #endif

  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">lds.l  @r15+,macl ! Before execution: r15 = 0x10000000
                       ! After execution:  r15 = 0x10000004, MACL = @0x10000000
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row196" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row196">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,MACL</span>
<span>Rm → MACL</span>
<span id="0100mmmm00011010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00011010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the system register MACL.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMACL (int m)
{
  MACL = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row197" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row197">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,MACL</span>
<span>(Rm) → MACL, Rm+4 → Rm</span>
<span id="0100mmmm00010110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00010110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the system register MACL.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by
MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMMACL (int m)
{
  MACL = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">lds.l  @r15+,macl ! Before execution: r15 = 0x10000000
      After execution: r15 = 0x10000004, MACL = @0x10000000
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row198" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row198">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,PR</span>
<span>Rm → PR</span>
<span id="0100mmmm00101010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the system register PR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSPR (int m)
{
  PR = R[m];
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">lds    r0,pr   ! Before execution: r0 = 0x12345678, PR = 0x00000000
      After execution: PR = 0x12345678
</span>
</span>
</label>
<input type="checkbox" id="row199" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row199">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,PR</span>
<span>(Rm) → PR, Rm+4 → Rm</span>
<span id="0100mmmm00100110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00100110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2/3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the system register PR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMPR (int m)
{
  PR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row200" />
<label class="summary DSP" for="row200">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,DSR</span>
<span>Rm → DSR</span>
<span id="0100mmmm01101010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section">Load to FPU System register</span>
<br />
<br />Stores the source operand into the DSP register DSR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSDSR (int m)
{
  DSR = R[m] & 0x0000000F;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row201" />
<label class="summary DSP" for="row201">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,A0</span>
<span>Rm → A0</span>
<span id="0100mmmm01111010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register A0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSA0 (long m)
{
 A0 = R[m];

 if ((A0 & 0x80000000) == 0)
   A0G = 0x00;
 else
   A0G = 0xFF;

 PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row202" />
<label class="summary DSP" for="row202">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,DSR</span>
<span>(Rm) → DSR, Rm+4 → Rm</span>
<span id="0100mmmm01100110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01100110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section">Load to FPU System register</span>
<br />
<br />Stores the source operand into the DSP register DSR.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMDSR (int m)
{
  DSR = Read_32 (R[m]) & 0x0000000F;
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row203" />
<label class="summary DSP" for="row203">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,A0</span>
<span>(Rm) → A0, Rm+4 → Rm</span>
<span id="0100mmmm01110110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01110110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register A0.  The MSB of the data is
copied into A0G.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMA0 (int m)
{
  A0 = Read_32 (R[m]);

  if ((A0 & 0x80000000) == 0)
    A0G = 0x00;
  else
    A0G = 0xFF;

  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row204" />
<label class="summary DSP" for="row204">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,X0</span>
<span>Rm → X0</span>
<span id="0100mmmm10001010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">10001010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register X0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSX0 (int m)
{
  X0 = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row205" />
<label class="summary DSP" for="row205">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,X0</span>
<span>(Rm) → X0, Rm+4 → Rm</span>
<span id="0100nnnn10000110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register X0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMX0 (int m)
{
  X0 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row206" />
<label class="summary DSP" for="row206">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,X1</span>
<span>Rm → X1</span>
<span id="0100mmmm10011010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">10011010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register X1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSX1 (int m)
{
  X1 = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row207" />
<label class="summary DSP" for="row207">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,X1</span>
<span>(Rm) → X1, Rm+4 → Rm</span>
<span id="0100nnnn10010110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10010110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register X1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMX1 (int m)
{
  X1 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row208" />
<label class="summary DSP" for="row208">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,Y0</span>
<span>Rm → Y0</span>
<span id="0100mmmm10101010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">10101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register Y0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSY0 (int m)
{
  Y0 = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row209" />
<label class="summary DSP" for="row209">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,Y0</span>
<span>(Rm) → Y0, Rm+4 → Rm</span>
<span id="0100nnnn10100110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10100110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register Y0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMY0 (int m)
{
  Y0 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row210" />
<label class="summary DSP" for="row210">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,Y1</span>
<span>Rm → Y1</span>
<span id="0100mmmm10111010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">10111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register Y1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSY1 (int m)
{
  Y1 = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row211" />
<label class="summary DSP" for="row211">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,Y1</span>
<span>(Rm) → Y1, Rm+4 → Rm</span>
<span id="0100nnnn10110110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10110110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the source operand into the DSP register Y1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMY1 (int m)
{
  Y1 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row212" />
<label class="summary SH3 SH4 SH4A" for="row212">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldtlb</span>
<span>PTEH/PTEL → TLB</span>
<span id="0000000000111000" class="colorized"><span title="Opcode Identifier">0000000000111000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Loads the contents of the PTEH/PTEL registers into the TLB (translation
lookaside buffer) specified by MMUCR.URC (random counter field in the MMC
control register).
<br /><br />
LDTLB is a privileged instruction, and can only be used in privileged mode. Use of this
instruction in user mode will cause an illegal instruction exception.
<br /><br />
<span title="section">Note</span>
<br />
<br />As this instruction loads the contents of the PTEH/PTEL registers into a TLB, it
should be used either with the MMU disabled, or in the P1 or P2 virtual space
with the MMU enabled (see the MMU section of the applicable hardware manual for
details).
<br /><br />
After this instruction is issued, there must be at least one instruction between
the LDTLB instruction and issuance of an instruction relating to address to the
P0, U0, and P3 areas (i.e. BRAF, BSRF, JMP, JSR, RTS, or RTE).
<br /><br />
If the instruction is issued in an exception handler, it should be at least two
instructions prior to an RTE instruction that terminates the handler.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDTLB (void)
{
  #if SH3
  TLB_tag = PTEH;
  TLB_data = PTEL;

  #elif SH4
  TLB[MMUCR.URC].ASID = PTEH & 0x000000FF;
  TLB[MMUCR.URC].VPN = (PTEH & 0xFFFFFC00) &gt;&gt; 10;
  TLB[MMUCR.URC].PPN = (PTEH & 0x1FFFFC00) &gt;&gt; 10;
  TLB[MMUCR.URC].SZ = (PTEL & 0x00000080) &gt;&gt; 6 | (PTEL & 0x00000010) &gt;&gt; 4;
  TLB[MMUCR.URC].SH = (PTEH & 0x00000002) &gt;&gt; 1;
  TLB[MMUCR.URC].PR = (PTEH & 0x00000060) &gt;&gt; 5;
  TLB[MMUCR.URC].WT = (PTEH & 0x00000001);
  TLB[MMUCR.URC].C = (PTEH & 0x00000008) &gt;&gt; 3;
  TLB[MMUCR.URC].D = (PTEH & 0x00000004) &gt;&gt; 2;
  TLB[MMUCR.URC].V = (PTEH & 0x00000100) &gt;&gt; 8;

  #endif

  PC += 2;
}

</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row213" />
<label class="summary SH4 SH4A" for="row213">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movca.l	R0,@Rn</span>
<span>R0 → (Rn) (without fetching cache block)</span>
<span id="0000nnnn11000011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11000011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3-7</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the contents of general register R0 in the memory location indicated by
effective address Rn. This instruction differs from other store instructions as
follows.
<br /><br />
If write-back is selected for the accessed memory, and a cache miss occurs, the
cache block will be allocated but an R0 data write will be performed to that
cache block without performing a block read. Other cache block contents are
undefined.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void MOVCAL (int n)
{
  if (is_write_back_memory (R[n]) && look_up_in_operand_cache (R[n]) == MISS)
    allocate_operand_cache_block (R[n]);

  Write_32 (R[n], R[0]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row214" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row214">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nop</span>
<span>No operation</span>
<span id="0000000000001001" class="colorized"><span title="Opcode Identifier">0000000000001001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>MT</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section">Note</span>
<br />
<br />Increments the program counter (PC), advancing the processing flow to execution
of the next instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void NOP (void)
{
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">nop            ! Executes in one cycle
</span>
</span>
</label>
<input type="checkbox" id="row215" />
<label class="summary SH4 SH4A" for="row215">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ocbi	@Rn</span>
<span>Invalidate operand cache block</span>
<span id="0000nnnn10010011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10010011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1-2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Accesses data using the contents indicated by effective address Rn. In the case
of a hit in the cache, the corresponding cache block is invalidated (the V bit
is cleared to 0). If there is unwritten information (U bit = 1), write-back is
not performed even if write-back mode is selected. No operation is performed in
the case of a cache miss or an access to a non-cache area.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void OCBI (int n)
{
  invalidate_operand_cache_block (R[n]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>Note that the above exceptions are generated even if OCBI does not operate.</var>
</span>
</span>
</label>
<input type="checkbox" id="row216" />
<label class="summary SH4 SH4A" for="row216">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ocbp	@Rn</span>
<span>Write back and invalidate operand cache block</span>
<span id="0000nnnn10100011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10100011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1-5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Accesses data using the contents indicated by effective address Rn. If the cache
is hit and there is unwritten information (U bit = 1), the corresponding cache
block is written back to external memory and that block is invalidated (the V
bit is cleared to 0). If there is no unwritten information (U bit = 0), the
block is simply invalidated. No operation is performed in the case of a cache
miss or an access to a non-cache area.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void OCBP (int n)
{
  if (is_dirty_block (R[n]))
    write_back (R[n])

  invalidate_operand_cache_block (R[n]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Note that the above exceptions are generated even if OCBP does not operate.</var>
</span>
</span>
</label>
<input type="checkbox" id="row217" />
<label class="summary SH4 SH4A" for="row217">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ocbwb	@Rn</span>
<span>Write back operand cache block</span>
<span id="0000nnnn10110011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10110011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1-5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Accesses data using the contents indicated by effective address Rn. If the cache
is hit and there is unwritten information (U bit = 1), the corresponding cache
block is written back to external memory and that block is cleaned (the U bit
is cleared to 0). In other cases (i.e. in the case of a cache miss or an access
to a non-cache area, or if the block is already clean), no operation is
performed.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void OCBWB (int n)
{
  if (is_dirty_block (R[n]))
    write_back (R[n]);

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Note that the above exceptions are generated even if OCBWB does not operate.</var>
</span>
</span>
</label>
<input type="checkbox" id="row218" />
<label class="summary SH3 SH4 SH4A SH2A" for="row218">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pref	@Rn</span>
<span>(Rn) → operand cache</span>
<span id="0000nnnn10000011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/2</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />SH4 and SH4A
<br />
Reads a 32-byte data block starting at a 32-byte boundary into the operand
cache. The lower 5 bits of the address specified by Rn are masked to zero.
<br />
This instruction is also used to trigger a Store Queue write-back operation if
the specified address points to the Store Queue area.  For more information
refer to Store Queues in the manual.
<br /><br />

SH3 and SH2A
<br />
Reads a 16-byte data block into the cache.  The address specified by Rn should
be on 32-bit boundary.  No address related error is detected in this
instruction. In case of an error, the instruction operates as NOP.
<br /><br />
<span title="section">Note</span>
<br />
<br />On products with no cache, this instruction is handled as a NOP instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void PREF (int n)
{
  prefetch_operand_cache_block (R[n]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row219" />
<label class="summary SH4A" for="row219">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>prefi	@Rn</span>
<span>Reads 32-byte instruction block into instruction cache</span>
<span id="0000nnnn11010011" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11010011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>13</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>10</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Reads a 32-byte block of data starting at a 32-byte boundary within the
instruction cache. The lower 5 bits of the address specified by Rn are masked
by zeroes.
<br /><br />
This instruction does not generate data address error and MMU exceptions. In the
event of an error, the PREFI instruction is treated as an NOP (no operation)
instruction.
<br /><br />
When the address to be prefetched is missing from UTLB or is protected, the
PREFI instruction is treated as an NOP instruction and a TLB exception does not
occur.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can be used before the SLEEP command is issued to prefetch
instructions for execution on return from the SLEEP state.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void PREFI (int n)
{
  prefetch_instruction_cache_block (R[n]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row220" />
<label class="summary SH2A" for="row220">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>resbank</span>
<span>Bank → R0 to R14, GBR, MACH, MACL, PR</span>
<span id="0000000001011011" class="colorized"><span title="Opcode Identifier">0000000001011011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>9/19</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>8/20</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Restores the last register saved to a register bank.
<br /><br />
<span title="section">Note</span>
<br />
<br />The issue cycle count is 19 when a bank overflow has occured and the registers
are restored from the stack.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void RESBANK (void)
{
  int m;  // Number of register bank to which a save was last performed.

  if (BO == 0)
  {
    PR = Register_Bank[m].PR_BANK;
    GBR = Register_Bank[m].GBR_BANK;
    MACL = Register_Bank[m].MACL_BANK;
    MACH = Register_Bank[m].MACH_BANK;

    for (int i = 0; i &lt;= 14; i++)
      R[i] = Register_Bank[m].R_BANK[i];
  }
  else
  {
    for (int i = 0; i &lt;= 14; i++)
    {
      R[i] = Read_32 (R[15]);
      R[15] += 4;
    }

    PR = Read_32 (R[15]);
    R[15] += 4;
    GBR = Read_32 (R[15]);
    R[15] += 4;
    MACH = Read_32 (R[15]);
    R[15] += 4;
    MACL = Read_32 (R[15]);
    R[15] += 4;
  }

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row221" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row221">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rte</span>
<span>Delayed branch
SH1*,SH2*: stack area → PC/SR
SH3*,SH4*: SSR/SPC → SR/PC</span>
<span id="0000000000101011" class="colorized"><span title="Opcode Identifier">0000000000101011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>5</var><var>5</var><var>6</var></span>
<span class="cycle_grid"><var>4</var><var>4</var><var></var><var>4</var><var></var><var></var><var>5</var><var>4</var><var>5</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Returns from an exception or interrupt handling routine by restoring the PC and
SR values.  Program execution continues from the address specified
by the restored PC value.
<br /><br />
On SH3 and SH4 the PC and SR values are restored from SPC and SSR.  The SR value
accessed by the instruction in the RTE delay slot is the value restored from SSR
by the RTE instruction. The SR and MD values defined prior to RTE execution are
used to fetch the instruction in the RTE delay slot.
<br /><br />
On SH1, SH2 and SH2A the PC and SR values are from the stack (R15).
<br /><br />
<span title="section">Note</span>
<br />
<br />As this is a delayed branch instruction, the instruction following the RTE
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction. An exception must not be generated by the instruction in this
instruction's delay slot. If the following instruction is a branch instruction,
it is identified as a slot illegal instruction.
<br /><br />
If this instruction is located in the delay slot immediately following a delayed
branch instruction, it is identified as a slot illegal instruction.
<br /><br />
On SH3 and SH4 the SR value accessed by the instruction in the RTE delay slot is
the value restored from SSR by the RTE instruction. The SR and MD values defined
prior to RTE execution are used to fetch the instruction in the RTE delay slot.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void RTE (void)
{
  unsigned long temp = PC;

  #if SH1 || SH2 || SH2A
  PC = Read_32 (R[15]);
  R[15] += 4;
  SR = Read_32 (R[15]) & 0x000063F3;
  R[15] += 4;

  #elif SH3 || SH4 || SH4A
  SR = SSR;
  PC = SPC;

  #endif

  Delay_Slot (temp + 2);
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">rte            ! Returns to the original routine
add    #8,r14  ! Executes ADD before branching
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row222" />
<label class="summary DSP" for="row222">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>setrc	Rn</span>
<span>Rn[11:0] → RC (SR[27:16])</span>
<span id="0100mmmm00010100" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00010100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sets the repeat count to the SR register's RC counter. The bottom 12 bits of the
general register Rn are used as the repeat count.
Set repeat control flags to RF1, RF0 bits of the SR register. Use of the SETRC
instruction is subject to any limitations. Refer to the DSP Repeat (Loop)
Control section of the manual for more information.
<br /><img alt="Set Repeat Count to RC operation" src="setrc.svg" height="140" />
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SETRC (int m)
{
  long temp = (R[m] & 0x00000FFF) &lt;&lt; 16;
  SR &= 0x00000FF3;
  SR |= temp;
  RF1 = Repeat_Control_Flag1;
  RF0 = Repeat_Control_Flag0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  r14       ! Repeat n times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...
</span>
</span>
</label>
<input type="checkbox" id="row223" />
<label class="summary DSP" for="row223">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>setrc	#imm</span>
<span>imm → RC (SR[23:16]), 0 → SR[27:24]</span>
<span id="10000010iiiiiiii" class="colorized"><span title="Opcode Identifier">10000010</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sets the repeat count to the SR register's RC counter. The 8-bit immediate value
is zero-extended and used as the repeat count.
Set repeat control flags to RF1, RF0 bits of the SR register. Use of the SETRC
instruction is subject to any limitations. Refer to the DSP Repeat (Loop)
Control section of the manual for more information.
<br /><img alt="Set Repeat Count to RC operation" src="setrci.svg" height="140" />
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SETRCI (int i)
{
  long temp = ((long)i & 0x000000FF) &lt;&lt; 16;
  SR &= 0x00000FFF;
  SR |= temp;
  RF1 = Repeat_Control_Flag1;
  RF0 = Repeat_Control_Flag0;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">
    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...
</span>
</span>
</label>
<input type="checkbox" id="row224" />
<label class="summary SH3 SH4 SH4A" for="row224">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sets</span>
<span>1 → S</span>
<span id="0000000001011000" class="colorized"><span title="Opcode Identifier">0000000001011000</span></span>
<span>1 → S</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sets the S bit to 1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SETS (void)
{
  S = 1;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row225" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row225">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sett</span>
<span>1 → T</span>
<span id="0000000000011000" class="colorized"><span title="Opcode Identifier">0000000000011000</span></span>
<span>1 → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Sets the T bit to 1.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SETT (void)
{
  T = 1;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sett           ! Before execution: T = 0
      After execution: T = 1
</span>
</span>
</label>
<input type="checkbox" id="row226" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row226">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sleep</span>
<span>Sleep or standby</span>
<span id="0000000000011011" class="colorized"><span title="Opcode Identifier">0000000000011011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>2</var><var></var><var></var><var>4</var><var>ud</var><var>5</var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var></var><var>4</var><var></var><var></var><var>4</var><var>ud</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Places the CPU in the power-down state.
<br /><br />
In power-down mode, the CPU retains its internal state, but immediately stops
executing instructions and waits for an interrupt request. When it receives an
interrupt request, the CPU exits the power-down state.
<br /><br />
SLEEP is a privileged instruction, and can only be used in privileged mode. Use
of this instruction in user mode will cause an illegal instruction exception.
<br /><br />
<span title="section">Note</span>
<br />
<br />SLEEP performance depends on the standby control register (STBCR). See
Power-Down Modes in the target product's hardware manual, for details.
<br /><br />
The number of cycles given is for the transition to sleep mode. "ud" means
the number of cycles is undefined.
<br /><br />
Some SH4 implementations have a hardware bug which restricts the instructions
that should follow this instruction for safe operation.  There are two
recommended workarounds:
Put 8 NOP instructions following the SLEEP instruction.
Put 5 "OR R0,R0" instructions following the SLEEP instruction
<br />
For more information see the document "tnsh7456ae.pdf".
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SLEEP (void)
{
  Sleep_standby();
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sleep          ! Enters power-down mode
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row227" />
<label class="summary SH2A" for="row227">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stbank	R0,@Rn</span>
<span>R0 → (specified register bank entry)</span>
<span id="0100nnnn11100001" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11100001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>7</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>6</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />R0 is transferred to the register bank entry indicated by the contents of
general register Rn. The register bank number and register stored in the bank
are specified by general register Rn.
<br /><img alt="" class="image_filter" src="stbank.svg" height="400" />
<br /><br />
<span title="section">Note</span>
<br />
<br />The architecture supports a maximum of 512 banks. However, the number of banks
differs depending on the product.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STBANK (int n)
{
  Write_Bank_32 (R[n], R[0])
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row228" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row228">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	SR,Rn</span>
<span>SR → Rn</span>
<span id="0000nnnn00000010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SR in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCSR (int n)
{
  R[n] = SR;
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">stc    sr,r0   ! Before execution: r0 = 0xFFFFFFFF, SR = 0x00000000
      After execution: r0 = 0x00000000
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row229" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row229">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	SR,@-Rn</span>
<span>Rn-4 → Rn, SR → (Rn)</span>
<span id="0100nnnn00000011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>1/2</var><var></var><var></var><var>2/2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SR in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SR);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row230" />
<label class="summary SH2A" for="row230">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	TBR,Rn</span>
<span>TBR → Rn</span>
<span id="0000nnnn01001010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01001010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register TBR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCTBR (int n)
{
  R[n] = TBR;
  PC += 2;
}

</span>
</span>
</label>
<input type="checkbox" id="row231" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row231">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	GBR,Rn</span>
<span>GBR → Rn</span>
<span id="0000nnnn00010010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00010010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register GBR in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be issued in user mode.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">STCGBR (int n)
{
  R[n] = GBR;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row232" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row232">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	GBR,@-Rn</span>
<span>Rn-4 → Rn, GBR → (Rn)</span>
<span id="0100nnnn00010011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00010011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>1/2</var><var></var><var></var><var>2/2</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register GBR in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction can also be issued in user mode.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMGBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], GBR);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">stc.l  gbr,@-r15 ! Before execution: r15 = 0x10000004
      After execution: r15 = 0x10000000, @r15 = GBR
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row233" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row233">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	VBR,Rn</span>
<span>VBR → Rn</span>
<span id="0000nnnn00100010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register VBR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCVBR (int n)
{
  R[n] = VBR;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row234" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row234">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	VBR,@-Rn</span>
<span>Rn-4 → Rn, VBR → (Rn)</span>
<span id="0100nnnn00100011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>1/2</var><var></var><var></var><var>2/2</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register VBR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMVBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], VBR);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row235" />
<label class="summary DSP" for="row235">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	MOD,Rn</span>
<span>MOD → Rn</span>
<span id="0000nnnn01010010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01010010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register MOD in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMOD (int n)
{
  R[n] = MOD;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row236" />
<label class="summary DSP" for="row236">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	MOD,@-Rn</span>
<span>Rn-4 → Rn, MOD → (Rn)</span>
<span id="0100nnnn01010011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01010011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/2</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register MOD in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMMOD (int n)
{
  R[n] -= 4;
  Write_32 (R[n], MOD);
  PC += 2;
}

</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row237" />
<label class="summary DSP" for="row237">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	RE,Rn</span>
<span>RE → Rn</span>
<span id="0000nnnn01110010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01110010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register RE in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCRE (int n)
{
  R[n] = RE;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row238" />
<label class="summary DSP" for="row238">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	RE,@-Rn</span>
<span>Rn-4 → Rn, RE → (Rn)</span>
<span id="0100nnnn01110011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01110011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/2</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register RE in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMRE (int n)
{
  R[n] -= 4;
  Write_32 (R[n], RE);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row239" />
<label class="summary DSP" for="row239">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	RS,Rn</span>
<span>RS → Rn</span>
<span id="0000nnnn01100010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01100010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register RS in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCRS (int n)
{
  R[n] = RS;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row240" />
<label class="summary DSP" for="row240">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	RS,@-Rn</span>
<span>Rn-4 → Rn, RS → (Rn)</span>
<span id="0100nnnn01100011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01100011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1/2</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register RS in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On the SH-DSP the latency of this instruction is 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMRS (int n)
{
  R[n] -= 4;
  Write_32 (R[n], RS);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row241" />
<label class="summary SH4 SH4A" for="row241">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	SGR,Rn</span>
<span>SGR → Rn</span>
<span id="0000nnnn00111010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SGR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCSGR (int n)
{
  R[n] = SGR;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row242" />
<label class="summary SH4 SH4A" for="row242">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	SGR,@-Rn</span>
<span>Rn-4 → Rn, SGR → (Rn)</span>
<span id="0100nnnn00110010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00110010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SGR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMSGR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SGR);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row243" />
<label class="summary SH3 SH4 SH4A" for="row243">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	SSR,Rn</span>
<span>SSR → Rn</span>
<span id="0000nnnn00110010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00110010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SSR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCSSR (int n)
{
  R[n] = SSR;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row244" />
<label class="summary SH3 SH4 SH4A" for="row244">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	SSR,@-Rn</span>
<span>Rn-4 → Rn, SSR → (Rn)</span>
<span id="0100nnnn00110011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00110011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/2</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SSR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMSSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SSR);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row245" />
<label class="summary SH3 SH4 SH4A" for="row245">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	SPC,Rn</span>
<span>SPC → Rn</span>
<span id="0000nnnn01000010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01000010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SPC in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCSPC (int n)
{
  R[n] = SPC;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row246" />
<label class="summary SH3 SH4 SH4A" for="row246">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	SPC,@-Rn</span>
<span>Rn-4 → Rn, SPC → (Rn)</span>
<span id="0100nnnn01000011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01000011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register SPC in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMSPC (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SPC);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row247" />
<label class="summary SH4 SH4A" for="row247">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	DBR,Rn</span>
<span>DBR → Rn</span>
<span id="0000nnnn11111010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register DBR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCDBR (int n)
{
  R[n] = DBR;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row248" />
<label class="summary SH4 SH4A" for="row248">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	DBR,@-Rn</span>
<span>Rn-4 → Rn, DBR → (Rn)</span>
<span id="0100nnnn11110010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">11110010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores control register DBR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMDBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], DBR);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row249" />
<label class="summary SH3 SH4 SH4A" for="row249">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc	Rm_BANK,Rn</span>
<span>Rm_BANK → Rn (m = 0-7)</span>
<span id="0000nnnn1mmm0010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">0010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a banked general register in the destination. Rn_BANK0 is accessed when
the RB bit in the SR register is 1, and Rn_BANK1 is accessed when this bit is 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCRm_BANK (int n)
{
  R[n] = Rm_BANK;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row250" />
<label class="summary SH3 SH4 SH4A" for="row250">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l	Rm_BANK,@-Rn</span>
<span>Rn-4 → Rn, Rm_BANK → (Rn) (m = 0-7)</span>
<span id="0100nnnn1mmm0011" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">0011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores a banked general register in the destination. Rn_BANK0 is accessed when
the RB bit in the SR register is 1, and Rn_BANK1 is accessed when this bit is 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STCMRm_BANK (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Rm_BANK);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row251" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row251">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	MACH,Rn</span>
<span>MACH → Rn</span>
<span id="0000nnnn00001010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00001010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores system register MACH in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH1, the value of bit 9 is transferred to and stored in the higher 22 bits
(bits 31 to 10) of the destination.
<br /><br />
On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMACH (int n)
{
  R[n] = MACH;

  #if SH1
  if ((R[n] & 0x00000200) == 0)
    R[n] &= 0x000003FF;
  else
    R[n] |= 0xFFFFFC00;

  #endif

  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sts    mach,r0 ! Before execution: r0 = 0xFFFFFFFF, MACH = 0x00000000
      After execution: r0 = 0x00000000
</span>
</span>
</label>
<input type="checkbox" id="row252" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row252">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	MACH,@-Rn</span>
<span>Rn-4 → Rn, MACH → (Rn)</span>
<span id="0100nnnn00000010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00000010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores system register MACH in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH1, the value of bit 9 is transferred to and stored in the higher 22 bits
(bits 31 to 10) of the destination.
<br /><br />
On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMMACH (int n)
{
  R[n] -= 4;

  #if SH1
  if ((MACH & 0x00000200) == 0)
    Write_32 (R[n], MACH & 0x000003FF);
  else
    Write_32 (R[n], MACH | 0xFFFFFC00)

  #else
  Write_32 (R[n], MACH);

  #endif

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row253" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row253">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	MACL,Rn</span>
<span>MACL → Rn</span>
<span id="0000nnnn00011010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00011010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores system register MACL in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMACL (int n)
{
  R[n] = MACL;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row254" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row254">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	MACL,@-Rn</span>
<span>Rn-4 → Rn, MACL → (Rn)</span>
<span id="0100nnnn00010010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00010010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>1/1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores system register MACL in the destination.
<br /><br />
<span title="section">Note</span>
<br />
<br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the
latency of the LDS to MAC* is 4 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMMACL (int n)
{
  R[n] -= 4;
  Write_32 (R[n], MACL);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row255" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row255">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	PR,Rn</span>
<span>PR → Rn</span>
<span id="0000nnnn00101010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores system register PR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSPR (int n)
{
  R[n] = PR;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row256" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row256">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	PR,@-Rn</span>
<span>Rn-4 → Rn, PR → (Rn)</span>
<span id="0100nnnn00100010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00100010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var></var><var>1</var><var></var><var></var><var>2/2</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores system register PR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMPR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], PR);
  PC += 2;
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">sts.l  pr,@–r15 ! Before execution: r15 = 0x10000004
      After execution: r15 = 0x10000000, @r15 = PR
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row257" />
<label class="summary DSP" for="row257">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	DSR,Rn</span>
<span>DSR → Rn</span>
<span id="0000nnnn01101010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section">Store from FPU System Register</span>
<br />
<br />Stores DSP register DSR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSDSR (int n)
{
  R[n] = DSR;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row258" />
<label class="summary DSP" for="row258">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	DSR,@-Rn</span>
<span>Rn-4 → Rn, DSR → (Rn)</span>
<span id="0100nnnn01100010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01100010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section">Store from FPU System Register</span>
<br />
<br />Stores DSP register DSR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMDSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], DSR);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row259" />
<label class="summary DSP" for="row259">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	A0,Rn</span>
<span>A0 → Rn</span>
<span id="0000nnnn01111010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register A0 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSA0 (int n)
{
  R[n] = A0;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row260" />
<label class="summary DSP" for="row260">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	A0,@-Rn</span>
<span>Rn-4 → Rn, A0 → (Rn)</span>
<span id="0100nnnn01110010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01110010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register A0 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMA0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], A0);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row261" />
<label class="summary DSP" for="row261">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	X0,Rn</span>
<span>X0 → Rn</span>
<span id="0000nnnn10001010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10001010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register X0 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSX0 (int n)
{
  R[n] = X0;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row262" />
<label class="summary DSP" for="row262">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	X0,@-Rn</span>
<span>Rn-4 → Rn, X0 → (Rn)</span>
<span id="0100nnnn10000010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10000010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register X0 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMX0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], X0);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row263" />
<label class="summary DSP" for="row263">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	X1,Rn</span>
<span>X1 → Rn</span>
<span id="0000nnnn10011010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10011010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register X1 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSX1 (int n)
{
  R[n] = X1;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row264" />
<label class="summary DSP" for="row264">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	X1,@-Rn</span>
<span>Rn-4 → Rn, X1 → (Rn)</span>
<span id="0100nnnn10010010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10010010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register X1 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMX1 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], X1);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row265" />
<label class="summary DSP" for="row265">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	Y0,Rn</span>
<span>Y0 → Rn</span>
<span id="0000nnnn10101010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register Y0 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSY0 (int n)
{
  R[n] = Y0;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row266" />
<label class="summary DSP" for="row266">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	Y0,@-Rn</span>
<span>Rn-4 → Rn, Y0 → (Rn)</span>
<span id="0100nnnn10100010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10100010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register Y0 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMY0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Y0);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row267" />
<label class="summary DSP" for="row267">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	Y1,Rn</span>
<span>Y1 → Rn</span>
<span id="0000nnnn10111010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10111010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register Y1 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSY1 (int n)
{
  R[n] = Y1;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row268" />
<label class="summary DSP" for="row268">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	Y1,@-Rn</span>
<span>Rn-4 → Rn, Y1 → (Rn)</span>
<span id="0100nnnn10110010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10110010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores DSP register Y1 in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMY1 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Y1);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row269" />
<label class="summary SH4A" for="row269">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>synco</span>
<span>Prevents the next instruction from being issued until instructions issued before this instruction has been completed.</span>
<span id="0000000010101011" class="colorized"><span title="Opcode Identifier">0000000010101011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>ud</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>ud</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />This instruction is used to synchronize data operations. When this instruction
is executed, the subsequent bus accesses are not executed until the execution of
all preceding bus accesses has been completed.
<br /><br />
<span title="section">Note</span>
<br />
<br />The SYNCO instruction can not guarantee the ordering of receipt timing which is
notified by the memory-mapped peripheral resources through the method except bus
when the register is changed by bus accesses. Refer to the description of each
registers to guarantee this ordering.
<br /><br />
Common example usages are:
Ordering access to memory areas which are shared with other memory users
Flushing all write buffers
Stopping memory-access operations from merging and becoming ineffective
Waiting for the completion of cache-control instructions
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void SYNCO (void)
{
  synchronize_data_operaiton ();
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row270" />
<label class="summary SH1 SH2 SH3 SH4 SH4A SH2A" for="row270">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>trapa	#imm</span>
<span>SH1*,SH2*: PC/SR → stack area, (imm*4 + VBR) → PC
SH3*,SH4*: PC/SR → SPC/SSR, imm*4 → TRA, 0x160 → EXPEVT, VBR + 0x0100 → PC</span>
<span id="11000011iiiiiiii" class="colorized"><span title="Opcode Identifier">11000011</span><span title="Unsigned Immediate Data (8 bits)">iiiiiiii</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var></var><var>2</var><var></var><var></var><var>7</var><var>14</var><var>5</var></span>
<span class="cycle_grid"><var>8</var><var>8</var><var></var><var>8</var><var></var><var></var><var>7</var><var>13</var><var>6</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Starts trap exception handling.

SH1, SH2 and SH2A:
<br />
The PC and SR values are stored on the stack, and the program branches to an
address specified by the vector. The vector is a memory address obtained by
zero-extending the 8-bit immediate data and then quadrupling it. The PC is the
start address of the next instruction. TRAPA and RTE are both used together for
system calls.
<br /><br />

SH3, SH4 and SH4A:
<br />
The values of (PC + 2), SR, and R15 are saved to SPC, SSR and SGR, and 8-bit
immediate data is stored in the TRA register (bits 9 to 2). The processor mode
is switched to privileged mode (the MD bit in SR is set to 1), and the BL bit
and RB bit in SR are set to 1.  As a result, exception and interrupt requests
are masked (not accepted), and the BANK1 registers (R0_BANK1 to R7_BANK1) are
selected. Exception code 0x160 is written to the EXPEVT register (bits 11 to 0).
The program branches to address (VBR + 0x00000100), indicated by the sum of the
VBR register contents and offset 0x00000100.
<br /><br />
<span title="section">Note</span>
<br />
<br />Some SH4 implementations have a hardware bug which restricts the instructions
that should follow this instruction for safe operation.  There are two
recommended workarounds:
Put 8 NOP instructions following the TRAPA instruction.
Put 5 "OR R0,R0" instructions following the TRAPA instruction
<br />
For more information see the document "tnsh7456ae.pdf".
<br /><br />
Some SH2E implementations (SH7055) have an FPU related hardware bug which
affects this instruction.  The recommended workaround is to align the addresses
of trapa handlers to 4 bytes and not to place any FPU or FPU related
instructions at addresses 4n + 2 in the handler.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void TRAPA (int i)
{
  int imm = (0x000000FF & i);

  #if SH1 || SH2 || SH2A
  R[15] -= 4;
  Write_32 (R[15], SR);
  R[15] -= 4;
  Write_32 (R[15], PC + 2);
  PC = Read_32 (VBR + (imm &lt;&lt; 2));

  #elif SH3 || SH4 || SH4A
  TRA = imm &lt;&lt; 2;
  SSR = SR;
  SPC = PC + 2;
  SGR = R15;
  SR.MD = 1;
  SR.BL = 1;
  SR.RB = 1;
  EXPEVT = 0x00000160;
  PC = VBR + 0x00000100;

  #endif
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">vbr   +0x80 .data.l 10000000 ! 
..........
trapa  #0x20   ! Branches to an address specified by data in address VBR + 0x80
tst    #0,r0   ! ← Return address from the trap routine (stacked PC value)
..........
      100000000 xor r0,r0 ! ← Trap routine entrance
      100000002 rte ! Returns to the TST instruction
      100000004 nop ! Executes NOP before RTE
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Unconditional trap</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<br/><br/><br/><b>32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)</b><br/><br/>
<input type="checkbox" id="row271" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row271">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	FRm,FRn</span>
<span>FRm → FRn</span>
<span id="1111nnnnmmmm1100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers FRm contents to FRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV (int m, int n)
{
  FR[n] = FR[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row272" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row272">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	@Rm,FRn</span>
<span>(Rm) → FRn</span>
<span id="1111nnnnmmmm1000" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>2</var><var>1</var><var>0/2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers contents of memory at address indicated by Rm to FRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_LOAD (int m, int n)
{
  FR[n] = Read_32 (R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row273" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row273">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	FRm,@Rn</span>
<span>FRm → (Rn)</span>
<span id="1111nnnnmmmm1010" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers FRm contents to memory at address indicated by Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_STORE (int m, int n)
{
  Write_32 (R[n], FR[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row274" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row274">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	@Rm+,FRn</span>
<span>(Rm) → FRn, Rm+4 → Rm</span>
<span id="1111nnnnmmmm1001" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1/2</var><var>1</var><var>1/2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers contents of memory at address indicated by Rm to FRn, and adds 4 to
Rm.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_RESTORE (int m, int n)
{
  FR[n] = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row275" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row275">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	FRm,@-Rn</span>
<span>Rn-4 → Rn, FRm → (Rn)</span>
<span id="1111nnnnmmmm1011" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1/1</var><var>1</var><var>1/0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts 4 from Rn, and transfers FRm contents to memory at address indicated
by resulting Rn value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_SAVE (int m, int n)
{
  Write_32 (R[n] - 4, FR[m]);
  R[n] -= 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row276" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row276">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	@(R0,Rm),FRn</span>
<span>(R0 + Rm) → FRn</span>
<span id="1111nnnnmmmm0110" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>2</var><var>1</var><var>0/2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers contents of memory at address indicated by (R0 + Rm) to FRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_LOAD (int m, int n)
{
  FR[n] = Read_32 (R[0] + R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row277" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row277">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	FRm,@(R0,Rn)</span>
<span>FRm → (R0 + Rn)</span>
<span id="1111nnnnmmmm0111" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers FRm contents to memory at address indicated by (R0 + Rn).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_STORE (int m, int n)
{
  Write_32 (R[0] + R[n], FR[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row278" />
<label class="summary SH2A" for="row278">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	@(disp12,Rm),FRn</span>
<span>(disp × 4 + Rm) → FRn</span>
<span id="0011nnnnmmmm0001_0111dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0111</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0/2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers memory contents at the address indicated by (disp + Rn) to FRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_DISP12_LOAD (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  FR[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row279" />
<label class="summary SH2A" for="row279">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s	FRm,@(disp12,Rn)</span>
<span>FRm → (disp × 4 + Rn)</span>
<span id="0011nnnnmmmm0001_0011dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0011</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers FRm contents to memory at the address indicated by (disp + Rn).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_DISP12_STORE (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), FR[m]);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<br/><br/><br/><b>64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)</b><br/><br/>
<input type="checkbox" id="row280" />
<label class="summary SH4 SH4A SH2A" for="row280">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	DRm,DRn</span>
<span>DRm → DRn</span>
<span id="1111nnn0mmm01100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">01100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers DRm contents to DRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = DR[m &gt;&gt; 1];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row281" />
<label class="summary SH4 SH4A" for="row281">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	DRm,XDn</span>
<span>DRm → XDn</span>
<span id="1111nnn1mmm01100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">01100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers DRm contents to XDn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_DRXD (int m, int n)
{
  XD[n &gt;&gt; 1] = DR[m &gt;&gt; 1];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row282" />
<label class="summary SH4 SH4A" for="row282">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	XDm,DRn</span>
<span>XDm → DRn</span>
<span id="1111nnn0mmm11100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">11100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers XDm contents to DRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_XDDR (int m, int n)
{
  DR[n &gt;&gt; 1] = XD[m &gt;&gt; 1];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row283" />
<label class="summary SH4 SH4A" for="row283">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	XDm,XDn</span>
<span>XDm → XDn</span>
<span id="1111nnn1mmm11100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">11100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers XDm contents to XDn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_XDXD (int m, int n)
{
  XD[n &gt;&gt; 1] = XD[m &gt;&gt; 1];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row284" />
<label class="summary SH4 SH4A SH2A" for="row284">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	@Rm,DRn</span>
<span>(Rm) → DRn</span>
<span id="1111nnn0mmmm1000" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var>0/4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers contents of memory at address indicated by Rm to DRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_LOAD_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row285" />
<label class="summary SH4 SH4A" for="row285">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	@Rm,XDn</span>
<span>(Rm) → XDn</span>
<span id="1111nnn1mmmm1000" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers contents of memory at address indicated by Rm to XDn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_LOAD_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row286" />
<label class="summary SH4 SH4A SH2A" for="row286">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	DRm,@Rn</span>
<span>DRm → (Rn)</span>
<span id="1111nnnnmmm01010" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">01010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers DRm contents to memory at address indicated by Rn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_STORE_DR (int m, int n)
{
  Write_64 (R[n], DR[m &gt;&gt; 1]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row287" />
<label class="summary SH4 SH4A" for="row287">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	XDm,@Rn</span>
<span>XDm → (Rn)</span>
<span id="1111nnnnmmm11010" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">11010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers contents of memory at address indicated by (R0 + Rm) to XDn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_STORE_XD (int m, int n)
{
  Write_64 (R[n], XD[m &gt;&gt; 1]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row288" />
<label class="summary SH4 SH4A SH2A" for="row288">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	@Rm+,DRn</span>
<span>(Rm) → DRn, Rm + 8 → Rm</span>
<span id="1111nnn0mmmm1001" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/2</var><var>1</var><var>1/4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers contents of memory at address indicated by Rm to DRn, and adds 8 to
Rm.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_RESTORE_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[m]);
  R[m] += 8;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row289" />
<label class="summary SH4 SH4A" for="row289">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	@Rm+,XDn</span>
<span>(Rm) → XDn, Rm+8 → Rm</span>
<span id="1111nnn1mmmm1001" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers contents of memory at address indicated by Rm to XDn, and adds 8 to
Rm.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_RESTORE_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[m]);
  R[m] += 8;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row290" />
<label class="summary SH4 SH4A SH2A" for="row290">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	DRm,@-Rn</span>
<span>Rn-8 → Rn, DRm → (Rn)</span>
<span id="1111nnnnmmm01011" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">01011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/1</var><var>1</var><var>0/1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts 8 from Rn, and transfers DRm contents to memory at address indicated
by resulting Rn value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_SAVE_DR (int m, int n)
{
  Write_64 (R[n] - 8, DR[m &gt;&gt; 1]);
  R[n] -= 8;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row291" />
<label class="summary SH4 SH4A" for="row291">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	XDm,@-Rn</span>
<span>Rn-8 → Rn, (Rn) → XDm</span>
<span id="1111nnnnmmm11011" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">11011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Subtracts 8 from Rn, and transfers XDm contents to memory at address indicated
by resulting Rn value.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_SAVE_XD (int m, int n)
{
  Write_64 (R[n] - 8, XD[m &gt;&gt; 1]);
  R[n] -= 8;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row292" />
<label class="summary SH4 SH4A SH2A" for="row292">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	@(R0,Rm),DRn</span>
<span>(R0 + Rm) → DRn</span>
<span id="1111nnn0mmmm0110" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var>0/4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers contents of memory at address indicated by (R0 + Rm) to DRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_LOAD_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row293" />
<label class="summary SH4 SH4A" for="row293">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	@(R0,Rm),XDn</span>
<span>(R0 + Rm) → XDn</span>
<span id="1111nnn1mmmm0110" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">1</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers contents of memory at address indicated by (R0 + Rm) to XDn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_LOAD_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row294" />
<label class="summary SH4 SH4A SH2A" for="row294">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	DRm,@(R0,Rn)</span>
<span>DRm → (R0 + Rn)</span>
<span id="1111nnnnmmm00111" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers DRm contents to memory at address indicated by (R0 + Rn).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_STORE_DR (int m, int n)
{
  Write_64 (R[0] + R[n], DR[m &gt;&gt; 1]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row295" />
<label class="summary SH4 SH4A" for="row295">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov	XDm,@(R0,Rn)</span>
<span>XDm → (R0 + Rn)</span>
<span id="1111nnnnmmm10111" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">10111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point Move Extension</span>
<br />
<br />Transfers XDm contents to memory at address indicated by (R0 + Rn).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_STORE_XD (int m, int n)
{
  Write_64 (R[0] + R[n], XD[m &gt;&gt; 1]);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row296" />
<label class="summary SH2A" for="row296">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.d	@(disp12,Rm),DRn</span>
<span>(disp × 8 + Rm) → DRn</span>
<span id="0011nnn0mmmm0001_0111dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span> <span title="Opcode Identifier">0111</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0/4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers memory contents at the address indicated by (disp + Rn) to DRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_DISP12_LOAD_DR (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  DR[n &gt;&gt; 1] = Read_64 (R[m] + (disp &lt;&lt; 3));
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row297" />
<label class="summary SH2A" for="row297">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.d	DRm,@(disp12,Rn)</span>
<span>DRm → (disp × 8 + Rn)</span>
<span id="0011nnnnmmm00001_0011dddddddddddd" class="colorized"><span title="Opcode Identifier">0011</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00001</span> <span title="Opcode Identifier">0011</span><span title="Displacement (12 bits)">dddddddddddd</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers DRm contents to memory at the address indicated by (disp + Rn).
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMOV_INDEX_DISP12_STORE_DR (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  Write_64 (R[n] + (disp &lt;&lt; 3), DR[m &gt;&gt; 1]);
  PC += 4;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<br/><br/><br/><b>Floating-Point Single-Precision Instructions (FPSCR.PR = 0)</b><br/><br/>
<input type="checkbox" id="row298" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row298">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fldi0	FRn</span>
<span>0x00000000 → FRn</span>
<span id="1111nnnn10001101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10001101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />When FPSCR.PR = 0, this instruction loads floating-point 0.0 (0x00000000) into
FRn.<br />
If FPSCR.PR = 1, the instruction is handled as an illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FLDI0 (int n)
{
  FR[n] = 0x00000000;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row299" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row299">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fldi1	FRn</span>
<span>0x3F800000 → FRn</span>
<span id="1111nnnn10011101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">10011101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />When FPSCR.PR = 0, this instruction loads floating-point 1.0 (0x3F800000) into
FRn.<br />
If FPCSR.PR = 1, the instruction is handled as an illegal instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FLDI1 (int n)
{
  FR[n] = 0x3F800000;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row300" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row300">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>flds	FRm,FPUL</span>
<span>FRm → FPUL</span>
<span id="1111mmmm00011101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00011101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the contents of floating-point register FRm into system register FPUL.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FLDS (int m)
{
  FPUL = FR[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row301" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row301">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsts	FPUL,FRn</span>
<span>FPUL → FRn</span>
<span id="1111nnnn00001101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00001101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the contents of system register FPUL to floating-point register FRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSTS (int n)
{
  FR[n] = FPUL;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row302" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row302">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fabs	FRn</span>
<span>FRn & 0x7FFFFFFF → FRn</span>
<span id="1111nnnn01011101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01011101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears the most significant bit of the contents of floating-point register FRn
to 0, and stores the result in FRn.
<br /><br />
<span title="section">Note</span>
<br />
<br />The cause and flag fields in FPSCR are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FABS (int n)
{
  FR[n] = FR[n] & 0x7FFFFFFFF;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row303" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row303">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fneg	FRn</span>
<span>FRn ^ 0x80000000 → FRn</span>
<span id="1111nnnn01001101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01001101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts the most significant bit (sign bit) of the contents of floating-point
register FRn, and stores the result in FRn.
<br /><br />
<span title="section">Note</span>
<br />
<br />The cause and flag fields in FPSCR are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FNEG (int n)
{
  FR[n] = -FR[n];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row304" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row304">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fadd	FRm,FRn</span>
<span>FRn + FRm → FRn</span>
<span id="1111nnnnmmmm0000" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3/4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically adds the two single-precision floating-point numbers in FRn and
FRm, and stores the result in FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fadd.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FADD (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, ADD);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        break;
      default:
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case NZERO:
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;

     case NINF:
       switch (data_type_of (n))
       {
       case PINF:
         invalid (n);
         break;
       default:
         inf (n, 1);
         break;
       }
       break;
    }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have the same sign and the exponent of at least one value is 0xFE</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have different signs and neither has an exponent greater than 0x18</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row305" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row305">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsub	FRm,FRn</span>
<span>FRn - FRm → FRn</span>
<span id="1111nnnnmmmm0001" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3/4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically subtracts the single-precision floating-point number in FRm from
the single-precision floating-point number in FRn, and stores the result in FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fsub.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSUB (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, SUB);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        FR[n] = -FR[n];
        break;
      default:
        break;
      }
      break;

    case PZERO:
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case PINF:
        invalid (n);
        break;
      default:
        inf (n, 1);
        break;
      }
      break;

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;
    }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have the same sign and the exponent of at least one value is 0xFE</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have different signs and neither has an exponent greater than 0x18</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row306" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row306">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmul	FRm,FRn</span>
<span>FRn × FRm → FRn</span>
<span id="1111nnnnmmmm0010" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3/4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically multiplies the two single-precision floating-point numbers in
FRn and FRm, and stores the result in FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fmul.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMUL (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      default:
        normal_fmul (m, n);
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n,sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      default:
        inf (n, sign_of (m) ^ sign_of (n));
        break
      }
      break;
    }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of FRn) + (exponent of FRm) - 0x7F is not less than 0xFE</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>When both FRn and FRm are normalized numbers:</var>
  <var>(exponent of FRn) + (exponent of FRm) - 0x7F is not more than 0x00</var>
  <var><br /></var>
  <var>When at least FRn or FRm is not a normalized number:</var>
  <var>(exponent of FRn) + (exponent of FRm) - 0x7F is not more than 0x18</var>
  <var>
</var>
  <var>Inexact</var>
  <var></var>
</span>
</span>
</label>
<input type="checkbox" id="row307" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row307">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmac	FR0,FRm,FRn</span>
<span>FR0 × FRm + FRn → FRn</span>
<span id="1111nnnnmmmm1110" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">1110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3/4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically multiplies the two single-precision floating-point numbers in
FR0 and FRm, arithmetically adds the contents of FRn, and stores the result in
FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fmac.svg" height="942" />
<br /><br />
<span title="section">Note</span>
<br />
<br />SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
This instruction rounds only the final result and does not round the
intermediate result of the multiplication.  Thus, for IEEE 754 compliant code,
this instruction cannot be used as a replacement for individual FADD and FMUL
instructions.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMAC (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (FPSCR_PR == 1)
    undefined_operation ();

  else if (data_type_of (0) == sNaN
           || data_type_of (m) == sNaN
           || data_type_of (n) == sNaN)
    invalid (n);

  else if (data_type_of (0) == qNaN || data_type_of (m) == qNaN)
    qnan (n);

  else if (data_type_of (0) == DENORM || data_type_of (m) == DENORM)
    set_E ();

  else
    switch (data_type_of (0))
    {
    case NORM:
      switch (data_type_of (m))
      {
      case PZERO:
      case NZERO:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PZERO:
        case NZERO:
          zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
          break;
        default:
          break;
        }

      case PINF:
      case NINF:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PINF:
        case NINF:
          if (sign_of (0) ^ sign_of (m) ^ sign_of (n))
            invalid (n);
          else
            inf (n, sign_of (0) ^ sign_of (m));
          break;
        default:
          inf (n, sign_of (0) ^ sign_of (m));
          break;
        }

      case NORM:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PINF:
        case NINF:
          inf (n, sign_of (n));
          break;
        case PZERO:
        case NZERO:
        case NORM:
          normal_fmac (m, n);
          break;
        }
        break;

      case PZERO:
      case NZERO:
        switch (data_type_of (m))
        {
        case PINF:
        case NINF:
          invalid (n);
          break;
        case PZERO:
        case NZERO:
        case NORM:
          switch (data_type_of (n))
          {
          case DENORM:
            set_E ();
            break;
          case qNaN:
            qnan (n);
            break;
          case PZERO:
          case NZERO:
            zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
            break;
          default:
            break;
          }
          break;
        }
        break;

      case PINF:
      case NINF:
        switch (data_type_of (m))
        {
        case PZERO:
        case NZERO:
          invalid (n);
          break;
        default:
          switch (data_type_of (n))
          {
          case DENORM:
            set_E ();
            break;
          case qNaN:
            qnan(n);
            break;
          default:
            inf (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
            break
          }
          break;
        }
        break;
      }
    }
}

void normal_fmac (int m, int n)
{
  union
  {
    int double x;
    int l[4];
  } dstx, tmpx;

  float dstf, srcf;

  if (data_type_of (n) == PZERO || data_type_of (n) == NZERO)
    srcf = 0.0; // flush denormalized value
  else
    srcf = FR[n];

  tmpx.x = FR[0]; // convert single to int double
  tmpx.x *= FR[m]; //exact product
  dstx.x = tmpx.x + srcf;

  if ((dstx.x == srcf && tmpx.x != 0.0)
      || (dstx.x == tmpx.x && srcf != 0.0))
  {
    set_I ();
    if (sign_of (0) ^ sign_of (m) ^ sign_of (n))
    {
      dstx.l[3] -= 1; // correct result
      if (dstx.l[3] == 0xFFFFFFFF)
        dstx.l[2] -= 1;
      if (dstx.l[2] == 0xFFFFFFFF)
        dstx.l[1] -= 1;
      if (dstx.l[1] == 0xFFFFFFFF)
        dstx.l[0] -= 1;
    }
    else
      dstx.l[3] |= 1
  }

  if ((dstx.l[1] & 0x01FFFFFF) || dstx.l[2] || dstx.l[3])
    set_I();

  if(FPSCR_RM == 1)
  {
    dstx.l[1] &= 0xFE000000; // round toward zero
    dstx.l[2] = 0x00000000;
    dstx.l[3] = 0x00000000;
  }

  dstf = dstx.x;
  check_single_exception (&FR[n], dstf);
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>At least one of the following results is not less than 0xFD:</var>
  <var><br /></var>
  <var>(exponent of FR0) + (exponent of FRm)</var>
  <var><br /></var>
  <var>(exponent of FRn)</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>At least one of the following results is not more than 0x2E:</var>
  <var><br /></var>
  <var>(exponent of FR0) + (exponent of FRm)</var>
  <var><br /></var>
  <var>(exponent of FRn)</var>
  <var>
</var>
  <var>Inexact</var>
  <var></var>
</span>
</span>
</label>
<input type="checkbox" id="row308" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row308">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fdiv	FRm,FRn</span>
<span>FRn / FRm → FRn</span>
<span id="1111nnnnmmmm0011" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>13</var><var></var><var>13</var><var></var><var>12/13</var><var>14</var><var>12</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically divides the single-precision floating-point number in FRn by the
single-precision floating-point number in FRm, and stores the result in FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fdiv.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FDIV (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case DENORM:
        set_E ();
        break;
      default:
        normal_fdiv_single (m, n);
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
      case NINF:
        break;
      default:
        dz (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
        inf (n, 1);
        break;
      case NINF:
        inf (n, 0);
        break;
      default:
        dz (FR[n], sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case DENORM:
      set_E ();
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case DENORM:
        set_E ();
        break;
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;
    }
}

void normal_fdiv_single (int m, int n)
{
  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } tmpd;

  tmpf.f = FR[n];   // save destination value
  dstf.f /= FR[m];  // round toward nearest or even
  tmpd.d = dstf.f;  // convert single to double
  tmpd.d *= FR[m];

  if (tmpf.f != tmpd.d)
    set_I ();
  if (tmpf.f &lt; tmpd.d && FPSCR_RM == 1)
    dstf.l -= 1; // round toward zero

  check_single_exception (&FR[n], dstf.f);
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Division by zero</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of FRn) - (exponent of FRm) + 0x7F is not less than 0xFF</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of FRn) - (exponent of FRm) + 0x7F is not more than 0x01</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row309" />
<label class="summary SH3E" for="row309">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsqrt	FRn</span>
<span>sqrt (FRn) → FRn</span>
<span id="1111nnnn01101101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01101101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>13</var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds the arithmetical square root of the single-precision floating-point number
in FRn, and stores the result in FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in FPSCR.cause and FPSCR.flag and FRn is not
updated. Appropriate processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fsqrt.svg" height="128" />
<br /><br />
<span title="section">Note</span>
<br />
<br />SH3E supports only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSQRT (int n)
{
  PC += 2;
  clear_cause ();

  switch (data_type_of (n))
  {
  case NORM:
    if (sign_of (n) == 0)
      normal_fsqrt_single (n);
    else
      invalid (n);
    break;

  case DENORM:
    if (sign_of (n) == 0)
      set_E ();
    else
      invalid (n);
    break;

  case PZERO:
  case NZERO:
  case PINF:
    break;

  case NINF:
    invalid (n);
    break;

  case qNAN:
    qnan (n);
    break;

  case sNAN:
    invalid (n);
    break;
  }
}

void normal_fsqrt_single (int n)
{
  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } tmpd;

  tmpf.f = FR[n];         // save destination value
  dstf.f = sqrt (FR[n]);  // round toward nearest or even
  tmpd.d = dstf.f;        // convert single to double
  tmpd.d *= dstf.f;

  if (tmpf.f != tmpd.d)
    set_I ();
  if (tmpf.f &lt; tmpd.d && FPSCR_RM == 1)
    dstf.l -= 1;  // round toward zero
  if (FPSCR & ENABLE_I)
    fpu_exception_trap ();
  else
    FR[n] = dstf.f;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row310" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row310">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/eq	FRm,FRn</span>
<span>If FRn = FRm: 1 → T
Else: 0 → T</span>
<span id="1111nnnnmmmm0100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0100</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>2/4</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically compares the two single-precision floating-point numbers in FRn
and FRm, and stores 1 in the T bit if they are equal, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fcmpeq.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />Special Cases:
When FPSCR.DN is 1, a positive denormalized number is treated as +0 and a
negative denormalized number as -0. This flush-to-zero treatment is applied before
exception detection and special case handling.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FCMP_EQ (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_single (m, n) == INVALID)
    fcmp_invalid ();
  else if (fcmp_chk_single (m, n) == EQ)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_single (int m, int n)
{
  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    return INVALID;
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    return UO;
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
        return GT;
      case NINF:
        return LT;
      default:
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        return EQ;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
        case PINF:
          return EQ;
        default:
          return LT;
      }

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        return EQ;
      default:
        return GT;
      }
    }

  if (FR[n] == FR[m])
    return EQ;
  else if (FR[n] &gt; FR[m])
    return GT;
  else
    return LT;
}

void fcmp_invalid (void)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
    T = 0;
  else
    fpu_exception_trap ();
}

</span>
</span>
</label>
<input type="checkbox" id="row311" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row311">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/gt	FRm,FRn</span>
<span>If FRn &gt; FRm: 1 → T
Else: 0 → T</span>
<span id="1111nnnnmmmm0101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">0101</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>2/4</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically compares the two single-precision floating-point numbers in FRn
and FRm, and stores 1 in the T bit if FRn > FRm, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fcmpgt.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />For IEEE 754 conform less-than-or-equal comparison it is not sufficient to swap
the operands.  The FCMP/EQ must be used as well.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FCMP_GT (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_single (m, n) == INVALID || fcmp_chk_single (m, n) == UO)
    fcmp_invalid ();
  else if (fcmp_chk_single (m, n) == GT)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_single (int m, int n)
{
  // see description of FCMP/EQ instruction.
}

void fcmp_invalid (void)
{
  // see description of FCMP/EQ instruction.
}

</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input type="checkbox" id="row312" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row312">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>float	FPUL,FRn</span>
<span>(float)FPUL → FRn</span>
<span id="1111nnnn00101101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">00101101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3/4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Taking the contents of FPUL as a 32-bit integer, converts this integer to a
single-precision floating-point number and stores the result in FRn.
<br /><br />
When FPSCR.enable.I = 1 an FPU exception trap is generated regardless of whether
or not an exception has occurred. When an exception occurs, correct exception
information is reflected in FPSCR.cause and FPSCR.flag, and FRn is not updated.
Appropriate processing should therefore be performed by software.
<br /><br />
<span title="section">Note</span>
<br />
<br />SH2E and SH3E support only invalid operation (V) and division by zero
(Z) exception flags.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FLOAT_single (int n)
{
  union
  {
    double d;
    int l[2];
  } tmp;

  PC += 2;
  clear_cause ();

  FR[n] = FPUL; // convert from integer to float
  tmp.d = FPUL;
  if (tmp.l[1] & 0x1FFFFFFF)
    inexact();
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row313" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row313">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ftrc	FRm,FPUL</span>
<span>(long)FRm → FPUL</span>
<span id="1111mmmm00111101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">00111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3/4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Converts the single-precision floating-point number in FRm to a 32-bit integer,
and stores the result in FPUL.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="ftrc.svg" height="128" />
<br /><br />
<span title="section">Note</span>
<br />
<br />The rounding mode is always truncation.

The original SH4 has a pipeline exception.  If the FTRC instruction is followed
by an STS FPUL, Rn instruction, the latency of the FTRC instruction is reduced
to 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">#define NEG_INT_SINGLE_RANGE 0xCF000000 & 0x7FFFFFFF // -1.000000 * 2^31
#define POS_INT_SINGLE_RANGE 0x4EFFFFFF              // 1.FFFFFE * 2^30

void FTRC_single (int m)
{
  PC += 2;
  clear_cause ();

  switch (ftrc_single_type_of (m))
  {
    case NORM:
      FPUL = FR[m];  // Convert float to integer
      break;
    case PINF:
      ftrc_invalid (0, &FPUL);
      break;
    case NINF:
      ftrc_invalid (1, &FPUL);
      break;
  }
}

int ftrc_single_type_of (int m)
{
  if (sign_of (m) == 0)
  {
    if (FR_HEX[m] &gt; 0x7F800000)
      return NINF;  // NaN
    else if (FR_HEX[m] &gt; POS_INT_SINGLE_RANGE)
      return PINF;  // out of range, +INF
    else
      return NORM;  // +0, +NORM
  }
  else
  {
    if ((FR_HEX[m] & 0x7FFFFFFF) &gt; NEG_INT_SINGLE_RANGE)
      return NINF;  // out of range, +INF, NaN
    else
      return NORM;  // -0, -NORM
  }
}

void ftrc_invalid (int sign, int* result)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
  {
    if (sign == 0)
      *result = 0x7FFFFFFF;
    else
      *result = 0x80000000;
  }
  else
    fpu_exception_trap ();
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input type="checkbox" id="row314" />
<label class="summary SH4 SH4A" for="row314">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fipr	FVm,FVn</span>
<span>inner_product (FVm, FVn) → FR[n+3]</span>
<span id="1111nnmm11101101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R3)">nn</span><span title="Source Register (R0 - R3)">mm</span><span title="Opcode Identifier">11101101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>4/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Calculates the inner products of the 4-dimensional single-precision
floating-point vector indicated by FVn and FVm, and stores the results in
FR[n + 3].
<br /><br />
The FIPR instruction is intended for speed rather than accuracy, and therefore
the results will differ from those obtained by using a combination of FADD and
FMUL instructions. The FIPR execution sequence is as follows:
<ol type="1">
 Multiplies all terms.  The results are 28 bits long.
 Aligns these results, rounding them to fit within 30 bits.
 Adds the aligned values.
 Performs normalization and rounding.
</ol>

Special processing is performed in the following cases:
<ol type="1">
If an input value is an sNaN, an invalid exception is generated.

If the input values to be multiplied include a combination of 0 and
infinity, an invalid exception is generated.

In cases other than the above, if the input values include a qNaN, the
result will be a qNaN.

In cases other than the above, if the input values include infinity:
  <ol type="a">
  If multiplication results in two or more infinities and the signs are
  different, an invalid exception will be generated.
  Otherwise, correct infinities will be stored.
  </ol>

If the input values do not include an sNaN, qNaN, or infinity, processing
is performed in the normal way.
</ol>
When FPSCR.enable.U/I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag, and FR[n+3] is not updated. Appropriate
processing should therefore be performed by software.
<br /><br />
<span title="section">Note</span>
<br />
<br />FV0 = { FR0, FR1, FR2, FR3 }<br />
FV4 = { FR4, FR5, FR6, FR7 }<br />
FV8 = { FR8, FR9, FR10, FR11 }<br />
FV12 = { FR12, FR13, FR14, FR15 }<br />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FIPR (int m, int n)
{
  if (FPSCR_PR == 0)
  {
    PC += 2;
    clear_cause ();
    fipr (m,n);
  }
  else
    undefined_operation ();
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow exception traps</var>
  <var><br /></var>
  <var>At least one of the following results is not less than 0xFC</var>
  <var><br /></var>
  <var>(exponent of FRn) + (exponent of FRm)<br /></var>
  <var>(exponent of FR(n + 1)) + (exponent of FR(m + 1))<br /></var>
  <var>(exponent of FR(n + 2)) + (exponent of FR(m + 2))<br /></var>
  <var>(exponent of FR(n + 3)) + (exponent of FR(m + 3))<br /></var>
  <var>
Underflow</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row315" />
<label class="summary SH4 SH4A" for="row315">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ftrv	XMTRX,FVn</span>
<span>transform_vector (XMTRX, FVn) → FVn</span>
<span id="1111nn0111111101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R3)">nn</span><span title="Opcode Identifier">0111111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>5/8</var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Takes the contents of floating-point registers XF0 to XF15 indicated by XMTRX
as a 4-row &times 4-column matrix, takes the contents of floating-point
registers FR[n] to FR[n + 3] indicated by FVn as a 4-dimensional vector,
multiplies the array by the vector, and stores the results in FV[n].

<br /><img alt="" class="image_filter" src="ftrv.svg" height="128" /><br />

The FTRV instruction is intended for speed rather than accuracy, and therefore
the results will differ from those obtained by using a combination of FADD and
FMUL instructions. The FTRV execution sequence is as follows:
<ol type="1">
Multiplies all terms. The results are 28 bits long.
Aligns these results, rounding them to fit within 30 bits.
Adds the aligned values.
Performs normalization and rounding.
</ol>

Special processing is performed in the following cases:
<ol type="1">
If an input value is an sNaN, an invalid exception is generated.

If the input values to be multiplied include a combination of 0 and
infinity, an invalid operation exception is generated.

In cases other than the above, if the input values include a qNaN, the
result will be a qNaN.

In cases other than the above, if the input values include infinity:
  <ol type="a">
  If multiplication results in two or more infinities and the signs are
  different, an invalid exception will be generated.

  Otherwise, correct infinities will be stored.
  </ol>


If the input values do not include an sNaN, qNaN, or infinity, processing
is performed in the normal way.

</ol>

When FPSCR.enable.V/O/U/I is set, an FPU exception trap is generated regardless
of whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in FPSCR.cause and FPSCR.flag, and FVn is not
updated. Appropriate processing should therefore be performed by software.
<br /><br />
<span title="section">Note</span>
<br />
<br />A 4-dimensional matrix &times matrix transformation can be realized by four FTRV
instructions, where every FTRV calculates a column of the result matrix.  The
resulting matrix can be set to the XMTRX registers by toggling the FPSCR.FR bit
to switch register banks without copying them.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FTRV (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    float saved_vec[4];
    float result_vec[4];
    int saved_fpscr;
    int dst;

    PC += 2;
    clear_cause ();

    saved_fpscr = FPSCR;
    FPSCR &= ~ENABLE_VOUI;  // mask VOUI enable
    dst = 12 - n;           // select other vector than FVn

    for (int i = 0; i &lt; 4; i++)
      saved_vec[i] = FR[dst+i];

    for (int i = 0; i &lt; 4; i++)
    {
      for (int j = 0; j &lt; 4; j++)
        FR[dst+j] = XF[i+4j];

      fipr (n, dst);
      saved_fpscr |= FPSCR & (CAUSE | FLAG);
      result_vec[i] = FR[dst+3];
    }

    for (int i = 0; i &lt; 4; i++)
      FR[dst+i] = saved_vec[i];

    FPSCR = saved_fpscr;

    if (FPSCR & ENABLE_VOUI)
      fpu_exception_trap();
    else
      for (int i = 0; i &lt; 4; i++)
        FR[n+i] = result_vec[i];
  }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
  <var>Overflow</var>
  <var>Underflow</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row316" />
<label class="summary SH4A" for="row316">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsrra	FRn</span>
<span>1.0 / sqrt (FRn) → FRn</span>
<span id="1111nnnn01111101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Takes the approximate inverse of the arithmetic square root (absolute error is
within &plusmn;2<sup>-21</sup>) of the single-precision floating-point in FRn
and writes the result to FRn. Since the this instruction operates by
approximation, an imprecision exception is required when the input is a
normalized value. In other cases, the instruction does not require an
imprecision exception.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated. When an
exception occurs, correct exception information is reflected in FPSCR.cause and
FPSCR.flag, and FRn is not updated. Appropriate processing should therefore be
performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fsrra.svg" height="128" />
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction is also supported by the SH4 variant SH7091.  Other SH4
variants such as SH7751, SH7760, SH7761 might also support it.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSRRA (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    PC += 2;
    clear_cause();

    switch (data_type_of (n))
    {
    case NORM:
      if (sign_of (n) == 0)
      {
        set_I ();
        FR[n] = 1 / sqrt (FR[n]);
      }
      else
        invalid (n);
      break;

    case DENORM:
      if (sign_of (n) == 0)
        fpu_error ();
      else
        invalid (n);
      break;

    case PZERO:
    case NZERO:
      dz (n, sign_of (n));
      break;

    case PINF:
      FR[n] = 0;
      break;

    case NINF:
      invalid (n);
      break;

    case qNAN:
      qnan (n);
      break;

    case sNAN:
      invalid (n);
      break;
    }
  }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU error</var>
  <var>Invalid operation</var>
  <var>Division by zero</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row317" />
<label class="summary SH4A" for="row317">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsca	FPUL,DRn</span>
<span>sin (FPUL) → FRn
cos (FPUL) → FR[n+1]</span>
<span id="1111nnn011111101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">011111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Calculates the sine and cosine approximations of FPUL (absolute error is
within &plusmn;2<sup>-21</sup>) as single-precision floating point values, and
places the values of the sine and cosine in FRn and FR[n + 1], respectively.
Since this instruction is an approximate operation instruction, an imprecision
exception is always required (even if the input is a 0, the result is
imprecise).
<br /><br />
The input angle is specified as a signed fraction in twos complement.  The
result of sin and cos is a single-precision floating-point number.
<br />
0x7FFFFFFF to 0x00000001:
360&times;2<sup>15</sup>&minus;360/2<sup>16</sup> to 360/2<sup>16</sup> degrees
<br />
0x00000000: 0 degree
<br />
0xFFFFFFFF to 0x80000000:
&minus;360/2<sup>16</sup> to &minus;360&times2<sup>15</sup> degrees
<br /><br />
<span title="section">Note</span>
<br />
<br />This instruction is also supported by the SH4 variant SH7091.  Other SH4
variants such as SH7751, SH7760, SH7761 might also support it.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSCA (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    float angle;
    long offset = 0x00010000;
    long fraction = 0x0000FFFF;

    set_I ();
    fraction &= FPUL;  // extract sub-rotation (fraction) part
    angle = fraction;  // convert to float
    angle = 2 * M_PI * angle / offset;  // convert to radian
    FR[n] = sin (angle);
    FR[n+1] = cos (angle);
    PC += 2;
  }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Inexact</var>
</span>
</span>
</label>
<br/><br/><br/><b>Floating-Point Double-Precision Instructions (FPSCR.PR = 1)</b><br/><br/>
<input type="checkbox" id="row318" />
<label class="summary SH4 SH4A SH2A" for="row318">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fabs	DRn</span>
<span>DRn & 0x7FFFFFFFFFFFFFFF → DRn</span>
<span id="1111nnn001011101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">001011101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears the most significant bit of the contents of floating-point register DRn
to 0, and stores the result in DRn.
<br /><br />
<span title="section">Note</span>
<br />
<br />The cause and flag fields in FPSCR are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FABS (int n)
{
  FR[n] = FR[n] & 0x7FFFFFFFF;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row319" />
<label class="summary SH4 SH4A SH2A" for="row319">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fneg	DRn</span>
<span>DRn ^ 0x8000000000000000 → DRn</span>
<span id="1111nnn001001101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">001001101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var>0</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts the most significant bit (sign bit) of the contents of floating-point
register DRn, and stores the result in DRn.
<br /><br />
<span title="section">Note</span>
<br />
<br />The cause and flag fields in FPSCR are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.PR setting before this instruction.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FNEG (int n)
{
  FR[n] = -FR[n];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row320" />
<label class="summary SH4 SH4A SH2A" for="row320">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fadd	DRm,DRn</span>
<span>DRn + DRm → DRn</span>
<span id="1111nnn0mmm00000" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>7/9</var><var>1</var><var>0/8</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically adds the two double-precision floating-point numbers in DRn and
DRm, and stores the result in DRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fadd.svg" height="300" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FADD (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, ADD);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        break;
      default:
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case NZERO:
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;

     case NINF:
       switch (data_type_of (n))
       {
       case PINF:
         invalid (n);
         break;
       default:
         inf (n, 1);
         break;
       }
       break;
    }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have the same sign and the exponent of at least one value is 0x7FE</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have different signs and neither has an exponent greater than 0x035</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row321" />
<label class="summary SH4 SH4A SH2A" for="row321">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsub	DRm,DRn</span>
<span>DRn - DRm → DRn</span>
<span id="1111nnn0mmm00001" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>7/9</var><var>1</var><var>0/8</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically subtracts the double-precision floating-point number in DRm from
the double-precision floating-point number in DRn, and stores the result in DRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fsub.svg" height="300" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSUB (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, SUB);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        FR[n] = -FR[n];
        break;
      default:
        break;
      }
      break;

    case PZERO:
      break;
      case NZERO:
        switch (data_type_of (n))
        {
        case NZERO:
          zero (n, 0);
          break;
        default:
          break;
        }
        break;

    case PINF:
      switch (data_type_of (n))
      {
      case PINF:
        invalid (n);
        break;
      default:
        inf (n, 1);
        break;
      }
      break;

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;
    }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have the same sign and the exponent of at least one value is 0x7FE</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have different signs and neither has an exponent greater than 0x035</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row322" />
<label class="summary SH4 SH4A SH2A" for="row322">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmul	DRm,DRn</span>
<span>DRn × DRm → DRn</span>
<span id="1111nnn0mmm00010" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>7/9</var><var>3</var><var>0/8</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically multiplies the two double-precision floating-point numbers in
DRn and DRm, and stores the result in FRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fmuld.svg" height="300" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FMUL (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      default:
        normal_fmul (m, n);
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n,sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      default:
        inf (n, sign_of (m) ^ sign_of (n));
        break
      }
      break;
    }
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>
Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) + (exponent of DRm) - 0x3FF is not less than 0x7FE</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) + (exponent of DRm) - 0x3FF is not more than 0x000</var>
  <var>
</var>
  <var>Inexact</var>
  <var></var>
</span>
</span>
</label>
<input type="checkbox" id="row323" />
<label class="summary SH4 SH4A SH2A" for="row323">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fdiv	DRm,DRn</span>
<span>DRn / DRm → DRn</span>
<span id="1111nnn0mmm00011" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>24/26</var><var>14</var><var>0/24</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically divides the double-precision floating-point number in DRn by the
double-precision floating-point number in DRm, and stores the result in DRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fdiv.svg" height="300" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FDIV (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case DENORM:
        set_E ();
        break;
      default:
        normal_fdiv_double (m, n);
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
      case NINF:
        break;
      default:
        dz (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
        inf (n, 1);
        break;
      case NINF:
        inf (n, 0);
        break;
      default:
        dz (FR[n], sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case DENORM:
      set_E ();
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case DENORM:
        set_E ();
        break;
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;
    }
}

void normal_fdiv_double (int m, int n)
{
  union
  {
    double d;
    int l[2];
  } dstd, tmpd;

  union
  {
    int double x;
    int l[4];
  } tmpx;

  tmpd.d = DR[n &gt;&gt; 1];   // save destination value
  dstd.d /= DR[m &gt;&gt; 1];  // round toward nearest or even
  tmpx.x = dstd.d;       // convert double to int double
  tmpx.x *= DR[m &gt;&gt; 1];

  if (tmpd.d != tmpx.x)
    set_I ();
  if (tmpd.d &lt; tmpx.x && FPSCR_RM == 1)
  {
    dstd.l[1] -= 1;  // round toward zero
    if (dstd.l[1] == 0xFFFFFFFF)
      dstd.l[0] -= 1;
  }

  check_double_exception (&DR[n &gt;&gt; 1], dstd.d);
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Division by zero</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) - (exponent of DRm) + 0x3FF is not less than 0x7FF</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) - (exponent of DRm) + 0x3FF is not more than 0x001</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row324" />
<label class="summary SH4 SH4A SH2A" for="row324">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsqrt	DRn</span>
<span>sqrt (DRn) → DRn</span>
<span id="1111nnn001101101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">001101101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>23/25</var><var>30</var><var>0/24</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds the arithmetical square root of the double-precision floating-point number
in DRn, and stores the result in DRn.
<br /><br />
When FPSCR.enable.I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in FPSCR.cause and FPSCR.flag and DRn is not
updated. Appropriate processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fsqrt.svg" height="128" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSQRT (int n)
{
  PC += 2;
  clear_cause ();

  switch (data_type_of (n))
  {
  case NORM:
    if (sign_of (n) == 0)
      normal_fsqrt_double (n);
    else
      invalid (n);
    break;

  case DENORM:
    if (sign_of (n) == 0)
      set_E ();
    else
      invalid (n);
    break;

  case PZERO:
  case NZERO:
  case PINF:
    break;

  case NINF:
    invalid (n);
    break;

  case qNAN:
    qnan (n);
    break;

  case sNAN:
    invalid (n);
    break;
  }
}

void normal_fsqrt_double (int n)
{
  union
  {
    double d;
    int l[2];
  } dstd, tmpd;

  union
  {
    int double x;
    int l[4];
  } tmpx;

  tmpd.d = DR[n &gt;&gt; 1];         // save destination value
  dstd.d = sqrt (DR[n &gt;&gt; 1]);  // round toward nearest or even
  tmpx.x = dstd.d;             // convert double to int double
  tmpx.x *= dstd.d;

  if (tmpd.d != tmpx.x)
    set_I ();
  if (tmpd.d &lt; tmpx.x && FPSCR_RM == 1)
  {
    dstd.l[1] -= 1;  // round toward zero
    if (dstd.l[1] == 0xFFFFFFFF)
      dstd.l[0] -= 1;
  }
  if (FPSCR & ENABLE_I)
    fpu_exception_trap();
  else
    DR[n &gt;&gt; 1] = dstd.d;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row325" />
<label class="summary SH4 SH4A SH2A" for="row325">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/eq	DRm,DRn</span>
<span>If DRn = DRm: 1 → T
Else: 0 → T</span>
<span id="1111nnn0mmm00100" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00100</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3/5</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically compares the two double-precision floating-point numbers in DRn
and DRm, and stores 1 in the T bit if they are equal, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fcmpeq.svg" height="300" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FCMP_EQ (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_double (m, n) == INVALID)
    fcmp_invalid ();
  else if (fcmp_chk_double (m, n) == EQ)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_double (int m, int n)
{
  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    return INVALID;
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    return UO;
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
        return GT;
      case NINF:
        return LT;
      default:
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        return EQ;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
        case PINF:
          return EQ;
        default:
          return LT;
      }

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        return EQ;
      default:
        return GT;
      }
    }

  if (DR[n &gt;&gt; 1] == DR[m &gt;&gt; 1])
    return EQ;
  else if (DR[n &gt;&gt; 1] &gt; DR[m &gt;&gt; 1])
    return GT;
  else
    return LT;
}

void fcmp_invalid (void)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
    T = 0;
  else
    fpu_exception_trap ();
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input type="checkbox" id="row326" />
<label class="summary SH4 SH4A SH2A" for="row326">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/gt	DRm,DRn</span>
<span>If DRn &gt; DRm: 1 → T
Else: 0 → T</span>
<span id="1111nnn0mmm00101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">0</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">00101</span></span>
<span>Result → T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var>2</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3/5</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically compares the two double-precision floating-point numbers in DRn
and DRm, and stores 1 in the T bit if DRn > DRm, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fcmpgt.svg" height="300" />
<br /><br />
<span title="section">Note</span>
<br />
<br />For IEEE 754 conform less-than-or-equal comparison it is not sufficient to swap
the operands.  The FCMP/EQ must be used as well.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FCMP_GT (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_double (m, n) == INVALID || fcmp_chk_double (m, n) == UO)
    fcmp_invalid ();
  else if (fcmp_chk_double (m, n) == GT)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_double (int m, int n)
{
  // see description of FCMP/EQ instruction.
}

void fcmp_invalid (void)
{
  // see description of FCMP/EQ instruction.
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input type="checkbox" id="row327" />
<label class="summary SH4 SH4A SH2A" for="row327">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>float	FPUL,DRn</span>
<span>(double)FPUL → DRn</span>
<span id="1111nnn000101101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">000101101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3/5</var><var>1</var><var>0/4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Taking the contents of FPUL as a 32-bit integer, converts this integer to a
double-precision floating-point number and stores the result in DRn.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FLOAT_double (int n)
{
  union
  {
    double d;
    int l[2];
  } tmp;

  PC += 2;
  clear_cause ();

  DR[n &gt;&gt; 1] = FPUL; // convert from integer to double
}
</span>
</span>
</label>
<input type="checkbox" id="row328" />
<label class="summary SH4 SH4A SH2A" for="row328">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ftrc	DRm,FPUL</span>
<span>(long)DRm → FPUL</span>
<span id="1111mmm000111101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">000111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>4/5</var><var>1</var><var>0/4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Converts the double-precision floating-point number in DRm to a 32-bit integer,
and stores the result in FPUL.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="ftrc.svg" height="128" />
<br /><br />
<span title="section">Note</span>
<br />
<br />The rounding mode is always truncation.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">#define NEG_INT_DOUBLE_RANGE 0xC1E0000000200000 & 0x7FFFFFFFFFFFFFFF
#define POS_INT_DOUBLE_RANGE 0x41E0000000000000

void FTRC_double (int m)
{
  PC += 2;
  clear_cause ();

  switch (ftrc_double_type_of (m))
  {
    case NORM:
      FPUL = DR[m &gt;&gt; 1];  // Convert double to integer
      break;
    case PINF:
      ftrc_invalid (0, &FPUL);
      break;
    case NINF:
      ftrc_invalid (1, &FPUL);
      break;
  }
}

int ftrc_double_type_of (int m)
{
  if (sign_of (m) == 0)
  {
    if (FR_HEX[m] &gt; 0x7FF00000
        || (FR_HEX[m] == 0x7FF00000 && FR_HEX[m+1] != 0x00000000))
      return NINF;  // NaN
    else if (DR_HEX[m &gt;&gt; 1] &gt;= POS_INT_DOUBLE_RANGE)
      return PINF;  // out of range, +INF
    else
      return NORM;  // +0, +NORM
  }
  else
  {
    if ((DR_HEX[m &gt;&gt; 1] & 0x7FFFFFFFFFFFFFFF) &gt;= NEG_INT_DOUBLE_RANGE)
      return NINF;  // out of range, +INF, NaN
    else
      return NORM;  // -0, -NORM
  }
}

void ftrc_invalid (int sign, int* result)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
  {
    if (sign == 0)
      *result = 0x7FFFFFFF;
    else
      *result = 0x80000000;
  }
  else
    fpu_exception_trap ();
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input type="checkbox" id="row329" />
<label class="summary SH4 SH4A SH2A" for="row329">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcnvds	DRm,FPUL</span>
<span>double_to_float (DRm) → FPUL</span>
<span id="1111mmm010111101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Source Register (R0 - R7)">mmm</span><span title="Opcode Identifier">010111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>4/5</var><var>1</var><var>4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Converts the double-precision floating-point number in DRm to a single-precision
floating-point number, and stores the result in FPUL.
<br /><br />
When FPSCR.enable. I is set, an FPU exception trap is generated regardless of
whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU
exception traps are generated on actual generation by the FPU exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in FPSCR.cause and FPSCR.flag, and FPUL is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fcnvds.svg" height="128" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FCNVDS (int m)
{
  if (FPSCR_PR != 1)
    undefined_operation ();
  else
  {
    PC += 2;
    clear_cause ();

    switch (data_type_of (m))
    {
    case NORM:
    case PZERO:
    case NZERO:
      normal_fcnvds (m, &FPUL);
      break;

    case DENORM:
      set_E ();

    case PINF:
      FPUL = 0x7F800000;
      break;

    case NINF:
      FPUL = 0xFF800000;
      break;

    case qNaN:
      FPUL = 0x7FBFFFFF;
      break;

    case sNaN:
      set_V ();
      if ((FPSCR & ENABLE_V) == 0)
        FPUL = 0x7FBFFFFF;
      else
        fpu_exception_trap ();
      break;
    }
  }
}

void normal_fcnvds (int m, float* result)
{
  int sign;
  float abs;

  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } dstd;

  dstd.d = DR [m &gt;&gt; 1];

  if (dstd.l[1] & 0x1FFFFFFF))
    set_I ();

  if (FPSCR_RM == 1)
    dstd.l[1] &= 0xE0000000;  // round toward zero

  dstf.f = dstd.d;
  check_single_exception (result, dstf.f);
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU error</var>
  <var>Invalid operation</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow exception traps</var>
  <var><br /></var>
  <var>The exponent of DRn is not less than 0x47E</var>
  <var>
</var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow exception traps</var>
  <var><br /></var>
  <var>The exponent of DRn is not more than 0x380</var>
  <var>
</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input type="checkbox" id="row330" />
<label class="summary SH4 SH4A SH2A" for="row330">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcnvsd	FPUL,DRn</span>
<span>float_to_double (FPUL) → DRn</span>
<span id="1111nnn010101101" class="colorized"><span title="Opcode Identifier">1111</span><span title="Destination Register (R0 - R7)">nnn</span><span title="Opcode Identifier">010101101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3/5</var><var>1</var><var>4</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Converts the single-precision floating-point number in FPUL to a
double-precision floating-point number, and stores the result in DRn.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="" class="image_filter" src="fcnvsd.svg" height="128" />
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FCNVSD (int n)
{
  if (FPSCR_PR != 1)
    undefined_operation ();
  else
  {
    switch (fpul_type ())
    {
    case PZERO:
    case NZERO:
    case PINF:
    case NINF:
    case NORM:
      DR[n &gt;&gt; 1] = FPUL;  // convert float to double
      break;

    case DENORM:
      set_E ();
      break;

    case qNaN:
      qnan (n);
      break;

    case sNaN:
      invalid (n);
      break;
    }
  }
}

int fpul_type ()
{
  int abs = FPUL & 0x7FFFFFFF;
  if (abs &lt; 0x00800000)
  {
    if (FPSCR_DN == 1 || abs == 0x00000000)
    {
      if (sign_of (FPUL) == 0)
        return PZERO;
      else
        return NZERO;
    }
    else
      return DENORM;
  }
  else if (abs &lt; 0x7F800000)
    return NORM;
  else if (abs == 0x7F800000)
  {
    if (sign_of (FPUL) == 0)
      return PINF;
    else
      return NINF;
  }
  else if (abs &lt; 0x7FC00000)
    return qNaN;
  else
    return sNaN;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>FPU error</var>
  <var>Invalid operation</var>
</span>
</span>
</label>
<br/><br/><br/><b>Floating-Point Control Instructions</b><br/><br/>
<input type="checkbox" id="row331" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row331">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,FPSCR</span>
<span>Rm → FPSCR</span>
<span id="0100mmmm01101010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>4</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Loads the source operand into FPU system register FPSCR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSFPSCR (int m)
{
  #if SH2E || SH3E
  FPSCR = R[m] & 0x00018C60;

  #elif SH4 || SH4A || SH2A
  FPSCR = R[m] & 0x003FFFFF;

  #endif

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row332" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row332">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	FPSCR,Rn</span>
<span>FPSCR → Rn</span>
<span id="0000nnnn01101010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01101010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores FPU system register FPSCR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSFPSCR (int n)
{
  #if SH2E || SH3E
  R[n] = FPSCR;

  #elif SH4 || SH4A || SH2A
  R[n] = FPSCR & 0x003FFFFF;

  #endif

  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row333" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row333">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,FPSCR</span>
<span>(Rm) → FPSCR, Rm+4 → Rm</span>
<span id="0100mmmm01100110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01100110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3</var><var>1</var><var>3</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Loads the source operand into FPU system register FPSCR.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSMFPSCR (int m)
{
  #if SH2E || SH3E
  FPSCR = Read_32 (R[m]) & 0x00018C60;

  #elif SH4 || SH4A || SH2A
  FPSCR = Read_32 (R[m]) & 0x003FFFFF;

  #endif

  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row334" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row334">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	FPSCR,@-Rn</span>
<span>Rn-4 → Rn, FPSCR → (Rn)</span>
<span id="0100nnnn01100010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01100010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1/1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores FPU system register FPSCR in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMFPSCR (int n)
{
  R[n] -= 4;

  #if SH2E || SH3E
  Write_32 (R[n], FPSCR);

  #elif SH4 || SH4A || SH2A
  Write_32 (R[n], FPSCR & 0x003FFFFF);

  #endif

  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row335" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row335">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds	Rm,FPUL</span>
<span>Rm → FPUL</span>
<span id="0100mmmm01011010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01011010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section">Load to FPU System register</span>
<br />
<br />Loads the source operand into FPU system register FPUL.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void LDSFPUL (int m)
{
  FPUL = R[m];
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row336" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row336">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts	FPUL,Rn</span>
<span>FPUL → Rn</span>
<span id="0000nnnn01011010" class="colorized"><span title="Opcode Identifier">0000</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01011010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>3</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Store from FPU System Register</span>
<br />
<br />Stores FPU system register FPUL in the destination.

<br /><br />
<span title="section">Note</span>
<br />
<br />The original SH4 has a pipeline exception.  If the FTRC instruction is followed
by an STS FPUL, Rn instruction, the latency of the FTRC instruction is reduced
to 1 cycle.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSFPUL (int n)
{
  R[n] = FPUL;
  PC += 2;
}
</span>
</span>
</label>
<input type="checkbox" id="row337" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row337">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l	@Rm+,FPUL</span>
<span>(Rm) → FPUL, Rm+4 → Rm</span>
<span id="0100mmmm01010110" class="colorized"><span title="Opcode Identifier">0100</span><span title="Source Register (R0 - R15)">mmmm</span><span title="Opcode Identifier">01010110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1/2</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Operation</span>
<br />
<span title="code">void LDSMFPUL (int m)
{
  FPUL = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input type="checkbox" id="row338" />
<label class="summary SH2E SH3E SH4 SH4A SH2A" for="row338">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l	FPUL,@-Rn</span>
<span>Rn-4 → Rn, FPUL → (Rn)</span>
<span id="0100nnnn01010010" class="colorized"><span title="Opcode Identifier">0100</span><span title="Destination Register (R0 - R15)">nnnn</span><span title="Opcode Identifier">01010010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var></var><var>1</var><var></var><var>1/1</var><var>1</var><var>2</var></span>
<span class="details">
<span title="section">Store from FPU System Register</span>
<br />
<br />Stores FPU system register FPUL in the destination.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void STSMFPUL (int n)
{
  R[n] -= 4;
  Write_32 (R[n], FPUL);
  PC += 2;
}
</span>
<span title="section">Possible Exceptions</span>
<br />
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input type="checkbox" id="row339" />
<label class="summary SH4 SH4A" for="row339">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>frchg</span>
<span>If FPSCR.PR = 0: ~FPSCR.FR → FPSCR.FR
Else: Undefined Operation</span>
<span id="1111101111111101" class="colorized"><span title="Opcode Identifier">1111101111111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts the FR bit in floating-point register FPSCR. When the FR bit in FPSCR is
changed, FR0 to FR15 in FPR0_BANK0 to FPR15_BANK0 and FPR0_BANK1 to FPR15_BANK1
become XR0 to XR15, and XR0 to XR15 become FR0 to FR15. When FPSCR.FR = 0,
FPR0_BANK0 to FPR15_BANK0 correspond to FR0 to FR15, and FPR0_BANK1 to
FPR15_BANK1 correspond to XR0 to XR15. When FPSCR.FR = 1, FPR0_BANK1 to
FPR15_BANK1 correspond to FR0 to FR15, and FPR0_BANK0 to FPR15_BANK0 correspond
to XR0 to XR15.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FRCHG (void)
{
  if (FPSCR_PR == 0)
  {
    FPSCR ^= 0x00200000;  // toggle bit 21
    PC += 2;
  }
  else
    undefined_operation ();
}
</span>
</span>
</label>
<input type="checkbox" id="row340" />
<label class="summary SH4 SH4A SH2A" for="row340">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fschg</span>
<span>If FPSCR.PR = 0: ~FPSCR.SZ → FPSCR.SZ
Else: Undefined Operation</span>
<span id="1111001111111101" class="colorized"><span title="Opcode Identifier">1111001111111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/4</var><var>1</var><var>1</var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts the SZ bit of the floating-point status register FPSCR. Changing the
value of the SZ bit in FPSCR switches the amount of data for transfer by the
FMOV instruction between one single-precision data and a pair of
single-precision data. When FPSCR.SZ = 0, an FMOV instruction transfers a
single-precision number. When FPSCR.SZ = 1, the FMOV instruction transfers a
pair of single-precision numbers.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FSCHG (void)
{
  if (FPSCR_PR == 0)
  {
    FPSCR ^= 0x00100000;  // toggle bit 20
    PC += 2;
  }
  else
    undefined_operation ();
}
</span>
</span>
</label>
<input type="checkbox" id="row341" />
<label class="summary SH4A" for="row341">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fpchg</span>
<span>~FPSCR.PR → FPSCR.PR</span>
<span id="1111011111111101" class="colorized"><span title="Opcode Identifier">1111011111111101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Inverts the PR bit of the floating-point status register FPSCR. The value of
this bit selects single-precision or double-precision operation.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void FPCHG (void)
{
  FPSCR ^= 0x00080000;  // toggle bit 19
  PC += 2;
}
</span>
</span>
</label>
<br/><br/><br/><b>DSP Data Transfer Instructions</b><br/><br/>
<input type="checkbox" id="row342" />
<label class="summary DSP" for="row342">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nopx</span>
<span>No operation</span>
<span id="1111000*0*0*00**" class="colorized"><span title="Opcode Identifier">1111000</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">00</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />No access operation for X memory.
<br /><br />
</span>
</label>
<input type="checkbox" id="row343" />
<label class="summary DSP" for="row343">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w	@Ax,Dx</span>
<span>(Ax) → MSW of Dx, 0 → LSW of Dx</span>
<span id="111100A*D*0*01**" class="colorized"><span title="Opcode Identifier">111100</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">01</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.
<br /><br />
<span title="section">Example</span>
<br />
<span title="assembly">movx.w  @r4,x0   ! before execution: r4 = 0x08010000, @r4 = 0x5555, x0 = 0x12345678
                       ! after execution:  r4 = 0x08010000, x0 = 0x55550000
</span>
</span>
</label>
<input type="checkbox" id="row344" />
<label class="summary DSP" for="row344">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w	@Ax+,Dx</span>
<span>(Ax) → MSW of Dx, 0 → LSW of Dx, Ax+2 → Ax</span>
<span id="111100A*D*0*10**" class="colorized"><span title="Opcode Identifier">111100</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">10</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.
<br /><br />
<span title="section">Example</span>
<br />
<span title="assembly">movx.w  @r4+,x0  ! before execution: r4 = 0x08010000, @r4 = 0x5555, x0 = 0x12345678
                       ! after execution:  r4 = 0x08010002, x0 = 0x55550000
</span>
</span>
</label>
<input type="checkbox" id="row345" />
<label class="summary DSP" for="row345">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w	@Ax+Ix,Dx</span>
<span>(Ax) → MSW of Dx, 0 → LSW of Dx, Ax+Ix → Ax</span>
<span id="111100A*D*0*11**" class="colorized"><span title="Opcode Identifier">111100</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">11</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row346" />
<label class="summary DSP" for="row346">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w	Da,@Ax</span>
<span>MSW of Da → (Ax)</span>
<span id="111100A*D*1*01**" class="colorized"><span title="Opcode Identifier">111100</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">1</span><span title="Ignored">*</span><span title="Opcode Identifier">01</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row347" />
<label class="summary DSP" for="row347">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w	Da,@Ax+</span>
<span>MSW of Da → (Ax), Ax+2 → Ax</span>
<span id="111100A*D*1*10**" class="colorized"><span title="Opcode Identifier">111100</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">1</span><span title="Ignored">*</span><span title="Opcode Identifier">10</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row348" />
<label class="summary DSP" for="row348">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w	Da,@Ax+Ix</span>
<span>MSW of Da → (Ax), Ax+Ix → Ax</span>
<span id="111100A*D*1*11**" class="colorized"><span title="Opcode Identifier">111100</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">1</span><span title="Ignored">*</span><span title="Opcode Identifier">11</span><span title="Ignored">**</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row349" />
<label class="summary DSP" for="row349">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nopy</span>
<span>No Operation</span>
<span id="111100*0*0*0**00" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">**</span><span title="Opcode Identifier">00</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />No access operation for Y memory.
<br /><br />
</span>
</label>
<input type="checkbox" id="row350" />
<label class="summary DSP" for="row350">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w	@Ay,Dy</span>
<span>(Ay) → MSW of Dy, 0 → LSW of Dy</span>
<span id="111100*A*D*0**01" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">**</span><span title="Opcode Identifier">01</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row351" />
<label class="summary DSP" for="row351">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w	@Ay+,Dy</span>
<span>(Ay) → MSW of Dy, 0 → LSW of Dy, Ay+2 → Ay</span>
<span id="111100*A*D*0**10" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">**</span><span title="Opcode Identifier">10</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row352" />
<label class="summary DSP" for="row352">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w	@Ay+Iy,Dy</span>
<span>(Ay) → MSW of Dy, 0 → LSW of Dy, Ay+Iy → Ay</span>
<span id="111100*A*D*0**11" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">0</span><span title="Ignored">**</span><span title="Opcode Identifier">11</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row353" />
<label class="summary DSP" for="row353">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w	Da,@Ay</span>
<span>MSW of Da → (Ay)</span>
<span id="111100*A*D*1**01" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">1</span><span title="Ignored">**</span><span title="Opcode Identifier">01</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row354" />
<label class="summary DSP" for="row354">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w	Da,@Ay+</span>
<span>MSW of Da → (Ay), Ay+2 → Ay</span>
<span id="111100*A*D*1**10" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">1</span><span title="Ignored">**</span><span title="Opcode Identifier">10</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row355" />
<label class="summary DSP" for="row355">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w	Da,@Ay+Iy</span>
<span>MSW of Da → (Ay), Ay+Iy → Ay</span>
<span id="111100*A*D*1**11" class="colorized"><span title="Opcode Identifier">111100</span><span title="Ignored">*</span><span title="A">A</span><span title="Ignored">*</span><span title="D">D</span><span title="Ignored">*</span><span title="Opcode Identifier">1</span><span title="Ignored">**</span><span title="Opcode Identifier">11</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.
<br /><br />
<span title="section">Note</span>
<br />
<br />"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br /><br />
</span>
</label>
<input type="checkbox" id="row356" />
<label class="summary DSP" for="row356">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	@-As,Ds</span>
<span>As-2 → As, (As) → MSW of Ds, 0 → LSW of Ds</span>
<span id="111101AADDDD0000" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row357" />
<label class="summary DSP" for="row357">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	@As,Ds</span>
<span>(As) → MSW of Ds, 0 → LSW of Ds</span>
<span id="111101AADDDD0100" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row358" />
<label class="summary DSP" for="row358">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	@As+,Ds</span>
<span>(As) → MSW of Ds, 0 → LSW of Ds, As+2 → As</span>
<span id="111101AADDDD1000" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1000</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row359" />
<label class="summary DSP" for="row359">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	@As+Ix,Ds</span>
<span>(As) → MSW of Ds, 0 → LSW of DS, As+Ix → As</span>
<span id="111101AADDDD1100" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1100</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row360" />
<label class="summary DSP" for="row360">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	Ds,@-As</span>
<span>As-2 → As, MSW of Ds → (As)</span>
<span id="111101AADDDD0001" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row361" />
<label class="summary DSP" for="row361">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	Ds,@As</span>
<span>MSW of Ds → (As)</span>
<span id="111101AADDDD0101" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row362" />
<label class="summary DSP" for="row362">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	Ds,@As+</span>
<span>MSW of Ds → (As), As+2 → As</span>
<span id="111101AADDDD1001" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1001</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row363" />
<label class="summary DSP" for="row363">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w	Ds,@As+Is</span>
<span>MSW of DS → (As), As+Is → As</span>
<span id="111101AADDDD1101" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1101</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row364" />
<label class="summary DSP" for="row364">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	@-As,Ds</span>
<span>As-4 → As, (As) → Ds</span>
<span id="111101AADDDD0010" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row365" />
<label class="summary DSP" for="row365">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	@As,Ds</span>
<span>(As) → Ds</span>
<span id="111101AADDDD0110" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row366" />
<label class="summary DSP" for="row366">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	@As+,Ds</span>
<span>(As) → Ds, As+4 → As</span>
<span id="111101AADDDD1010" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1010</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row367" />
<label class="summary DSP" for="row367">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	@As+Is,Ds</span>
<span>(As) → Ds, As+Is → As</span>
<span id="111101AADDDD1110" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1110</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.
<br /><br />
</span>
</label>
<input type="checkbox" id="row368" />
<label class="summary DSP" for="row368">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	Ds,@-As</span>
<span>As-4 → As, Ds → (As)</span>
<span id="111101AADDDD0011" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row369" />
<label class="summary DSP" for="row369">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	Ds,@As</span>
<span>Ds → (As)</span>
<span id="111101AADDDD0111" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">0111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row370" />
<label class="summary DSP" for="row370">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	Ds,@As+</span>
<span>Ds → (As), As+4 → As</span>
<span id="111101AADDDD1011" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1011</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<input type="checkbox" id="row371" />
<label class="summary DSP" for="row371">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l	Ds,@As+Is</span>
<span>Ds → (As), As+Is → As</span>
<span id="111101AADDDD1111" class="colorized"><span title="Opcode Identifier">111101</span><span title="A">AA</span><span title="D">DDDD</span><span title="Opcode Identifier">1111</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Transfers the source operand data to the destination. The transferred data is a
longword.
<br /><br />
<span title="section">Note</span>
<br />
<br />When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.
<br /><br />
</span>
</label>
<br/><br/><br/><b>DSP ALU Arithmetic Operation Instructions</b><br/><br/>
<input type="checkbox" id="row372" />
<label class="summary DSP" for="row372">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pabs		Sx,Dz</span>
<span>If Sx &gt;= 0: Sx → Dz
If Sx &lt; 0: 0 - Sx → Dz</span>
<span id="111110**********_10001000xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10001000</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds absolute values. When the Sx operand is positive, the contents of the
operand are transferred to the Dz operand. If the value is negative, the value
of the Sx operand is subtracted from 0 and stored in the Dz operand.
<br /><br />
The DC bit of the DSR register are updated according to the specifications of
the CS bits. The N, Z, V, and GT bits of the DSR register are updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pabs_sx (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    // positive value
    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;
    carry_bit = 0;
    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  }
  else
  {
    // negative value
    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;
    borrow_bit = 1;
    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  }

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    #include "fixed_pt_plus_dc_bit.c"
  }
  else
  {
    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
    #include "fixed_pt_minus_dc_bit.c"
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row373" />
<label class="summary DSP" for="row373">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pabs		Sy,Dz</span>
<span>If Sy &gt;= 0: Sy → Dz
If Sy &lt; 0: 0 - Sy → Dz</span>
<span id="111110**********_1010100000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1010100000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds absolute values. When the Sy operand is positive, the contents of the
operand are transferred to the Dz operand. If the value is negative, the value
of the Sy operand is subtracted from 0 and stored in the Dz operand.
<br /><br />
The DC bit of the DSR register are updated according to the specifications of
the CS bits. The N, Z, V, and GT bits of the DSR register are updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pabs_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    // positive value
    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;
    carry_bit = 0;
    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  }
  else
  {
    // negative value
    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;
    borrow_bit = 1;
    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  }

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    #include "fixed_pt_plus_dc_bit.c"
  }
  else
  {
    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
    #include "fixed_pt_minus_dc_bit.c"
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row374" />
<label class="summary DSP" for="row374">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>padd		Sx,Sy,Dz</span>
<span>Sx + Sy → Dz</span>
<span id="111110**********_10110001xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds the contents of the Sx and Sy operands and stores the result in the Dz
operand.  The DC bit of the DSR register is updated according to the
specifications for the CS bits. The N, Z, V, and GT bits of the DSR register
are also updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />The DC bit is updated depending on the state of the CS [2:0] bit immediately
before the operation.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void padd (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">padd     x0,y0,a0   nopx   nopy    ! before execution: x0 = 0x22222222, y0 = 0x33333333, a0 = 0x123456789a
                                       ! after execution:  x0 = 0x22222222, y0 = 0x33333333, a0 = 0x0055555555
</span>
</span>
</label>
<input type="checkbox" id="row375" />
<label class="summary DSP" for="row375">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct padd	Sx,Sy,Dz</span>
<span>If DC = 1: Sx + Sy → Dz
Else: nop</span>
<span id="111110**********_10110010xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally adds the contents of the Sx and Sy operands and stores the result
in the Dz operand.  The instruction is executed of the DC bit is set to 1.
Otherwise no operation is performed.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void padd_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG [ex2_dz_no] = DSP_ALU_DST;
    if(ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no==1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row376" />
<label class="summary DSP" for="row376">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf padd	Sx,Sy,Dz</span>
<span>If DC = 0: Sx + Sy → Dz
Else: nop</span>
<span id="111110**********_10110011xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally adds the contents of the Sx and Sy operands and stores the result
in the Dz operand.  The instruction is executed of the DC bit is set to 0.
Otherwise no operation is performed.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void padd_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG [ex2_dz_no] = DSP_ALU_DST;
    if(ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no==1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row377" />
<label class="summary DSP" for="row377">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>padd		Sx,Sy,Du
pmuls		Se,Sf,Dg</span>
<span>Sx + Sy → Du
MSW of Se × MSW of Sf → Dg</span>
<span id="111110**********_0111eeffxxyygguu" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">0111</span><span title="Multiplier Source Register 1 (A1, X0, X1, Y0)">ee</span><span title="Multiplier Source Register 2 (A1, X0, Y0, Y1)">ff</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="Multiplier Destination Register (A0, A1, M0, M1)">gg</span><span title="ALU Destination Register (A0, A1, X0, Y0)">uu</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds the contents of the Sx and Sy operands and stores the result in the Du
operand. The contents of the top word of the Se and Sf operands are multiplied
as signed and the result stored in the Dg operand. These two processes are
executed simultaneously in parallel.
<br /><br />
The DC bit of the DSR register is updated according to the results of the ALU
operation and the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated according to the results of the ALU operation.
<br /><br />
<span title="section">Note</span>
<br />
<br />Since the PMULS is fixed decimal point multiplication, the operation result is
different from that of MULS even though the source data is the same.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void padd_pmuls (void)
{
  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  switch (EX2_DU)
  {
  case 0x0:
    X0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x1:
    Y0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x2:
    A0 = DSP_ALU_DST;
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G = A0G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x3:
    A1 = DSP_ALU_DST;
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G = A1G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;
  }

  #include "fixed_pt_plus_dc_bit.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">padd    a0,m0,a0  pmuls x0,yo,mo  nopx  nopy
                      ! before execution:  x0 = 0x00020000, y0 = 0x00030000, m0 = 0x22222222, a0 = 0x0055555555
                      ! after execution: x0 = 0x00020000, y0 = 0x00030000, m0 = 0x0000000c, a0 = 0x0077777777
</span>
</span>
</label>
<input type="checkbox" id="row378" />
<label class="summary DSP" for="row378">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>paddc		Sx,Sy,Dz</span>
<span>Sx + Sy + DC → Dz</span>
<span id="111110**********_10110000xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110000</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds the contents of the Sx and Sy operands to the DC bit and stores the result
in the Dz operand. The DC bit of the DSR register is updated as the carry flag.
The N, Z, V, and GT bits of the DSR register are also updated.

<br /><br />
<span title="section">Note</span>
<br />
<br />The DC bit is updated as the carry flag after execution of the PADDC instruction
regardless of the CS bits.
<br /><br />
CS[2:0] = ***: Always operate as Carry or Borrow mode, regardless of the status
of the DC bit.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void paddc (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2 + DSPDCBIT;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_dc_always_carry.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">paddc  x0,y0,m0  nopx  nopy   ! before execution: x0 = 0xb3333333, y0 = 0x55555555 m0 = 0x12345678, dc = 0
                                   ! after execution: x0 = 0xb3333333, y0 = 0x55555555 m0 = 0x08888888, dc = 1


paddc  x0,y0,m0  nopx  nopy   ! before execution: x0 = 0x33333333, y0 = 0x55555555 m0 = 0x12345678, dc = 1
                                   ! after execution: x0 = 0x33333333, y0 = 0x55555555 m0 = 0x88888889, dc = 0
</span>
</span>
</label>
<input type="checkbox" id="row379" />
<label class="summary DSP" for="row379">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pclr		Dz</span>
<span>0x00000000 → Dz</span>
<span id="111110**********_100011010000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">100011010000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Clears the Dz operand.  The DC bit of the DSR register is updated according to
the specifications for the CS bits. The Z bit of the DSR register is set to 1.
The N, V, and GT bits are cleared to 0.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pclr (void)
{
  DSP_REG[ex2_dz_no] = 0x0;

  if (ex2_dz_no == 0)
    A0G = 0x0;
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0;
  negative_bit = 0;
  zero_bit = 1;
  overflow_bit = 0;

  #include "fixed_pt_plus_dc_bit.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">pclr    a0  nopx  nopy   ! before execution: a0 = 0xff87654321
                             ! after execution: a0 = 0x0000000000
</span>
</span>
</label>
<input type="checkbox" id="row380" />
<label class="summary DSP" for="row380">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pclr	Dz</span>
<span>If DC = 1: 0x00000000 → Dz
Else: nop</span>
<span id="111110**********_100011100000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">100011100000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally clears the Dz operand.  The instruction is executed when the DC
bit is set to 1.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pclr_dct (void)
{
  if (DC == 1)
    DSP_REG[ex2_dz_no] = 0x0;
}
</span>
</span>
</label>
<input type="checkbox" id="row381" />
<label class="summary DSP" for="row381">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pclr	Dz</span>
<span>If DC = 0: 0x00000000 → Dz
Else: nop</span>
<span id="111110**********_100011110000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">100011110000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally clears the Dz operand.  The instruction is executed when the DC
bit is set to 0.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pclr_dcf (void)
{
  if (DC == 0)
    DSP_REG[ex2_dz_no] = 0x0;
}
</span>
</span>
</label>
<input type="checkbox" id="row382" />
<label class="summary DSP" for="row382">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pcmp		Sx,Sy</span>
<span>Sx - Sy</span>
<span id="111110**********_10000100xxyy0000" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10000100</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="Opcode Identifier">0000</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of the Sy operand from the Sx operand. The DC bit of the
DSR register is updated according to the specifications for the CS bits.
The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcmp (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);

  borrow_bit = ! carry_bit;

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;

  negative_bit = DSP_ALU_DSTG_BIT7;
  zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_minus_dc_bit.c"

}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">pcmp    x0,y0  nopx  nopy  ! before execution: x0 = 0x22222222, y0 = 0x33333333
                               ! after execution: x0 = 0x22222222, y0 = 0x33333333
                               !                  n = 1, z = 0, v = 0, gt = 0
</span>
</span>
</label>
<input type="checkbox" id="row383" />
<label class="summary DSP" for="row383">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pcopy		Sx,Dz</span>
<span>Sx → Dz</span>
<span id="111110**********_11011001xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">11011001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the Sx operand in the Dz operand.  The DC bit of the DSR register
is updated according to the specifications for the CS bits. The N, Z, V, and GT
bits are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcopy_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}

</span>
</span>
</label>
<input type="checkbox" id="row384" />
<label class="summary DSP" for="row384">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pcopy		Sy,Dz</span>
<span>Sy → Dz</span>
<span id="111110**********_1111100100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1111100100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the Sy operand in the Dz operand.  The DC bit of the DSR register
is updated according to the specifications for the CS bits. The N, Z, V, and GT
bits are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcopy_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">pcopy   x0,a0  nopx  nopy  ! before execution: x0 = 0x55555555, a0 = 0xffffffff
                                ! after execution: x0 = 0x55555555, a0 = 0x0055555555
</span>
</span>
</label>
<input type="checkbox" id="row385" />
<label class="summary DSP" for="row385">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pcopy	Sx,Dz</span>
<span>If DC = 1: Sx → Dz
Else: nop</span>
<span id="111110**********_11011010xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">11011010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Sx operand in the Dz operand.  The instruction
is executed if the DC bit is set to 1.  The DC, N, Z, V, and GT bits are not
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcopy_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row386" />
<label class="summary DSP" for="row386">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pcopy	Sy,Dz</span>
<span>If DC = 1: Sy → Dz
Else: nop</span>
<span id="111110**********_1111101000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1111101000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Sy operand in the Dz operand.  The instruction
is executed if the DC bit is set to 1.  The DC, N, Z, V, and GT bits are not
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcopy_sy_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row387" />
<label class="summary DSP" for="row387">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pcopy	Sx,Dz</span>
<span>If DC = 0: Sx → Dz
Else: nop</span>
<span id="111110**********_11011011xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">11011011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Sx operand in the Dz operand.  The instruction
is executed if the DC bit is set to 0.  The DC, N, Z, V, and GT bits are not
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcopy_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row388" />
<label class="summary DSP" for="row388">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pcopy	Sy,Dz</span>
<span>If DC = 0: Sy → Dz
Else: nop</span>
<span id="111110**********_1111101100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1111101100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Sy operand in the Dz operand.  The instruction
is executed if the DC bit is set to 0.  The DC, N, Z, V, and GT bits are not
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pcopy_sy_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row389" />
<label class="summary DSP" for="row389">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pneg		Sx,Dz</span>
<span>0 - Sx → Dz</span>
<span id="111110**********_11001001xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">11001001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Reverses the sign. Subtracts the Sx operand from 0 and stores the result in
the Dz operand.  The DC bit of the DSR register is updated according to the
specifications for the CS bits. The N, Z, V, and GT bits of the DSR register
are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pneg_sx (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row390" />
<label class="summary DSP" for="row390">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pneg		Sy,Dz</span>
<span>0 - Sy → Dz</span>
<span id="111110**********_1110100100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1110100100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Reverses the sign. Subtracts the Sy operand from 0 and stores the result in
the Dz operand.  The DC bit of the DSR register is updated according to the
specifications for the CS bits. The N, Z, V, and GT bits of the DSR register
are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pneg_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row391" />
<label class="summary DSP" for="row391">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pneg	Sx,Dz</span>
<span>If DC = 1: 0 - Sx → Dz
Else: nop</span>
<span id="111110**********_11001010xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">11001010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 1.  Subtracts the Sx operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pneg_sx_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row392" />
<label class="summary DSP" for="row392">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pneg	Sy,Dz</span>
<span>If DC = 1: 0 - Sy → Dz
Else: nop</span>
<span id="111110**********_1110101000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1110101000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 1.  Subtracts the Sy operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pneg_sy_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row393" />
<label class="summary DSP" for="row393">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pneg	Sx,Dz</span>
<span>If DC = 0: 0 - Sx → Dz
Else: nop</span>
<span id="111110**********_11001011xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">11001011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 0.  Subtracts the Sx operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pneg_sx_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row394" />
<label class="summary DSP" for="row394">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pneg	Sy,Dz</span>
<span>If DC = 0: 0 - Sy → Dz
Else: nop</span>
<span id="111110**********_1110101100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1110101100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally reverses the sign.  The instruction is executed if the DC bit is
set to 0.  Subtracts the Sy operand from 0 and stores the result in the Dz
operand.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pneg_sy_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row395" />
<label class="summary DSP" for="row395">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psub		Sx,Sy,Dz</span>
<span>Sx - Sy → Dz</span>
<span id="111110**********_10100001xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of the Sy operand from the Sx operand and stores the
result in the Dz operand.  The DC bit of the DSR register is updated according
to the specifications for the CS bits. The N, Z, V, and GT bits of the DSR
register are updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psub (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">psub    x0,y0,a0  nopx  nopy  ! before execution: x0 = 0x55555555, y0 = 0x33333333, a0 = 0x123456789a
                                  ! after execution: x0 = 0x55555555, y0 = 0x33333333, a0 = 0x0022222222
</span>
</span>
</label>
<input type="checkbox" id="row396" />
<label class="summary DSP" for="row396">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psub	Sx,Sy,Dz</span>
<span>If DC = 1: Sx - Sy → Dz
Else: nop</span>
<span id="111110**********_10100010xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally subtracts the contents of the Sy operand from the Sx operand and
stores the result in the Dz operand.  The instruction is executed if the DC bit
is set to 1.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psub_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row397" />
<label class="summary DSP" for="row397">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psub 	Sx,Sy,Dz</span>
<span>If DC = 0: Sx - Sy → Dz
Else: nop</span>
<span id="111110**********_10100011xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally subtracts the contents of the Sy operand from the Sx operand and
stores the result in the Dz operand.  The instruction is executed if the DC bit
is set to 0.  The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psub_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row398" />
<label class="summary DSP" for="row398">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psub		Sx,Sy,Du
pmuls		Se,Sf,Dg</span>
<span>Sx - Sy → Du
MSW of Se × MSW of Sf → Dg</span>
<span id="111110**********_0110eeffxxyygguu" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">0110</span><span title="Multiplier Source Register 1 (A1, X0, X1, Y0)">ee</span><span title="Multiplier Source Register 2 (A1, X0, Y0, Y1)">ff</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="Multiplier Destination Register (A0, A1, M0, M1)">gg</span><span title="ALU Destination Register (A0, A1, X0, Y0)">uu</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of the Sy operand from the Sx operand and stores the
result in the Du operand. The contents of the top word of the Se and Sf operands
are multiplied as signed and the result stored in the Dg operand. These two
processes are executed simultaneously in parallel.
<br /><br />
The DC bit of the DSR register is updated according to the results of the ALU
operation and the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated according to the results of the ALU operation.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psub_pmuls (void)
{
  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  switch (EX2_DU)
  {
  case 0x0:
    X0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DST_MSB;
    zero_bit = (DSP_ALU_DST == 0);
    break;

  case 0x1:
    Y0  = DSP_ALU_DST;
    negative_bit = DSP_ALU_DST_MSB;
    zero_bit = (DSP_ALU_DST == 0);
    break;

  case 0x2:
    A0 = DSP_ALU_DST;
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G = A0G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x3:
    A1 = DSP_ALU_DST;
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G = A1G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;
  }

  #include "fixed_pt_minus_dc_bit.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">psub    a0,m0,a0  pmuls x0,y0,m0  nopx  nopy
                  ! before execution: x0 = 0x00020000, y0 = 0xfffe0000, m0 = 0x33333333, a0 = 0x0022222222
                  ! after execution: x0 = 0x00020000, y0 = 0xfffe0000, m0 = 0xfffffff8, a0 = 0x55555555
</span>
</span>
</label>
<input type="checkbox" id="row399" />
<label class="summary DSP" for="row399">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psubc		Sx,Sy,Dz</span>
<span>Sx - Sy - DC → Dz</span>
<span id="111110**********_10100000xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100000</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts the contents of the Sy operand and the DC bit from the Sx operand and
stores the result in the Dz operand. The DC bit of the DSR register is updated
as the borrow flag. The N, Z, V, and GT bits of the DSR register are also
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psubc (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2 - DSPDCBIT;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_dc_always_borrow.c"
}
</span>
<span title="section">Example</span>
<br />
<span title="assembly">psubc  x0,y0,m0  nopx  nopy  ! before execution: x0 = 0x33333333, y0 = 0x55555555 m0 = 0x0012345678, dc = 0
                                  ! after execution: x0 = 0x33333333, y0 = 0x55555555 m0 = 0xffddddddde, dc = 1

psubc  x0,y0,m0  nopx  nopy  ! before execution: x0 = 0x33333333, y0 = 0x55555555 m0 = 0x0012345678, dc = 1
                                  ! after execution: x0 = 0x33333333, y0 = 0x55555555 m0 = 0xffdddddddd, dc = 1
</span>
</span>
</label>
<input type="checkbox" id="row400" />
<label class="summary DSP" for="row400">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdec		Sx,Dz</span>
<span>MSW of Sx - 1 → MSW of Dz, clear LSW of Dz</span>
<span id="111110**********_10001001xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10001001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts 1 from the top word of the Sx operand, stores the result in the upper
word of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />The bottom word of the destination register is ignored when the DC bit is
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdec_sx (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_minus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row401" />
<label class="summary DSP" for="row401">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdec		Sy,Dz</span>
<span>MSW of Sy - 1 → MSW of Dz, clear LSW of Dz</span>
<span id="111110**********_1010100100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1010100100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Subtracts 1 from the top word of the Sy operand, stores the result in the upper
word of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />The bottom word of the destination register is ignored when the DC bit is
updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdec_sy (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_minus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row402" />
<label class="summary DSP" for="row402">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdec	Sx,Dz</span>
<span>If DC = 1: MSW of Sx - 1 → MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10001010xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10001010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally subtracts 1 from the top word of the Sx operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdec_sx_dct (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row403" />
<label class="summary DSP" for="row403">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdec	Sy,Dz</span>
<span>If DC = 1: MSW of Sy - 1 → MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********_1010101000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1010101000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally subtracts 1 from the top word of the Sy operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdec_sy_dct (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row404" />
<label class="summary DSP" for="row404">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdec	Sx,Dz</span>
<span>If DC = 0: MSW of Sx - 1 → MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10001011xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10001011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally subtracts 1 from the top word of the Sx operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdec_sx_dcf (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row405" />
<label class="summary DSP" for="row405">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdec	Sy,Dz</span>
<span>If DC = 0: MSW of Sy - 1 → MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********_1010101100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1010101100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally subtracts 1 from the top word of the Sy operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdec_sy_dcf (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row406" />
<label class="summary DSP" for="row406">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pinc		Sx,Dz</span>
<span>MSW of Sy + 1 → MSW of Dz, clear LSW of Dz</span>
<span id="111110**********_10011001xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds 1 to the top word of the Sx operand, stores the result in the upper word
of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pinc_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row407" />
<label class="summary DSP" for="row407">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pinc		Sy,Dz</span>
<span>MSW of Sy + 1 → MSW of Dz, clear LSW of Dz</span>
<span id="111110**********_1011100100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011100100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Adds 1 to the top word of the Sy operand, stores the result in the upper word
of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pinc_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row408" />
<label class="summary DSP" for="row408">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pinc	Sx,Dz</span>
<span>If DC = 1: MSW of Sx + 1 → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10011010xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally adds 1 to the top word of the Sx operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pinc_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row409" />
<label class="summary DSP" for="row409">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pinc	Sy,Dz</span>
<span>If DC = 1: MSW of Sy + 1 → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_1011101000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011101000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally adds 1 to the top word of the Sy operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pinc_sy_dct (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row410" />
<label class="summary DSP" for="row410">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pinc	Sx,Dz</span>
<span>If DC = 0: MSW of Sx + 1 → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10011011xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally adds 1 to the top word of the Sx operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pinc_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row411" />
<label class="summary DSP" for="row411">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pinc	Sy,Dz</span>
<span>If DC = 0: MSW of Sy + 1 → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_1011101100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011101100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally adds 1 to the top word of the Sy operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pinc_sy_dcf (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row412" />
<label class="summary DSP" for="row412">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdmsb		Sx,Dz</span>
<span>Sx data MSB position → MSW of Dz, clear LSW of Dz</span>
<span id="111110**********_10011101xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011101</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds the first position to change in the lineup of Sx operand bits and stores
the bit position in the Dz operand.  The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of the
DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdmsb_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;
  overflow_bit = 0;

  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row413" />
<label class="summary DSP" for="row413">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdmsb		Sy,Dz</span>
<span>Sy data MSB position → MSW of Dz, clear LSW of Dz</span>
<span id="111110**********_1011110100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011110100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Finds the first position to change in the lineup of Sy operand bits and stores
the bit position in the Dz operand.  The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of the
DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdmsb_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;
  overflow_bit = 0;

  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row414" />
<label class="summary DSP" for="row414">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdmsb	Sx,Dz</span>
<span>If DC = 1: Sx data MSB position → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10011110xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011110</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally finds the first position to change in the lineup of Sx operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdmsb_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row415" />
<label class="summary DSP" for="row415">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdmsb	Sy,Dz</span>
<span>If DC = 1: Sy data MSB position → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_1011111000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011111000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally finds the first position to change in the lineup of Sy operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdmsb_sy_dct (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row416" />
<label class="summary DSP" for="row416">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdmsb	Sx,Dz</span>
<span>If DC = 0: Sx data MSB position → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10011111xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011111</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally finds the first position to change in the lineup of Sx operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdmsb_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row417" />
<label class="summary DSP" for="row417">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdmsb	Sy,Dz</span>
<span>If DC = 0: Sy data MSB position → MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_1011111100yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011111100</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally finds the first position to change in the lineup of Sy operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pdmsb_sy_dcf (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i &gt;= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i &gt;= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row418" />
<label class="summary DSP" for="row418">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>prnd		Sx,Dz</span>
<span>Sx + 0x00008000 → Dz, clear LSW of Dz</span>
<span id="111110**********_10011000xx00zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10011000</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="Opcode Identifier">00</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Does rounding. Adds the immediate data 0x00008000 to the contents of the Sx
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of Dz with zeros.
<br /><br />
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void prnd_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) & MASKFFFF0000;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row419" />
<label class="summary DSP" for="row419">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>prnd		Sy,Dz</span>
<span>Sy + 0x00008000 → Dz, clear LSW of Dz</span>
<span id="111110**********_1011100000yyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">1011100000</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Does rounding. Adds the immediate data 0x00008000 to the contents of the Sy
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of Dz with zeros.
<br /><br />
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void prnd_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) & MASKFFFF0000;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}
</span>
</span>
</label>
<br/><br/><br/><b>DSP ALU Logical Operation Instructions</b><br/><br/>
<input type="checkbox" id="row420" />
<label class="summary DSP" for="row420">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pand		Sx,Sy,Dz</span>
<span>Sx & Sy → Dz, clear LSW of Dz</span>
<span id="111110**********_10010101xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10010101</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Does an AND of the upper word of the Sx operand and the upper word of the Sy
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of the Dz operand with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed. The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />The bottom word of the destination register and the guard bits are ignored when
the DC bit is updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pand (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW & DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row421" />
<label class="summary DSP" for="row421">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pand	Sx,Sy,Dz</span>
<span>If DC = 1: Sx & Sy → Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10010110xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10010110</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally does an AND of the upper word of the Sx operand and the upper word
of the Sy operand, stores the result in the upper word of the Dz operand, and
clears the bottom word of the Dz operand with zeros. When Dz is a register that
has guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pand_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW & DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no==1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row422" />
<label class="summary DSP" for="row422">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pand	Sx,Sy,Dz</span>
<span>If DC = 0: Sx & Sy → Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10010111xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10010111</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally does an AND of the upper word of the Sx operand and the upper word
of the Sy operand, stores the result in the upper word of the Dz operand, and
clears the bottom word of the Dz operand with zeros. When Dz is a register that
has guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pand_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW & DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no==1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row423" />
<label class="summary DSP" for="row423">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>por		Sx,Sy,Dz</span>
<span>Sx | Sy → Dz, clear LSW of Dz</span>
<span id="111110**********_10110101xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110101</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Takes the OR of the top word of the Sx operand and the top word of the Sy
operand, stores the result in the top word of the Dz operand, and clears the
bottom word of Dz with zeros. When Dz is a register that has guard bits, the
guard bits are also zeroed.   The DC bit of the DSR register is updated
according to the specifications for the CS bits. The N, Z, V, and GT bits of
the DSR register are also updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />The bottom word of the destination register and the guard bits are ignored when
the DC bit is updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void por (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row424" />
<label class="summary DSP" for="row424">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct por		Sx,Sy,Dz</span>
<span>If DC = 1: Sx | Sy → Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10110110xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110110</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally takes the OR of the top word of the Sx operand and the top word
of the Sy operand, stores the result in the top word of the Dz operand, and
clears the bottom word of Dz with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed.  The instruction is executed if the DC bit
is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void por_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // /*  */
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row425" />
<label class="summary DSP" for="row425">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf por		Sx,Sy,Dz</span>
<span>If DC = 0: Sx | Sy → Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10110111xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10110111</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally takes the OR of the top word of the Sx operand and the top word
of the Sy operand, stores the result in the top word of the Dz operand, and
clears the bottom word of Dz with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed.  The instruction is executed if the DC bit
is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void por_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // /*  */
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row426" />
<label class="summary DSP" for="row426">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pxor		Sx,Sy,Dz</span>
<span>Sx ^ Sy → Dz, clear LSW of Dz</span>
<span id="111110**********_10100101xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100101</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Takes the exclusive OR of the top word of the Sx operand and the top word of the
Sy operand, stores the result in the top word of the Dz operand, and clears the
bottom word of Dz with zeros. When Dz is a register that has guard bits, the
guard bits are also zeroed.  The DC bit of the DSR register is updated according
to the specifications for the CS bits. The N, Z, V, and GT bits of the DSR
register are also updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />The bottom word of the destination register and the guard bits are ignored when
the DC bit is updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pxor (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row427" />
<label class="summary DSP" for="row427">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pxor	Sx,Sy,Dz</span>
<span>If DC = 1: Sx ^ Sy → Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10100110xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100110</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally takes the exclusive OR of the top word of the Sx operand and the
top word of the Sy operand, stores the result in the top word of the Dz operand,
and clears the bottom word of Dz with zeros. When Dz is a register that has
guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pxor_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row428" />
<label class="summary DSP" for="row428">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pxor	Sx,Sy,Dz</span>
<span>If DC = 0: Sx ^ Sy → Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********_10100111xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10100111</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally takes the exclusive OR of the top word of the Sx operand and the
top word of the Sy operand, stores the result in the top word of the Dz operand,
and clears the bottom word of Dz with zeros. When Dz is a register that has
guard bits, the guard bits are also zeroed.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pxor_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<br/><br/><br/><b>DSP Fixed Decimal Point Multiplication Instructions</b><br/><br/>
<input type="checkbox" id="row429" />
<label class="summary DSP" for="row429">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pmuls	Se,Sf,Dg</span>
<span>MSW of Se × MSW of Sf → Dg</span>
<span id="111110**********_0100eeff0000gg00" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">0100</span><span title="Multiplier Source Register 1 (A1, X0, X1, Y0)">ee</span><span title="Multiplier Source Register 2 (A1, X0, Y0, Y1)">ff</span><span title="Opcode Identifier">0000</span><span title="Multiplier Destination Register (A0, A1, M0, M1)">gg</span><span title="Opcode Identifier">00</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />The contents of the top word of the Se and Sf operands are multiplied as signed
and the result stored in the Dg operand. The DC, N, Z, V, and GT bits of the
DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Since PMULS is fixed decimal point multiplication, the operation result is
different from that of MULS even though the source data is the same.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pmuls (void)
{
  switch (ee)  // Se Operand selection bit (ee)
  {
  case 0x0:
    DSP_M_SRC1 = X0;
    break;

  case 0x1:
    DSP_M_SRC1 = X1;
    break;

  case 0x2:
    DSP_M_SRC1 = Y0;
    break;

  case 0x3:
    DSP_M_SRC1 = A1;
    break;
  }

  switch (ff)  // Sf Operand selection bit (ff)
  {
  case 0x0:
    DSP_M_SRC2 = Y0;
    break;

  case 0x1:
    DSP_M_SRC2 = Y1;
    break;

  case 0x2:
    DSP_M_SRC2 = X0;
    break;

  case 0x3:
    DSP_M_SRC2 = A1;
    break;
  }

  if ((SBIT == 1) && (DSP_M_SRC1 == 0x8000) && (DSP_M_SRC2 == 0x8000))
    DSP_M_DST = 0x7FFFFFFF;  // overflow protection
  else
    DSP_M_DST= ((long)(short)DSP_M_SRC1 * (long)(short)DSP_M_SRC2) &lt;&lt; 1;

  if (DSP_M_DST_MSB)
    DSP_M_DSTG_LSB8 = 0xFF;
  else
    DSP_M_DSTG_LSB8 = 0x0;

  switch (gg)  // Dg Operand selection bit (gg)
  {
  case 0x0:
    M0 = DSP_M_DST;
    break;

  case 0x1:
    M1 = DSP_M_DST;
    break;

  case 0x2:
    A0 = DSP_M_DST;
    if (DSP_M_DSTG_LSB8 == 0x0)
      A0G=0x0;
    else
      A0G = 0xFFFFFFFF;
    break;

  case 0x3:
    A1 = DSP_M_DST;
    if (DSP_M_DSTG_LSB8 == 0x0)
      A1G = 0x0;
    else
      A1G = 0xFFFFFFFF;
    break;
  }
}
</span>
</span>
</label>
<br/><br/><br/><b>DSP Shift Operation Instructions</b><br/><br/>
<input type="checkbox" id="row430" />
<label class="summary DSP" for="row430">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psha		Sx,Sy,Dz</span>
<span>If Sy &gt;= 0: Sx &lt;&lt; Sy → Dz
If Sy &lt; 0: Sx &gt;&gt; Sy → Dz</span>
<span id="111110**********_10010001xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10010001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically shifts the contents of the Sx or Dz operand and stores the result
in the Dz operand. The amount of the shift is specified by the Sy operand.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psha (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 & MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW & MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt &gt; 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "shift_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row431" />
<label class="summary DSP" for="row431">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psha	Sx,Sy,Dz</span>
<span>If DC = 1 & Sy &gt;= 0: Sx &lt;&lt; Sy → Dz
If DC = 1 & Sy &lt; 0: Sx &gt;&gt; Sy → Dz
If DC = 0: nop</span>
<span id="111110**********_10010010xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10010010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally arithmetically shifts the contents of the Sx operand and
stores the result in the Dz operand. The amount of the shift is specified by
the Sy operand.  When the shift amount is positive, it shifts left. When the
shift amount is negative, it shifts right.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psha_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 & MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW & MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt &gt; 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row432" />
<label class="summary DSP" for="row432">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psha	Sx,Sy,Dz</span>
<span>If DC = 0 & Sy &gt;= 0: Sx &lt;&lt; Sy → Dz
If DC = 0 & Sy &lt; 0: Sx &gt;&gt; Sy → Dz
If DC = 1: nop</span>
<span id="111110**********_10010011xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10010011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally arithmetically shifts the contents of the Sx operand and
stores the result in the Dz operand. The amount of the shift is specified by
the Sy operand.  When the shift amount is positive, it shifts left. When the
shift amount is negative, it shifts right.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psha_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 & MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW & MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt &gt; 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row433" />
<label class="summary DSP" for="row433">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psha		#imm,Dz</span>
<span>If imm &gt;= 0: Dz &lt;&lt; imm → Dz
If imm &lt; 0: Dz &gt;&gt; imm → Dz</span>
<span id="111110**********_00000iiiiiiizzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">00000</span><span title="Unsigned Immediate Data (7 bits)">iiiiiii</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Arithmetically shifts the contents of the Dz operand and stores the result in
the Dz operand. The amount of the shift is specified by the immediate value.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psha_imm (void)
{
  unsigned short tmp_imm;
  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];

  switch (ex2_dz_no)
  {
    case 0x0:
      DSP_ALU_SRC1G = A0G;
      break;

    case 0x1:
      DSP_ALU_SRC1G = A1G;
      break;

    default:
      if (DSP_ALU_SRC1_MSB)
        DSP_ALU_SRC1G = 0xFF;
      else
        DSP_ALU_SRC1G = 0x0;
  }

  tmp_imm = ((EX2_LW &gt;&gt; 4) & MASK0000007F); // bit[10:4]

  if ((tmp_imm & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = tmp_imm & MASK003F;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\n", tmp_imm);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = (DSP_ALU_DSTG & MASK00000001) == 0x1;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~tmp_imm & MASK003F) + 1;
    if (cnt &gt; 32)
    {
      printf ("\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\n", tmp_imm);
      exit ();
    }

    if ((cnt &gt; 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "shift_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row434" />
<label class="summary DSP" for="row434">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pshl		Sx,Sy,Dz</span>
<span>If Sy &gt;= 0: Sx &lt;&lt; Sy → Dz, clear LSW of Dz
If Sy &lt; 0: Sx &gt;&gt; Sy → Dz, clear LSW of Dz</span>
<span id="111110**********_10000001xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10000001</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the top word contents of the Sx operand, stores the result in
the top word of the Dz operand, and clears the bottom word of the Dz operand
with zeros. When Dz is a register that has guard bits, the guard bits are also
zeroed. The amount of the shift is specified by the Sy operand. When the shift
amount is positive, it shifts left. When the shift amount is negative, it
shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pshl (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 & MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW & MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = DSP_ALU_DST_HW == 0;
  overflow_bit = 0x0;

  #include "shift_dc_bit.c"
}
</span>
</span>
</label>
<input type="checkbox" id="row435" />
<label class="summary DSP" for="row435">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pshl	Sx,Sy,Dz</span>
<span>If DC = 1 & Sy &gt;= 0: Sx &lt;&lt; Sy → Dz, clear LSW of Dz
If DC = 1 & Sy &lt; 0: Sx &gt;&gt; Sy → Dz, clear LSW of Dz
If DC = 0: nop</span>
<span id="111110**********_10000010xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10000010</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally logically shifts the top word contents of the Sx operand, stores
the result in the top word of the Dz operand, and clears the bottom word of the
Dz operand with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the Sy operand. When
the shift amount is positive, it shifts left. When the shift amount is negative,
it shifts right.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits are not updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pshl_dct
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 & MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW & MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row436" />
<label class="summary DSP" for="row436">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pshl	Sx,Sy,Dz</span>
<span>If DC = 0 & Sy &gt;= 0: Sx &lt;&lt; Sy → Dz, clear LSW of Dz
If DC = 0 & Sy &lt; 0: Sx &gt;&gt; Sy → Dz, clear LSW of Dz
If DC = 1: nop</span>
<span id="111110**********_10000011xxyyzzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">10000011</span><span title="ALU Source Register 1 (A0, A1, X0, X1)">xx</span><span title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally logically shifts the top word contents of the Sx operand, stores
the result in the top word of the Dz operand, and clears the bottom word of the
Dz operand with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the Sy operand. When
the shift amount is positive, it shifts left. When the shift amount is negative,
it shifts right.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits are not updated.

<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pshl_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 & MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW & MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row437" />
<label class="summary DSP" for="row437">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pshl		#imm,Dz</span>
<span>If imm &gt;= 0: Dz &lt;&lt; imm → Dz, clear LSW of Dz
If imm &lt; 0: Dz &gt;&gt; imm, clear LSW of Dz</span>
<span id="111110**********_00010iiiiiiizzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">00010</span><span title="Unsigned Immediate Data (7 bits)">iiiiiii</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span>Update → DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Logically shifts the top word contents of the Dz operand, stores the result in
the top word of the Dz operand, and clears the bottom word of the Dz operand
with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the immediate value.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The DC bit of the DSR register is updated according to the specifications for
the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void pshl_imm (void)
{
  unsigned short tmp_imm;
  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];
  switch (ex2_dz_no)
  {
  case 0x0:
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x1:
    DSP_ALU_SRC1G = A1G;
    break;

  default:
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
  }

  tmp_imm = ((EX2_LW &gt;&gt; 4) & MASK0000003F); // bit[9:4]
  if ((tmp_imm & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt; 16
    char cnt = tmp_imm & MASK001F;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\n", tmp_imm);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~tmp_imm & MASK001F) + 1;
    if (cnt &gt; 16)
    {
      printf ("\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\n", tmp_imm);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = DSP_ALU_DST_HW == 0;
  overflow_bit = 0x0;

  #include "shift_dc_bit.c"
}
</span>
</span>
</label>
<br/><br/><br/><b>DSP System Control Instructions</b><br/><br/>
<input type="checkbox" id="row438" />
<label class="summary DSP" for="row438">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>plds		Dz,MACH</span>
<span>Dz → MACH</span>
<span id="111110**********_111011010000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">111011010000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the Dz operand in the MACH register.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void plds_mach (void)
{
  MACH = DSP_REG[ex2_dz_no];
}
</span>
</span>
</label>
<input type="checkbox" id="row439" />
<label class="summary DSP" for="row439">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>plds		Dz,MACL</span>
<span>Dz → MACL</span>
<span id="111110**********_111111010000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">111111010000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the Dz operand in the MACL register.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void plds_macl (void)
{
  MACL = DSP_REG[ex2_dz_no];
}
</span>
</span>
</label>
<input type="checkbox" id="row440" />
<label class="summary DSP" for="row440">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct plds	Dz,MACH</span>
<span>If DC = 1: Dz → MACH
Else: nop</span>
<span id="111110**********_111011100000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">111011100000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Dz operand in the MACH register.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void plds_mach_dct (void)
{
  if (DC == 1)
    MACH = DSP_REG[ex2_dz_no];
}
</span>
</span>
</label>
<input type="checkbox" id="row441" />
<label class="summary DSP" for="row441">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct plds	Dz,MACL</span>
<span>If DC = 1: Dz → MACL
Else: nop</span>
<span id="111110**********_111111100000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">111111100000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Dz operand in the MACL register.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void plds_macl_dct (void)
{
  if (DC == 1)
    MACL = DSP_REG[ex2_dz_no];
}
</span>
</span>
</label>
<input type="checkbox" id="row442" />
<label class="summary DSP" for="row442">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf plds	Dz,MACH</span>
<span>If DC = 0: Dz → MACH
Else: nop</span>
<span id="111110**********_111011110000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">111011110000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Dz operand in the MACH register.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void plds_mach_dcf (void)
{
  if (DC == 0)
    MACH = DSP_REG[ex2_dz_no];
}
</span>
</span>
</label>
<input type="checkbox" id="row443" />
<label class="summary DSP" for="row443">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf plds	Dz,MACL</span>
<span>If DC = 0: Dz → MACL
Else: nop</span>
<span id="111110**********_111111110000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">111111110000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the Dz operand in the MACL register.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void plds_macl_dcf (void)
{
  if (DC == 0)
    MACL = DSP_REG[ex2_dz_no];
}
</span>
</span>
</label>
<input type="checkbox" id="row444" />
<label class="summary DSP" for="row444">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psts		MACH,Dz</span>
<span>MACH → Dz</span>
<span id="111110**********_110011010000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">110011010000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the contents of the MACH register in the Dz operand.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psts_mach (void)
{
  DSP_REG[ex2_dz_no] = MACH;
  if (ex2_dz_no == 0)
  {
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G |= MASKFFFFFF00;
  }
  else if (ex2_dz_no == 1)
  {
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G |= MASKFFFFFF00;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row445" />
<label class="summary DSP" for="row445">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psts		MACL,Dz</span>
<span>MACL → Dz</span>
<span id="111110**********_110111010000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">110111010000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Stores the contents of the MACL register in the Dz operand.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psts_macl (void)
{
  DSP_REG[ex2_dz_no] = MACL;
  if (ex2_dz_no == 0)
  {
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G |= MASKFFFFFF00;
  }
  else if (ex2_dz_no == 1)
  {
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G |= MASKFFFFFF00;
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row446" />
<label class="summary DSP" for="row446">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psts	MACH,Dz</span>
<span>If DC = 1: MACH → Dz
Else: nop</span>
<span id="111110**********_110011100000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">110011100000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the contents of the MACH register in the Dz operand.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psts_mach_dct (void)
{
  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = MACH;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row447" />
<label class="summary DSP" for="row447">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psts	MACL,Dz</span>
<span>If DC = 1: MACL → Dz
Else: nop</span>
<span id="111110**********_110111100000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">110111100000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the contents of the MACL register in the Dz operand.
The instruction is executed if the DC bit is set to 1.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psts_macl_dct (void)
{
  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = MACL;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row448" />
<label class="summary DSP" for="row448">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psts	MACH,Dz</span>
<span>If DC = 0: MACH → Dz
Else: nop</span>
<span id="111110**********_110011110000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">110011110000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the contents of the MACH register in the Dz operand.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psts_mach_dcf (void)
{
  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = MACH;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
<input type="checkbox" id="row449" />
<label class="summary DSP" for="row449">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psts	MACL,Dz</span>
<span>If DC = 0: MACL → Dz
Else: nop</span>
<span id="111110**********_110111110000zzzz" class="colorized"><span title="Opcode Identifier">111110</span><span title="Ignored">**********</span> <span title="Opcode Identifier">110111110000</span><span title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</span></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<br />
<br />Conditionally stores the contents of the MACL register in the Dz operand.
The instruction is executed if the DC bit is set to 0.
The DC, N, Z, V, and GT bits of the DSR register are not updated.
<br /><br />
<span title="section">Note</span>
<br />
<br />Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.
<br /><br />
<span title="section">Operation</span>
<br />
<span title="code">void psts_macl_dcf (void)
{
  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = MACL;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}
</span>
</span>
</label>
</body>
</html>
