<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Hitachi SuperH Instruction Set Summary</title>
<style>
:root
{
  --table-width: 1490px;
  --details-width: 820px;
}

@media (prefers-color-scheme : light)
{
  .image_filter {} /* no filtering needed */

  :root
  {
    --system-background-color: #FFFFFF;
    --system-text-color: #000000;

    --table-background-color: #FFFFFF;
    --table-text-color: #000000;
    --table-background-hover-color: #F0F0F0;
    --table-image-hover-color: #F0F0F0;

    --header-background-color: #D0D0D0;
    --header-text-color: #000000;

    --grid-inactive-text-color: #C0C0C0;
    --grid-cell-background-color: #F4F4F4;

    --cpu-grid-active-text-color: #404040;
    --cycle-grid-active-text-color: #000000;

    --mnemonic-text-color: #FF0000;
  }

  var[title="Ignored"]                          { color: goldenrod; }
  var[title="Opcode Identifier"]                { color: dodgerblue; }
  var[title="A"]                                { color: darkgreen; }
  var[title="D"]                                { color: darkmagenta; }
  var[title^='Unsigned Immediate Data']         { color: darkturquoise; }
  var[title^='Signed Immediate Data']           { color: darkturquoise; }
  var[title^='Source Register']                 { color: aquamarine; }
  var[title^='Destination Register']            { color: blueViolet; }
  var[title^='Displacement']                    { color: indigo; }
  var[title^='Multiplier Source Register 1']    { color: cyan; }
  var[title^='Multiplier Source Register 2']    { color: chartreuse; }
  var[title^='Multiplier Destination Register'] { color: darkcyan; }
  var[title^='ALU Source Register 1']           { color: darkmagenta; }
  var[title^='ALU Source Register 2']           { color: darkorange; }
  var[title^='ALU Destination Register']        { color: indianred; }
  var[title^='ALU Destination Register']        { color: forestgreen; }
}

@media (prefers-color-scheme : dark)
{
  .image_filter /* invert colors */
  {
    filter: invert(100%);
  }

  :root
  {
    --system-background-color: #000000;
    --system-text-color: #FFFFFF;

    --table-background-color: #000000;
    --table-text-color: #FFFFFF;
    --table-background-hover-color: #404040;
    --table-image-hover-color: #C0C0C0;

    --header-background-color: #606060;
    --header-text-color: #FFFFFF;

    --grid-inactive-text-color: #707070;
    --grid-cell-background-color: #303030;

    --cpu-grid-active-text-color: #C0C0C0;
    --cycle-grid-active-text-color: #FFFFFF;

    --mnemonic-text-color: #FF8888;
  }

  var[title="Ignored"]                          { color: gold; }
  var[title="Opcode Identifier"]                { color: #55ff55; }
  var[title="A"]                                { color: lightseagreen; }
  var[title="D"]                                { color: olive; }
  var[title^='Unsigned Immediate Data']         { color: #aaaaff; }
  var[title^='Signed Immediate Data']           { color: #aaaaff; }
  var[title^='Source Register']                 { color: #ffff55; }
  var[title^='Destination Register']            { color: #f92672; }
  var[title^='Displacement']                    { color: coral; }
  var[title^='Multiplier Source Register 1']    { color: cyan; }
  var[title^='Multiplier Source Register 2']    { color: chartreuse; }
  var[title^='Multiplier Destination Register'] { color: darkcyan; }
  var[title^='ALU Source Register 1']           { color: darkorange; }
  var[title^='ALU Source Register 2']           { color: deeppink; }
  var[title^='ALU Destination Register']        { color: darkmagenta; }
  var[title^='ALU Destination Register']        { color: forestgreen; }
}

var, section, q, q::before, q::after
{ all: unset; }

body
{
  background-color: var(--system-background-color);
  color: var(--system-text-color);
  font-size: 15px;
  padding-left: calc(50% - var(--table-width) / 2); /* center everything */
  height: 25000px; /* for sticky header */
  margin: 0px;
}

#header
{
  background-color: var(--system-background-color);
  color: var(--system-text-color);
  width: var(--table-width);
}

#table_header
{
  position: sticky !important;
  top: 0px;
  height: 85px;
  z-index: 100;
  font-weight: 700;
  font-style: italic;
  background-color: var(--header-background-color);
  color: var(--header-text-color)
}

.section_title
{
  display: block;
  font-weight: 900;
  padding-bottom: 0.5em;
  padding-top: 2em;
}

input[id^="cb_" ]::after { content:attr(name); }

#cb_SH1:checked  ~ label.SH1,
#cb_SH2:checked  ~ label.SH2,
#cb_SH2E:checked ~ label.SH2E,
#cb_SH2A:checked ~ label.SH2A,
#cb_SH2A:checked ~ label.SH2A_FPU,
#cb_SH3:checked  ~ label.SH3,
#cb_SH3E:checked ~ label.SH3_FPU,
#cb_DSP:checked  ~ label.SH1_DSP,
#cb_DSP:checked  ~ label.SH1_DSP,
#cb_DSP:checked  ~ label.SH2_DSP,
#cb_SH4:checked  ~ label.SH4,
#cb_SH4A:checked ~ label.SH4A
{ display: inline-grid; }

label.summary { display: none; }

input[id^="cb_" ]
{
  position: sticky;
  z-index: 1000;
  padding-left: 30px;
}

input[id^="row"] { display: none; }
input[id^="row"]:checked + label > .details
  { display: unset; }

.summary
{
  background-color: var(--table-background-color);
  color: var(--table-text-color);
  clear: both;
}

label.summary > .colorized
{
  font-family: monospace;
  word-wrap: break-word;
}

label.summary > .colorized > var
  { display: contents; }

label.summary > span:not(.details)
{
  padding-right: 20px;
  border-top-width: 1px;
  border-top-style: dotted;
  font-family: monospace;
  font-size: 13px;
}

.summary > span:not(.details):nth-child(2)
{
  white-space: pre-wrap;
}

.summary > span:not(.details):nth-child(1) { padding-left: 10px; }
.summary > span:not(.details):nth-child(3)
{
  white-space: pre-wrap;
  padding-right: 30px;
}


/* links hover events */
label.summary:hover > *,
.details:hover > *,
.details:hover + .summary
{ background-color: var(--table-background-hover-color); }

/* keep images readable */
label.summary:hover img,
.details:hover img
{ background-color: var(--table-image-hover-color) !important; }

.summary
{
  display: inline-grid;
  grid-template-columns: 150px 240px 470px 150px 130px 120px 120px 110px;
}

/* all columns */
.summary > span
{
  vertical-align: middle;
  display: inline-block;
}

.cpu_grid, .cycle_grid
{
  display: inline-grid !important;
  grid-gap: 2px;
  grid-template-columns: 33px 33px 33px;
  grid-template-rows: 13px 13px 13px;
  font-family: monospace;
  font-size: 11px;
  font-weight: unset;
  font-style: unset;
}

.cpu_grid > var, .cycle_grid > var
{
  color: transparent;
  background-color: var(--grid-cell-background-color);
  display: block;
  text-align: center;
  padding: 0px;
  margin: 0px;
  height: 13px;
}

.cpu_grid > var:nth-of-type(1):before { content:"SH1"  ; }
.cpu_grid > var:nth-of-type(2):before { content:"SH2"  ; }
.cpu_grid > var:nth-of-type(3):before { content:"SH2E" ; }
.cpu_grid > var:nth-of-type(4):before { content:"SH2A" ; }
.cpu_grid > var:nth-of-type(5):before { content:"SH3"  ; }
.cpu_grid > var:nth-of-type(6):before { content:"SH3E" ; }
.cpu_grid > var:nth-of-type(7):before { content:"SH4"  ; }
.cpu_grid > var:nth-of-type(8):before { content:"SH4A" ; }
.cpu_grid > var:nth-of-type(9):before { content:"DSP"  ; }


#cb_SH1:checked  ~ .summary .cpu_grid > var:nth-of-type(1),
#cb_SH2:checked  ~ .summary .cpu_grid > var:nth-of-type(2),
#cb_SH2E:checked ~ .summary .cpu_grid > var:nth-of-type(3),
#cb_SH2A:checked ~ .summary .cpu_grid > var:nth-of-type(4),
#cb_SH3:checked  ~ .summary .cpu_grid > var:nth-of-type(5),
#cb_SH3E:checked ~ .summary .cpu_grid > var:nth-of-type(6),
#cb_SH4:checked  ~ .summary .cpu_grid > var:nth-of-type(7),
#cb_SH4A:checked ~ .summary .cpu_grid > var:nth-of-type(8),
#cb_DSP:checked  ~ .summary .cpu_grid > var:nth-of-type(9)
{ color: var(--grid-inactive-text-color); }

#cb_SH1:checked  ~ .summary.SH1       .cpu_grid > var:nth-of-type(1),
#cb_SH2:checked  ~ .summary.SH2       .cpu_grid > var:nth-of-type(2),
#cb_SH2E:checked ~ .summary.SH2E      .cpu_grid > var:nth-of-type(3),
#cb_SH2A:checked ~ .summary.SH2A      .cpu_grid > var:nth-of-type(4),
#cb_SH2A:checked ~ .summary.SH2A_FPU  .cpu_grid > var:nth-of-type(4), /* show FPU instructions too */
#cb_SH3:checked  ~ .summary.SH3       .cpu_grid > var:nth-of-type(5),
#cb_SH3E:checked ~ .summary.SH3       .cpu_grid > var:nth-of-type(6),
#cb_SH3E:checked ~ .summary.SH3_FPU   .cpu_grid > var:nth-of-type(6), /* show FPU instructions too */
#cb_SH4:checked  ~ .summary.SH4       .cpu_grid > var:nth-of-type(7),
#cb_SH4A:checked ~ .summary.SH4A      .cpu_grid > var:nth-of-type(8),
#cb_DSP:checked  ~ .summary.SH1_DSP   .cpu_grid > var:nth-of-type(9), /* show DSP instructions too */
#cb_DSP:checked  ~ .summary.SH2_DSP   .cpu_grid > var:nth-of-type(9),
#cb_DSP:checked  ~ .summary.SH3_DSP   .cpu_grid > var:nth-of-type(9)
{ color: var(--cpu-grid-active-text-color); }

#cb_SH1:checked  ~ .summary.SH1       .cycle_grid > var:nth-of-type(1),
#cb_SH2:checked  ~ .summary.SH2       .cycle_grid > var:nth-of-type(2),
#cb_SH2E:checked ~ .summary.SH2E      .cycle_grid > var:nth-of-type(3),
#cb_SH2A:checked ~ .summary.SH2A      .cycle_grid > var:nth-of-type(4),
#cb_SH2A:checked ~ .summary.SH2A_FPU  .cycle_grid > var:nth-of-type(4), /* show FPU instructions too */
#cb_SH3:checked  ~ .summary.SH3       .cycle_grid > var:nth-of-type(5),
#cb_SH3E:checked ~ .summary.SH3       .cycle_grid > var:nth-of-type(6),
#cb_SH3E:checked ~ .summary.SH3_FPU   .cycle_grid > var:nth-of-type(6), /* show FPU instructions too */
#cb_SH4:checked  ~ .summary.SH4       .cycle_grid > var:nth-of-type(7),
#cb_SH4A:checked ~ .summary.SH4A      .cycle_grid > var:nth-of-type(8),
#cb_DSP:checked  ~ .summary.SH1_DSP   .cycle_grid > var:nth-of-type(9), /* show DSP instructions too */
#cb_DSP:checked  ~ .summary.SH2_DSP   .cycle_grid > var:nth-of-type(9),
#cb_DSP:checked  ~ .summary.SH3_DSP   .cycle_grid > var:nth-of-type(9)
{ color: var(--cycle-grid-active-text-color); }

/* styling for details section */
.summary > .details
{
  border: unset;
  display: none;
  padding: 10px calc(var(--table-width) - var(--details-width) - 30px) 10px 30px;
  width: var(--details-width);
}

.summary > .details > span
  { display: block; }

.summary > .details > span:first-of-type
  { padding-top: 0em !important; }

.summary > .details > span[title="operation"],
.summary > .details > span[title="assembly"]
{
  font-size: 13px;
  font-family: monospace;
  white-space: pre;
}

.summary > .details > span[title="section"]
{
  padding-bottom: 0.5em;
  padding-top: 1em;
  font-style: italic;
  font-weight: 700;
}

.summary > .details > span[title="section"] > em
{ color: var(--mnemonic-text-color); }


span[title="list"]
{
  list-style-type: circle;
}

span[title="list"] > var
{
  font-style: unset;
  display: list-item;
}

input[id="radio_math"]:checked ~ var[title="for all"]::before { content: "∀"; }

input[id="radio_math"]:checked ~ .summary var[title="greater than or equal"]::before { content: "≤"; }
input[id="radio_math"]:checked ~ .summary var[title="less than or equal"]::before { content: "≥"; }
input[id="radio_math"]:checked ~ .summary var[title="equality"]::before { content: "="; }
input[id="radio_math"]:checked ~ .summary var[title="shift bits left"]::before { content: "«"; }
input[id="radio_math"]:checked ~ .summary var[title="shift bits right"]::before { content: "»"; }
input[id="radio_math"]:checked ~ .summary var[title="binary or"]::before { content: "∨"; }
input[id="radio_math"]:checked ~ .summary var[title="binary and"]::before { content: "∧"; }
input[id="radio_math"]:checked ~ .summary var[title="binary xor"]::before { content: "⊕"; }
input[id="radio_math"]:checked ~ .summary var[title="binary not"]::before { content: "¬"; }
input[id="radio_math"]:checked ~ .summary var[title="double prime"]::after { content: "″"; }
input[id="radio_math"]:checked ~ .summary var[title="prime"]::after { content: "′"; }
input[id="radio_math"]:checked ~ .summary var[title="subtract"]::before { content: "−"; }
input[id="radio_math"]:checked ~ .summary var[title="square root"]::before { content: "√("; }
input[id="radio_math"]:checked ~ .summary var[title="square root"]::after { content: ")"; }
/* input[id="radio_math"]:checked ~ .summary var[title="divide"]::before { content: "÷"; } */
input[id="radio_math"]:checked ~ .summary var[title="multiply"]::before { content: "×"; }
input[id="radio_math"]:checked ~ .summary var[title="absolute value"]::before { content: "|"; }
input[id="radio_math"]:checked ~ .summary var[title="absolute value"]::after { content: "|"; }


input[id="radio_C"]:checked ~ .summary var[title="greater than or equal"]::before { content: ">="; }
input[id="radio_C"]:checked ~ .summary var[title="less than or equal"]::before { content: "<="; }
input[id="radio_C"]:checked ~ .summary var[title="equality"]::before { content: "=="; }
input[id="radio_C"]:checked ~ .summary var[title="shift bits left"]::before { content: "<<"; }
input[id="radio_C"]:checked ~ .summary var[title="shift bits right"]::before { content: ">>"; }
input[id="radio_C"]:checked ~ .summary var[title="binary or"]::before { content: "|"; }
input[id="radio_C"]:checked ~ .summary var[title="binary and"]::before { content: "&"; }
input[id="radio_C"]:checked ~ .summary var[title="binary xor"]::before { content: "^"; }
input[id="radio_C"]:checked ~ .summary var[title="binary not"]::before { content: "~"; }
input[id="radio_C"]:checked ~ .summary var[title="double prime"]::after { content: "’’"; }
input[id="radio_C"]:checked ~ .summary var[title="prime"]::after { content: "’"; }
input[id="radio_C"]:checked ~ .summary var[title="subtract"]::before { content: "-"; }
input[id="radio_C"]:checked ~ .summary var[title="square root"]::before { content: "sqrt("; }
input[id="radio_C"]:checked ~ .summary var[title="square root"]::after { content: ")"; }
/* input[id="radio_C"]:checked ~ .summary var[title="divide"]::before { content: "/"; } */
input[id="radio_C"]:checked ~ .summary var[title="multiply"]::before { content: "*"; }
input[id="radio_C"]:checked ~ .summary var[title="absolute value"]::before { content: "abs("; }
input[id="radio_C"]:checked ~ .summary var[title="absolute value"]::after { content: ")"; }


var[title="divide"]::before { content: "/"; }
var[title="greater than"]::before { content: ">"; }
var[title="less than"]::before { content: "<"; }
var[title="store into (right)"]::before { content: "→"; }
var[title="store into (left)"]::before { content: "←"; }
var[title="add"]::before { content: "+"; }

</style>
</head>
<body>
  <div id="header">
    <span style="font-size:20px;font-weight:700">Hitachi SuperH Instruction Set Summary</span>
    <div style="float:right">Last updated: Aug 28 2022 11:04:01</div>
    <br />
    <div style="float:right">
      <a href="https://github.com/SaturnOpenSDK/sh_insns">Page Source</a>
    </div>
  </div>
  <input type="radio" id="radio_C" name="symbols" checked /><label for="radio_C">C programming Symbols</label>
  <input type="radio" id="radio_math" name="symbols" /><label for="radio_math">Mathematic Symbols</label>
  <br />
  <select name="CPUtype">
    <option value="Grid">Show Grid</option>
    <option value="SH1">SuperH 1</option>
    <option value="SH2">SuperH 2</option>
    <option value="SHDSP">SuperH DSP</option>
    <option value="SH2E">SuperH 2E</option>
    <option value="SH2A">SuperH 2A without FPU</option>
    <option value="SH2A_FPU">SuperH 2A with FPU</option>

    <option value="SH3">SuperH 3</option>
    <option value="SH3_FPU">SuperH 3E (3 with FPU)</option>
    <option value="SH3_DSP">SuperH 3-DSP</option>
  </select>
  <br />
  <input type="checkbox" id="cb_SH1" name="SH1" checked /><label for="cb_SH1">SH1</label>
  <input type="checkbox" id="cb_DSP" name="DSP" checked /><label for="cb_DSP">DSP</label>
  <input type="checkbox" id="cb_SH2" name="SH2" checked /><label for="cb_SH2">SH2</label>
  <input type="checkbox" id="cb_SH2E" name="SH2E" checked /><label for="cb_SH2E">SH2E</label>
  <input type="checkbox" id="cb_SH2A" name="SH2A" checked /><label for="cb_SH2A">SH2A</label>
  <input type="checkbox" id="cb_SH3" name="SH3" checked /><label for="cb_SH3">SH3</label>
  <input type="checkbox" id="cb_SH3E" name="SH3E" checked /><label for="cb_SH3E">SH3E</label>
  <input type="checkbox" id="cb_SH4" name="SH4" checked /><label for="cb_SH4">SH4</label>
  <input type="checkbox" id="cb_SH4A" name="SH4A" checked /><label for="cb_SH4A">SH4A</label>
    <span id="table_header" class="summary SH1 DSP SH2 SH2E SH2A SH3 SH3E SH4 SH4A">
    <span>Compatibilty</span>
    <span>Format</span>
    <span>Abstract</span>
    <span>Code</span>
    <span>Bit Flags</span>
    <span>Instruction Group
      <span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
    </span>
    <span>Issue Cycles
      <span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
    </span>
    <span>Latency Cycles
      <span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
    </span>
  </span><span class="section_title">Data Transfer Instructions</span>
<input name="instruction" type="radio" id="row0" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row0">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov       Rm,Rn</span>
<span>Rm <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm0011" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>MT</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOV (int m, int n)
{
  R[n] = R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov r0,r1 ! Before execution: r0 = 0xFFFFFFFF, r1 = 0x00000000 
          ! After execution:  r1 = 0xFFFFFFFF</span>
</span>
</label>
<input name="instruction" type="radio" id="row1" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row1">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov       #imm,Rn</span>
<span>imm <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="1110nnnniiiiiiii" class="colorized"><var title="Opcode Identifier">1110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>MT</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Constant Value</span>
<span title="note">Stores immediate data, sign-extended to longword, in general register Rn.</span>
<span title="section">Operation</span>
<span title="operation">void MOVI (int i, int n)
{
  if ((i & 0x80) == 0)
    R[n] = (0x000000FF & i);
  else
    R[n] = (0xFFFFFF00 | i);

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">1000       mov     #0x80,r1   ! r1 = 0xFFFFFF80                                                        
1002       mov.w   IMM,r2     ! r2 = 0xFFFF9ABC, IMM means @(0x08,PC)                                  
1004       add     #-1,r0                                                                              
1006       tst     r0,r0      ! ← PC location used for address calculation for the MOV.W instruction 
1008       movt    r13                                                                                 
100A       bra     NEXT       ! Delayed branch instruction                                             
100C       mov.l   @(4,PC),r3 ! r3 = 0x12345678                                                        
100E IMM:  .data.w 0x9ABC                                                                              
1010       .data.w 0x1234                                                                              
1012 NEXT: jmp     @r3        ! Branch destination of the BRA instruction                              
1014       cmp/eq  #0,r0      ! ← PC location used for address calculation for the MOV.L instruction 
           .align  4                                                                                   
1018       .data.l 0x12345678</span>
</span>
</label>
<input name="instruction" type="radio" id="row2" />
<label class="summary SH2A" for="row2">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movi20    #imm20,Rn</span>
<span>imm <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0000nnnniiii0000iiiiiiiiiiiiiiii" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Unsigned Immediate Data (20 bits)">iiii</var><var title="Opcode Identifier">0000</var><var title="Unsigned Immediate Data (20 bits)">iiiiiiiiiiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>I</em>mmediate <em>20</em> bits of data</span>
<span title="note">Stores immediate data that has been sign-extended to longword in general
register Rn.
<br /><img alt="Move Immediate 20 bits of data" class="image_filter" src="movi20.svg" height="140" /></span>
<span title="section">Operation</span>
<span title="operation">void MOVI20 (int i, int n)
{
  if (i & 0x00080000) == 0)
    R[n] = (0x000FFFFF & (long)i);
  else
    R[n] = (0xFFF00000 | (long)i);

  PC += 4;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row3" />
<label class="summary SH2A" for="row3">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movi20s   #imm20,Rn</span>
<span>imm <var title="shift bits left"></var> 8 <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0000nnnniiii0001iiiiiiiiiiiiiiii" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Unsigned Immediate Data (20 bits)">iiii</var><var title="Opcode Identifier">0001</var><var title="Unsigned Immediate Data (20 bits)">iiiiiiiiiiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>I</em>mmediate <em>20</em> bits of data and <em>S</em>hift Left 8 bits</span>
<span title="note">Shifts immediate data 8 bits to the left and performs sign extension to
longword, then stores the resulting data in general register Rn. Using an OR or
ADD instruction as the next instruction enables a 28-bit absolute address to be
generated.
<br /><img alt="Move Immediate 20 bits of data and Shift Left 8 bits" class="image_filter" src="movi20s.svg" height="150" /></span>
<span title="section">Operation</span>
<span title="operation">void MOVI20S (int i, int n)
{
  if (i & 0x00080000) == 0)
    R[n] = (0x000FFFFF & (long)i);
  else
    R[n] = (0xFFF00000 | (long)i);

  R[n] &lt;&lt;= 8;
  PC += 4;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row4" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row4">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mova      @(disp,PC),R0</span>
<span>(disp <var title="multiply"></var> 4) <var title="add"></var> (PC <var title="binary and"></var> 0xFFFFFFFC) <var title="add"></var> 4 <var title="store into (right)"></var> R0</span>
<span id="11000111dddddddd" class="colorized"><var title="Opcode Identifier">11000111</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Effective <em>A</em>ddress</span>
<span title="note">Stores the effective address of the source operand into general
register R0.  The 8-bit displacement is zero-extended and quadrupled.
Consequently, the relative interval from the operand is <abbr title="Program Counter">PC</abbr> + 1020 bytes.  The <abbr title="Program Counter">PC</abbr>
is the address four bytes after this instruction, but the lowest two bits of the
<abbr title="Program Counter">PC</abbr> are fixed at 00.</span>
<span title="section">Note</span>
<span title="note">SH1*, SH2*, SH3*:<br />
If this instruction is placed immediately after a delayed branch instruction,
the <abbr title="Program Counter">PC</abbr> must point to an address specified by (the starting address of the branch
destination) + 2.<br /><br />

SH4*:<br />
If this instruction is executed in a delay slot, a slot illegal instruction
exception will be generated.</span>
<span title="section">Operation</span>
<span title="operation">void MOVA (int d)
{
  unsigned int disp;
  disp = (unsigned int)(0x000000FF & d);
  R[0] = (PC & 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">          .org   0x1006                                                                                   
1006      mova   STR,r0       ! Address of STR → r0                                                     
1008      mov.b  @r0,r1       ! r1 = “X” ← PC location after correcting the lowest two bits         
100A      add    r4,r5        ! ← Original PC location for address calculation for the MOVA instruction 
          .align 4                                                                                        
100C STR: .sdata “XYZP12”                                                                             
2002      bra    TARGET       ! Delayed branch instruction                                                
2004      mova   @(0,PC),r0   ! Address of TARGET + 2 → r0                                              
2006      nop</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row5" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row5">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @(disp,PC),Rn</span>
<span>(disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="1001nnnndddddddd" class="colorized"><var title="Opcode Identifier">1001</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Constant Value</span>
<span title="note">Stores immediate data, sign-extended to longword, in general register Rn.
The data is stored from memory address (<abbr title="Program Counter">PC</abbr> + 4 + displacement × 2).
The 8-bit displacement is multiplied by two after zero-extension, and so the
relative distance from the table is in the range up to <abbr title="Program Counter">PC</abbr> + 4 + 510 bytes. The
<abbr title="Program Counter">PC</abbr> value is the address of this instruction.</span>
<span title="section">Note</span>
<span title="note">If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWI (int d, int n)
{
  unsigned int disp = (0x000000FF & d);
  R[n] = Read_16 (PC + 4 + (disp &lt;&lt; 1));
  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Slot illegal instruction exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row6" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row6">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @(disp,PC),Rn</span>
<span>(disp <var title="multiply"></var> 4 <var title="add"></var> (PC <var title="binary and"></var> 0xFFFFFFFC) <var title="add"></var> 4) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="1101nnnndddddddd" class="colorized"><var title="Opcode Identifier">1101</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Constant Value</span>
<span title="note">Stores immediate data, sign-extended to longword, in general register Rn.
The data is stored from memory address (<abbr title="Program Counter">PC</abbr> + 4 + displacement × 4).
The 8-bit displacement is multiplied by four after zero-extension, and so the
relative distance from the operand is in the range up to <abbr title="Program Counter">PC</abbr> + 4 + 1020 bytes.
The <abbr title="Program Counter">PC</abbr> value is the address of this instruction. A value with the lower 2 bits
adjusted to 00 is used in address calculation.</span>
<span title="section">Note</span>
<span title="note">If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLI (int d, int n)
{
  unsigned int disp = (0x000000FF & d);
  R[n] = Read_32 ((PC & 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2));
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Slot illegal instruction exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row7" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row7">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @Rm,Rn</span>
<span>(Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm0000" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Note</span>
<span title="note">MOV.B @R0,R1 ;Before execution: @R0 = H'80, R1 = H'00000000
;After execution: R1 = H'FFFFFF80</span>
<span title="section">Operation</span>
<span title="operation">void MOVBL (int m, int n)
{
  R[n] = Read_8 (R[m]);
  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row8" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row8">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @Rm,Rn</span>
<span>(Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm0001" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWL (int m, int n)
{
  R[n] = Read_16 (R[m]);
  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row9" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row9">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @Rm,Rn</span>
<span>(Rm) <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm0010" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLL (int m, int n)
{
  R[n] = Read_32 (R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row10" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row10">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     Rm,@Rn</span>
<span>Rm <var title="store into (right)"></var> (Rn)</span>
<span id="0010nnnnmmmm0000" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBS (int m, int n)
{
  Write_8 (R[n], R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row11" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row11">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     Rm,@Rn</span>
<span>Rm <var title="store into (right)"></var> (Rn)</span>
<span id="0010nnnnmmmm0001" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWS (int m, int n)
{
  Write_16 (R[n], R[m]);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.w r0,@r1 ! Before execution: r0 = 0xFFFF7F80 
             ! After execution:  @r1 = 0x7F80</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row12" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row12">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     Rm,@Rn</span>
<span>Rm <var title="store into (right)"></var> (Rn)</span>
<span id="0010nnnnmmmm0010" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLS (int m, int n)
{
  Write_32 (R[n], R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row13" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row13">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @Rm+,Rn</span>
<span>(Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn, Rm<var title="add"></var>1 <var title="store into (right)"></var> Rm</span>
<span id="0110nnnnmmmm0100" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBP (int m, int n)
{
  R[n] = Read_8 (R[m]);
  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  if (n != m)
    R[m] += 1;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row14" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row14">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @Rm+,Rn</span>
<span>(Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn, Rm<var title="add"></var>2 <var title="store into (right)"></var> Rm</span>
<span id="0110nnnnmmmm0101" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWP (int m, int n)
{
  R[n] = Read_16 (R[m]);
  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  if (n != m)
    R[m] += 2;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row15" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row15">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @Rm+,Rn</span>
<span>(Rm) <var title="store into (right)"></var> Rn, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0110nnnnmmmm0110" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLP (int m, int n)
{
  R[n] = Read_32 (R[m]);

  if (n != m)
    R[m] += 4;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.l @r0+,r1 ! Before execution: r0 = 0x12345670                   
              ! After execution:  r0 = 0x12345674, r1 = @0x12345670</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row16" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row16">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     Rm,@-Rn</span>
<span>Rn<var title="subtract"></var>1 <var title="store into (right)"></var> Rn, Rm <var title="store into (right)"></var> (Rn)</span>
<span id="0010nnnnmmmm0100" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBM (int m, int n)
{
  Write_8 (R[n] - 1, R[m]);
  R[n] -= 1;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row17" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row17">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     Rm,@-Rn</span>
<span>Rn<var title="subtract"></var>2 <var title="store into (right)"></var> Rn, Rm <var title="store into (right)"></var> (Rn)</span>
<span id="0010nnnnmmmm0101" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWM (int m, int n)
{
  Write_16 (R[n] - 2, R[m]);
  R[n] -= 2;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.w r0,@-r1 ! Before execution: r0 = 0xAAAAAAAA, r1 = 0xFFFF7F80 
              ! After execution:  r1 = 0xFFFF7F7E, @r1 = 0xAAAA</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row18" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row18">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     Rm,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, Rm <var title="store into (right)"></var> (Rn)</span>
<span id="0010nnnnmmmm0110" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLM (int m, int n)
{
  Write_32 (R[n] - 4, R[m]);
  R[n] -= 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row19" />
<label class="summary SH2A" for="row19">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @-Rm,R0</span>
<span>Rm<var title="subtract"></var>1 <var title="store into (right)"></var> Rm, (Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> R0</span>
<span id="0100mmmm11001011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11001011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Reverse Stack</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRSBM (int m)
{
  R[m] -= 1;
  R[0] = Read_16 (R[m]);

  if ((R[0] & 0x80) == 0)
    R[0] &= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC+=2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row20" />
<label class="summary SH2A" for="row20">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @-Rm,R0</span>
<span>Rm<var title="subtract"></var>2 <var title="store into (right)"></var> Rm, (Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> R0</span>
<span id="0100mmmm11011011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11011011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Reverse Stack</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRSWM (int m)
{
  R[m]-= 2;
  R[0] = Read_16 (R[m]);

  if ((R[0] & 0x8000) == 0)
    R[0] &= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row21" />
<label class="summary SH2A" for="row21">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @-Rm,R0</span>
<span>Rm<var title="subtract"></var>4 <var title="store into (right)"></var> Rm, (Rm) <var title="store into (right)"></var> R0</span>
<span id="0100mmmm11101011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11101011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Reverse Stack</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRSLM (int m)
{
  R[m] -= 4;
  R[0] = Read_32 (R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row22" />
<label class="summary SH2A" for="row22">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     R0,@Rn+</span>
<span>R0 <var title="store into (right)"></var> (Rn), Rn<var title="add"></var>1 <var title="store into (right)"></var> Rn</span>
<span id="0100nnnn10001011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10001011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Reverse Stack</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRSBP (int n)
{
  Write_8 (R[n], R[0]);
  R[n] += 1;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row23" />
<label class="summary SH2A" for="row23">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     R0,@Rn+</span>
<span>R0 <var title="store into (right)"></var> (Rn), Rn<var title="add"></var>2 <var title="store into (right)"></var> Rn</span>
<span id="0100nnnn10011011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10011011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Reverse Stack</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRSWP (int n)
{
  Write_16 (R[n], R[0]);
  R[n] += 2;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row24" />
<label class="summary SH2A" for="row24">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     R0,@Rn+</span>
<span>R0 <var title="store into (right)"></var> (Rn), Rn<var title="add"></var>4 <var title="store into (right)"></var> Rn</span>
<span id="0100nnnn10101011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10101011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Reverse Stack</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRSLP (int n)
{
  Write_32 (R[n], R[0]);
  R[n] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row25" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row25">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @(disp,Rm),R0</span>
<span>(disp <var title="add"></var> Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> R0</span>
<span id="10000100mmmmdddd" class="colorized"><var title="Opcode Identifier">10000100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Displacement (4 bits)">dddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.
The 4-bit displacement is only zero-extended, so a range up to +15 bytes
can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can
be used instead.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBL4 (int m, int d)
{
  long disp = (0x0000000F & (long)d);
  R[0] = Read_8 (R[m] + disp);

  if ((R[0] & 0x80) == 0)
    R[0] &= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row26" />
<label class="summary SH2A" for="row26">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @(disp12,Rm),Rn</span>
<span>(disp <var title="add"></var> Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm00010100dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010100</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_8 (R[m] + disp);

  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row27" />
<label class="summary SH2A" for="row27">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movu.b    @(disp12,Rm),Rn</span>
<span>(disp <var title="add"></var> Rm) <var title="store into (right)"></var> zero extension <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm00011000dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00011000</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data as <em>U</em>nsigned</span>
<span title="note">Transfers a source operand to a destination, performing unsigned data transfer.
This instruction is ideal for data access in a structure or the stack.
The loaded data is zero-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBUL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_8 (R[m] + disp);
  R[n] &= 0x000000FF;
  PC += 4;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row28" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row28">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @(disp,Rm),R0</span>
<span>(disp <var title="multiply"></var> 2 <var title="add"></var> Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> R0</span>
<span id="10000101mmmmdddd" class="colorized"><var title="Opcode Identifier">10000101</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Displacement (4 bits)">dddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.
The 4-bit displacement is multiplied by two after zero-extension, enabling a
range up to +30 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWL4 (int m, int d)
{
  long disp = (0x0000000F & (long)d);
  R[0] = Read_16 (R[m] + (disp &lt;&lt; 1));

  if ((R[0] & 0x8000) == 0)
    R[0] &= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row29" />
<label class="summary SH2A" for="row29">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @(disp12,Rm),Rn</span>
<span>(disp <var title="multiply"></var> 2 <var title="add"></var> Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm00010101dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010101</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));

  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row30" />
<label class="summary SH2A" for="row30">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movu.w    @(disp12,Rm),Rn</span>
<span>(disp <var title="multiply"></var> 2 <var title="add"></var> Rm) <var title="store into (right)"></var> zero extension <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm00011001dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00011001</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data as <em>U</em>nsigned</span>
<span title="note">Transfers a source operand to a destination, performing unsigned data transfer.
This instruction is ideal for data access in a structure or the stack.
The loaded data is zero-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWUL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));
  R[n] &= 0x0000FFFF;
  PC += 4;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row31" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row31">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @(disp,Rm),Rn</span>
<span>(disp <var title="multiply"></var> 4 <var title="add"></var> Rm) <var title="store into (right)"></var> Rn</span>
<span id="0101nnnnmmmmdddd" class="colorized"><var title="Opcode Identifier">0101</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Displacement (4 bits)">dddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.
The 4-bit displacement is multiplied by four after zero-extension, enabling a
range up to +60 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLL4 (int m, int d, int n)
{
  long disp = (0x0000000F & (long)d);
  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.l @(2,r0),r1 ! Before execution: @(r0 + 8) = 0x12345670 
                 ! After execution:  r1 = 0x12345670</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row32" />
<label class="summary SH2A" for="row32">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @(disp12,Rm),Rn</span>
<span>(disp <var title="multiply"></var> 4 <var title="add"></var> Rm) <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm00010110dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010110</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLL12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row33" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row33">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     R0,@(disp,Rn)</span>
<span>R0 <var title="store into (right)"></var> (disp <var title="add"></var> Rn)</span>
<span id="10000000nnnndddd" class="colorized"><var title="Opcode Identifier">10000000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Displacement (4 bits)">dddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.
The 4-bit displacement is only zero-extended, so a range up to +15 bytes
can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can
be used instead.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBS4 (int d, int n)
{
  long disp = (0x0000000F & (long)d);
  Write_8 (R[n] + disp, R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row34" />
<label class="summary SH2A" for="row34">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     Rm,@(disp12,Rn)</span>
<span>Rm <var title="store into (right)"></var> (disp <var title="add"></var> Rn)</span>
<span id="0011nnnnmmmm00010000dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010000</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBS12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  Write_8 (R[n] + disp, R[m]);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row35" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row35">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     R0,@(disp,Rn)</span>
<span>R0 <var title="store into (right)"></var> (disp <var title="multiply"></var> 2 <var title="add"></var> Rn)</span>
<span id="10000001nnnndddd" class="colorized"><var title="Opcode Identifier">10000001</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Displacement (4 bits)">dddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.
The 4-bit displacement is multiplied by two after zero-extension, enabling a
range up to +30 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWS4 (int d, int n)
{
  long disp = (0x0000000F & (long)d);
  Write_16 (R[n] + (disp &lt;&lt; 1), R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row36" />
<label class="summary SH2A" for="row36">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     Rm,@(disp12,Rn)</span>
<span>Rm <var title="store into (right)"></var> (disp <var title="multiply"></var> 2 <var title="add"></var> Rn)</span>
<span id="0011nnnnmmmm00010001dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010001</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWS12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  Write_16 (R[n] + (disp &lt;&lt; 1), R[m]);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row37" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row37">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     Rm,@(disp,Rn)</span>
<span>Rm <var title="store into (right)"></var> (disp <var title="multiply"></var> 4 <var title="add"></var> Rn)</span>
<span id="0001nnnnmmmmdddd" class="colorized"><var title="Opcode Identifier">0001</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Displacement (4 bits)">dddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.
The 4-bit displacement is multiplied by four after zero-extension, enabling a
range up to +60 bytes to be specified.  If a memory operand cannot be reached,
the @(R0,Rn) mode can be used instead.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLS4 (int m, int d, int n)
{
  long disp = (0x0000000F & (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.l r0,@(0xF,r1) ! Before execution: r0 = 0xFFFF7F80         
                   ! After execution:  @(r1 + 60) = 0xFFFF7F80</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row38" />
<label class="summary SH2A" for="row38">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     Rm,@(disp12,Rn)</span>
<span>Rm <var title="store into (right)"></var> (disp <var title="multiply"></var> 4 <var title="add"></var> Rn)</span>
<span id="0011nnnnmmmm00010010dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010010</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Structure Data</span>
<span title="note">Transfers the source operand to the destination.  This
instruction is ideal for data access in a structure or the stack.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLS12 (int d, int m, int n)
{
  long disp = (0x00000FFF & (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row39" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row39">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @(R0,Rm),Rn</span>
<span>(R0 <var title="add"></var> Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0000nnnnmmmm1100" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBL0 (int m, int n)
{
  R[n] = Read_8 (R[m] + R[0]);

  if ((R[n] & 0x80) == 0)
    R[n] &= 0x000000FF;
  else R[n] |= 0xFFFFFF00;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row40" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row40">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @(R0,Rm),Rn</span>
<span>(R0 <var title="add"></var> Rm) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> Rn</span>
<span id="0000nnnnmmmm1101" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWL0 (int m, int n)
{
  R[n] = Read_16 (R[m] + R[0]);

  if ((R[n] & 0x8000) == 0)
    R[n] &= 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.w @(r0,r2),r1 ! Before execution: r2 = 0x00000004, r0 = 0x10000000 
                  ! After execution:  r1 = @0x10000004</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row41" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row41">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @(R0,Rm),Rn</span>
<span>(R0 <var title="add"></var> Rm) <var title="store into (right)"></var> Rn</span>
<span id="0000nnnnmmmm1110" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLL0 (int m, int n)
{
  R[n] = Read_32 (R[m] + R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row42" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row42">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     Rm,@(R0,Rn)</span>
<span>Rm <var title="store into (right)"></var> (R0 <var title="add"></var> Rn)</span>
<span id="0000nnnnmmmm0100" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBS0 (int m, int n)
{
  Write_8 (R[n] + R[0], R[m]);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mov.b r1,@(r0,r2) ! Before execution: r2 = 0x00000004, r0 = 0x10000000 
                  ! After execution:  r1 = @0x10000004</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row43" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row43">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     Rm,@(R0,Rn)</span>
<span>Rm <var title="store into (right)"></var> (R0 <var title="add"></var> Rn)</span>
<span id="0000nnnnmmmm0101" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWS0 (int m, int n)
{
  Write_16 (R[n] + R[0], R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row44" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row44">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     Rm,@(R0,Rn)</span>
<span>Rm <var title="store into (right)"></var> (R0 <var title="add"></var> Rn)</span>
<span id="0000nnnnmmmm0110" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Data</span>
<span title="note">Transfers the source operand to the destination.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLS0 (int m, int n)
{
  Write_32 (R[n] + R[0], R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row45" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row45">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     @(disp,GBR),R0</span>
<span>(disp <var title="add"></var> GBR) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> R0</span>
<span id="11000100dddddddd" class="colorized"><var title="Opcode Identifier">11000100</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Global Data</span>
<span title="note">Transfers the source operand to the destination.
The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be
specified.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBLG (int d)
{
  unsigned int disp = (0x000000FF & d);
  R[0] = Read_8 (GBR + disp);

  if ((R[0] & 0x80) == 0)
    R[0] &= 0x000000FF;
  else
    R[0] |= 0xFFFFFF00;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row46" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row46">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     @(disp,GBR),R0</span>
<span>(disp <var title="multiply"></var> 2 <var title="add"></var> GBR) <var title="store into (right)"></var> sign extension <var title="store into (right)"></var> R0</span>
<span id="11000101dddddddd" class="colorized"><var title="Opcode Identifier">11000101</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Global Data</span>
<span title="note">Transfers the source operand to the destination.
The 8-bit displacement is multiplied by two after zero-extension, enabling a
range up to +510 bytes to be specified.
The loaded data is sign-extended to 32 bit before being stored in the
destination register.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWLG (int d)
{
  unsigned int disp = (0x000000FF & d);
  R[0] = Read_16 (GBR + (disp &lt;&lt; 1));

  if ((R[0] & 0x8000) == 0)
    R[0] &= 0x0000FFFF;
  else
    R[0] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row47" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row47">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     @(disp,GBR),R0</span>
<span>(disp <var title="multiply"></var> 4 <var title="add"></var> GBR) <var title="store into (right)"></var> R0</span>
<span id="11000110dddddddd" class="colorized"><var title="Opcode Identifier">11000110</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Global Data</span>
<span title="note">Transfers the source operand to the destination.
The 8-bit displacement is multiplied by four after zero-extension, enabling a
range up to +1020 bytes to be specified.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLLG (int d)
{
  unsigned int disp = (0x000000FF & d);
  R[0] = Read_32 (GBR + (disp &lt;&lt; 2));
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row48" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row48">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.b     R0,@(disp,GBR)</span>
<span>R0 <var title="store into (right)"></var> (disp <var title="add"></var> GBR)</span>
<span id="11000000dddddddd" class="colorized"><var title="Opcode Identifier">11000000</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Global Data</span>
<span title="note">Transfers the source operand to the destination.
The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be
specified.</span>
<span title="section">Operation</span>
<span title="operation">void MOVBSG (int d)
{
  unsigned int disp = (0x000000FF & d);
  Write_8 (GBR + disp, R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row49" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row49">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.w     R0,@(disp,GBR)</span>
<span>R0 <var title="store into (right)"></var> (disp <var title="multiply"></var> 2 <var title="add"></var> GBR)</span>
<span id="11000001dddddddd" class="colorized"><var title="Opcode Identifier">11000001</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Global Data</span>
<span title="note">Transfers the source operand to the destination.
The 8-bit displacement is multiplied by two after zero-extension, enabling a
range up to +510 bytes to be specified.</span>
<span title="section">Operation</span>
<span title="operation">void MOVWSG (int d)
{
  unsigned int disp = (0x000000FF & d);
  Write_16 (GBR + (disp &lt;&lt; 1), R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row50" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row50">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mov.l     R0,@(disp,GBR)</span>
<span>R0 <var title="store into (right)"></var> (disp <var title="multiply"></var> 4 <var title="add"></var> GBR)</span>
<span id="11000010dddddddd" class="colorized"><var title="Opcode Identifier">11000010</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e Global Data</span>
<span title="note">Transfers the source operand to the destination.
The 8-bit displacement is multiplied by four after zero-extension, enabling a
range up to +1020 bytes to be specified.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLSG (int d)
{
  unsigned int disp = (0x000000FF & (long)d);
  Write_32 (GBR + (disp &lt;&lt; 2), R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row51" />
<label class="summary SH4A" for="row51">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movco.l   R0,@Rn</span>
<span>LDST <var title="store into (right)"></var> T
If T <var title="equality"></var> 1: R0 <var title="store into (right)"></var> Rn
0 <var title="store into (right)"></var> LDST</span>
<span id="0000nnnn01110011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01110011</var></span>
<span>LDST <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>Co</em>nditional</span>
<span title="note">MOVCO is used in combination with MOVLI to realize an atomic read-modify-write
operation in a single processor.<br /><br />
This instruction copies the value of the LDST flag to the <abbr title="Test condition bit flag">T</abbr> bit. When the <abbr title="Test condition bit flag">T</abbr> bit
is set to 1, the value of R0 is stored at the address in Rm. If the <abbr title="Test condition bit flag">T</abbr> bit is
cleared to 0, the value is not stored at the address in Rm. Finally, the LDST
flag is cleared to 0. Since the LDST flag is cleared by an instruction or
exception, storage by the MOVCO instruction only proceeds when no interrupt or
exception has occurred between the execution of the MOVLI and MOVCO instructions.</span>
<span title="section">Operation</span>
<span title="operation">void MOVCO (int n)
{
  T = LDST;
  if (T == 1)
    Write_32 (R[n], R[0]);

  LDST = 0;
  PC += 2
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row52" />
<label class="summary SH4A" for="row52">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movli.l   @Rm,R0</span>
<span>1 <var title="store into (right)"></var> LDST
(Rm) <var title="store into (right)"></var> R0
When interrupt<var title="divide"></var>exception occured: 0 <var title="store into (right)"></var> LDST</span>
<span id="0000mmmm01100011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01100011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>Li</em>nked</span>
<span title="note">MOVLI is used in combination with MOVCO to realize an atomic read-modify-write
operation in a single processor.<br /><br />
This instruction sets the LDST flag to 1 and reads the four bytes of data
indicated by Rm into R0. If, however, an interrupt or exception occurs, LDST is
cleared to 0. Storage by the MOVCO instruction only proceeds when the
instruction is executed after the LDST bit has been set by the MOVLI instruction
and not cleared by an interrupt or other exception.  When LDST has been cleared
to 0, the MOVCO instruction clears the <abbr title="Test condition bit flag">T</abbr> bit and does not proceed with storage.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLINK (int m)
{
  LDST = 1;
  R[0] = Read_32 (R[m]);
  PC += 2
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row53" />
<label class="summary SH4A" for="row53">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movua.l   @Rm,R0</span>
<span>(Rm) <var title="store into (right)"></var> R0
Load non<var title="subtract"></var>boundary alignment data</span>
<span id="0100mmmm10101001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">10101001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>U</em>n<em>a</em>ligned</span>
<span title="note">Loads the longword of data from the effective address indicated
by the contents of Rm in memory to R0. The address is not restricted to longword
boundaries address (4n).  This instruction allows loading from
non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error
exceptions do not occur when access is to non-longword-boundary addresses
(4n + 1, 4n + 2, and 4n + 3).</span>
<span title="section">Operation</span>
<span title="operation">void MOVUAL (int m)
{
  Read_Unaligned_32 (R0, R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error (when the privileged area is accessed from user mode)</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row54" />
<label class="summary SH4A" for="row54">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movua.l   @Rm+,R0</span>
<span>(Rm) <var title="store into (right)"></var> R0, Rm <var title="add"></var> 4 <var title="store into (right)"></var> Rm
Load non<var title="subtract"></var>boundary alignment data</span>
<span id="0100mmmm11101001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11101001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>U</em>n<em>a</em>ligned</span>
<span title="note">Loads the longword of data from the effective address indicated
by the contents of Rm in memory to R0. The address is not restricted to longword
boundaries address (4n).  This instruction allows loading from
non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error
exceptions do not occur when access is to non-longword-boundary addresses
(4n + 1, 4n + 2, and 4n + 3).</span>
<span title="section">Operation</span>
<span title="operation">void MOVUALP (int m)
{
  Read_Unaligned_32 (R0,R[m]);

  if (m != 0)
    R[m] += 4;

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error (when the privileged area is accessed from user mode)</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row55" />
<label class="summary SH2A" for="row55">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movml.l   Rm,@-R15</span>
<span>R15−4 <var title="store into (right)"></var> R15, Rm <var title="store into (right)"></var> (R15)
R15−4 <var title="store into (right)"></var> R15, Rm−1 <var title="store into (right)"></var> (R15)
...
...
R15−4 <var title="store into (right)"></var> R15, R0 <var title="store into (right)"></var> (R15)
Note: When Rm <var title="equality"></var> R15, read Rm as PR</span>
<span id="0100mmmm11110001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11110001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1-16</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1-16</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>M</em>ulti-register <em>L</em>ower part</span>
<span title="note">Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (R0 to Rn/Rm) not exceeding the specified
register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, <abbr title="Procedure Register">PR</abbr> is transferred instead of R15. That is, when
nnnn(mmmm) = 1111 is specified, R0 to R14 and <abbr title="Procedure Register">PR</abbr> are the general registers
subject to transfer.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLMML (int m)
{
  for (int i = m; i >= 0; i--)
  {
    if (i == 15)
      Write_32 (R[15] - 4, PR);
    else
      Write_32 (R[15] - 4, R[i]);

    R[15] -= 4;
  }

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row56" />
<label class="summary SH2A" for="row56">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movml.l   @R15+,Rn</span>
<span>(R15) <var title="store into (right)"></var> R0, R15<var title="add"></var>4 <var title="store into (right)"></var> R15
(R15) <var title="store into (right)"></var> R1, R15<var title="add"></var>4 <var title="store into (right)"></var> R15
...
...
(R15) <var title="store into (right)"></var> Rn
Note: When Rn <var title="equality"></var> R15, read Rn as PR</span>
<span id="0100nnnn11110101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11110101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1-16</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2-17</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>M</em>ulti-register <em>L</em>ower part</span>
<span title="note">Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (R0 to Rn/Rm) not exceeding the specified
register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, <abbr title="Procedure Register">PR</abbr> is transferred instead of R15. That is, when
nnnn(mmmm) = 1111 is specified, R0 to R14 and <abbr title="Procedure Register">PR</abbr> are the general registers
subject to transfer.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLPML (int n)
{
  for (int i = 0; i &lt;= n; i++)
  {
    if (i == 15)
      PR = Read_32 (R[15]);
    else
      R[i] = Read_32 (R[15]);

    R[15] += 4;
  }

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row57" />
<label class="summary SH2A" for="row57">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movmu.l   Rm,@-R15</span>
<span>R15<var title="subtract"></var>4 <var title="store into (right)"></var> R15, PR <var title="store into (right)"></var> (R15)
R15<var title="subtract"></var>4 <var title="store into (right)"></var> R15, R14 <var title="store into (right)"></var> (R15)
...
...
R15<var title="subtract"></var>4 <var title="store into (right)"></var> R15, Rm <var title="store into (right)"></var> (R15)
Note: When Rm <var title="equality"></var> R15, read Rm as PR</span>
<span id="0100mmmm11110000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11110000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1-16</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1-16</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>M</em>ulti-register <em>U</em>pper part</span>
<span title="note">Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (Rn/Rm to R14, <abbr title="Procedure Register">PR</abbr>) not lower than the
specified register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, <abbr title="Procedure Register">PR</abbr> is transferred instead of R15.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLMMU (int m)
{
  Write_32 (R[15] - 4, PR);
  R[15] -= 4;

  for (int i = 14; i >= m; i--)
  {
    Write_32 (R[15] - 4, R[i]);
    R[15] -= 4;
  }

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row58" />
<label class="summary SH2A" for="row58">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movmu.l   @R15+,Rn</span>
<span>(R15) <var title="store into (right)"></var> Rn, R15<var title="add"></var>4 <var title="store into (right)"></var> R15
(R15) <var title="store into (right)"></var> Rn<var title="add"></var>1, R15<var title="add"></var>4 <var title="store into (right)"></var> R15
...
...
(R15) <var title="store into (right)"></var> R14, R15<var title="add"></var>4 <var title="store into (right)"></var> R15
(R15) <var title="store into (right)"></var> PR
Note: When Rn <var title="equality"></var> R15, read Rn as PR</span>
<span id="0100nnnn11110100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11110100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1-16</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2-17</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>M</em>ulti-register <em>U</em>pper part</span>
<span title="note">Transfers a source operand to a destination. This instruction performs transfer
between a number of general registers (Rn/Rm to R14, <abbr title="Procedure Register">PR</abbr>) not lower than the
specified register number and memory with the contents of R15 as its address.
<br /><br />
If R15 is specified, <abbr title="Procedure Register">PR</abbr> is transferred instead of R15.</span>
<span title="section">Operation</span>
<span title="operation">void MOVLPMU (int n)
{
  for (int i = n; i &lt;= 14; i++)
  {
    R[i] = Read_32 (R[15]);
    R[15] += 4;
  }

  PR = Read_32 (R[15]);
  R[15] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row59" />
<label class="summary SH2A" for="row59">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movrt     Rn</span>
<span><var title="binary not"></var>T <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00111001" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00111001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>R</em>everse <em>T</em> bit</span>
<span title="note">Reverses the <abbr title="Test condition bit flag">T</abbr> bit and then stores the resulting value in general register Rn.
The value of Rn is 0 when <abbr title="Test condition bit flag">T</abbr> = 1 and 1 when <abbr title="Test condition bit flag">T</abbr> = 0.</span>
<span title="section">Operation</span>
<span title="operation">void MOVRT (int n)
{
  if (T == 1)
    R[n] = 0x00000000;
  else
    R[n] = 0x00000001;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row60" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row60">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movt      Rn</span>
<span>T <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00101001" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00101001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>T</em> Bit</span>
<span title="note">Stores the <abbr title="Test condition bit flag">T</abbr> bit in general register Rn.
The value of Rn is 1 when <abbr title="Test condition bit flag">T</abbr> = 1 and 0 when <abbr title="Test condition bit flag">T</abbr> = 0.</span>
<span title="section">Operation</span>
<span title="operation">void MOVT (int n)
{
  if (T == 1)
    R[n] = 0x00000001;
  else
    R[n] = 0x00000000;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">xor    r2,r2 ! r2 = 0 
cmp/pz r2    ! T = 1  
movt   r0    ! r0 = 1 
clrt         ! T = 0  
movt   r1    ! r1 = 0</span>
</span>
</label>
<input name="instruction" type="radio" id="row61" />
<label class="summary SH2A" for="row61">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nott</span>
<span><var title="binary not"></var>T <var title="store into (right)"></var> T</span>
<span id="0000000001101000" class="colorized"><var title="Opcode Identifier">0000000001101000</var></span>
<span><var title="binary not"></var>T <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Not</em> <em>T</em> bit</span>
<span title="note">Inverts the <abbr title="Test condition bit flag">T</abbr> bit, then stores the resulting value in the <abbr title="Test condition bit flag">T</abbr> bit.</span>
<span title="section">Operation</span>
<span title="operation">void NOTT (void)
{
  if (T == 1)
    T = 0;
  else
    T = 1;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row62" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row62">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>swap.b    Rm,Rn</span>
<span>Rm <var title="store into (right)"></var> swap lower 2 bytes <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1000" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Swap</em> Register Halves</span>
<span title="note">Swaps the upper and lower parts of the contents of general register Rm and
stores the result in Rn.
The 8 bits from bit 15 to bit 8 of Rm are swapped with the 8 bits from bit 7 to
bit 0. The upper 16 bits of Rm are transferred directly to the upper 16 bits of
Rn.</span>
<span title="section">Operation</span>
<span title="operation">void SWAPB (int m, int n)
{
  unsigned long temp0, temp1;
  temp0 = R[m] & 0xFFFF0000;
  temp1 = (R[m] & 0x000000FF) &lt;&lt; 8;
  R[n] = (R[m] & 0x0000FF00) &gt;&gt; 8;
  R[n] = R[n] | temp1 | temp0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">swap.b r0,r1 ! Before execution: r0 = 0x12345678 
             ! After execution:  r1 = 0x12347856</span>
</span>
</label>
<input name="instruction" type="radio" id="row63" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row63">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>swap.w    Rm,Rn</span>
<span>Rm <var title="store into (right)"></var> swap upper<var title="divide"></var>lower words <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1001" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Swap</em> Register Halves</span>
<span title="note">Swaps the upper and lower parts of the contents of general register Rm and
stores the result in Rn.
The 16 bits from bit 31 to bit 16 of Rm are swapped with the 16 bits from bit
15 to bit 0.</span>
<span title="section">Operation</span>
<span title="operation">void SWAPW (int m, int n)
{
  unsigned long temp;
  temp = (R[m] &gt;&gt; 16) & 0x0000FFFF;
  R[n] = R[m] &lt;&lt; 16;
  R[n] |= temp;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">swap.w r0,r1 ! Before execution: r0 = 0x12345678 
             ! After execution:  r1 = 0x5678123</span>
</span>
</label>
<input name="instruction" type="radio" id="row64" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row64">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xtrct     Rm,Rn</span>
<span>Rm:Rn middle 32 bits <var title="store into (right)"></var> Rn</span>
<span id="0010nnnnmmmm1101" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">E<em>xtr</em>a<em>ct</em></span>
<span title="note">Extracts the middle 32 bits from the 64-bit contents of linked general registers
Rm and Rn, and stores the result in Rn.
<br /><img alt="Extract" class="image_filter" src="xtrct.svg" height="110" /></span>
<span title="section">Operation</span>
<span title="operation">void XTRCT (int m, int n)
{
  unsigned long high = (R[m] &lt;&lt; 16) & 0xFFFF0000;
  unsigned long low = (R[n] &gt;&gt; 16) & 0x0000FFFF;
  R[n] = high | low;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">xtrct r0,r1 ! Before execution: r0 = 0x01234567, r1 = 0x89ABCDEF 
            ! After execution:  r1 = 0x456789AB</span>
</span>
</label>
<span class="section_title">Bit Manipulation Instructions</span>
<input name="instruction" type="radio" id="row65" />
<label class="summary SH2A" for="row65">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>band.b    #imm3,@disp12,Rn</span>
<span>(imm of (disp<var title="add"></var>Rn)) <var title="binary and"></var> T <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10010100dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010100</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>And</em></span>
<span title="note">ANDs a specified bit in memory at the address indicated by (disp + Rn) with the
<abbr title="Test condition bit flag">T</abbr> bit, and stores the result in the <abbr title="Test condition bit flag">T</abbr> bit. The bit number is specified by 3-bit
immediate data. With this instruction, data is read from memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BANDM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 0) || (assignbit == 0))
    T = 0;
  else
    T = 1;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row66" />
<label class="summary SH2A" for="row66">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bandnot.b #imm3,@(disp12,Rn)</span>
<span><var title="binary not"></var>(imm of (disp<var title="add"></var>Rn)) <var title="binary and"></var> T <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10011100dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10011100</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>And</em> <em>Not</em></span>
<span title="note">ANDs the value obtained by inverting a specified bit of memory at the address
indicated by (disp + Rn) with the <abbr title="Test condition bit flag">T</abbr> bit, and stores the result in the <abbr title="Test condition bit flag">T</abbr> bit.
The bit number is specified by 3-bit immediate data. With this instruction, data
is read from memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BANDNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 1) && (assignbit == 0))
    T = 1;
  else
    T = 0;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row67" />
<label class="summary SH2A" for="row67">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bclr.b    #imm3,@(disp12,Rn)</span>
<span>0 <var title="store into (right)"></var> (imm of (disp<var title="add"></var>Rn))</span>
<span id="0011nnnn0iii10010000dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010000</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>Cl</em>ea<em>r</em></span>
<span title="note">Clears a specified bit of memory at the address indicated by (disp + Rn).
The bit number is specified by 3-bit immediate data. After data is read from
memory as a byte unit, clearing of the specified bit is executed and the
resulting data is then written to memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BCLRM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  temp &= (~(0x00000001 &lt;&lt; imm));
  Write_8 (R[n] + disp, temp);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row68" />
<label class="summary SH2A" for="row68">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bclr      #imm3,Rn</span>
<span>0 <var title="store into (right)"></var> imm of Rn</span>
<span id="10000110nnnn0iii" class="colorized"><var title="Opcode Identifier">10000110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>Cl</em>ea<em>r</em></span>
<span title="note">Clears a specified bit of the <abbr title="Least Significant Bit">LSB</abbr> 8 bits of a general register Rn.
The bit number is specified by 3-bit immediate data.</span>
<span title="section">Operation</span>
<span title="operation">void CLR (int i, int n)
{
  long imm, temp;
  imm = (0x00000007 & (long)i);
  R[n] &= (~(0x00000001 &lt;&lt; imm));
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row69" />
<label class="summary SH2A" for="row69">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bld.b     #imm3,@(disp12,Rn)</span>
<span>(imm of (disp<var title="add"></var>Rn)) <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10010011dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010011</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>L</em>oa<em>d</em></span>
<span title="note">Stores a specified bit of memory at the address indicated by (disp + Rn) in the
<abbr title="Test condition bit flag">T</abbr> bit. The bit number is specified by 3-bit immediate data. Data is read from
memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BLDM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if (assignbit == 0)
    T = 0;
  else
    T = 1;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row70" />
<label class="summary SH2A" for="row70">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bld       #imm3,Rn</span>
<span>imm of Rn <var title="store into (right)"></var> T</span>
<span id="10000111nnnn1iii" class="colorized"><var title="Opcode Identifier">10000111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">1</var><var title="Unsigned Immediate Data (3 bits)">iii</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>L</em>oa<em>d</em></span>
<span title="note">Stores a specified bit of the <abbr title="Least Significant Bit">LSB</abbr> 8 bits of a general register Rn in the <abbr title="Test condition bit flag">T</abbr> bit.
The bit number is specified by 3-bit immediate data.</span>
<span title="section">Operation</span>
<span title="operation">void BLD (int i, int n)
{
  long imm, assignbit;
  imm = (0x00000007 & (long)i);
  assignbit = (0x00000001 &lt;&lt; imm) & R[n];

  if (assignbit == 0)
    T = 0;
  else
    T = 1;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row71" />
<label class="summary SH2A" for="row71">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bldnot.b  #imm3,@(disp12,Rn)</span>
<span><var title="binary not"></var>(imm of (disp<var title="add"></var>Rn)) <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10011011dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10011011</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>L</em>oa<em>d</em> <em>Not</em></span>
<span title="note">Inverts a specified bit of memory at the address indicated by (disp + Rn), and
stores the resulting value in the <abbr title="Test condition bit flag">T</abbr> bit. The bit number is specified by 3-bit
immediate data. Data is read from memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BLDNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if (assignbit == 0)
    T = 1;
  else
    T = 0;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row72" />
<label class="summary SH2A" for="row72">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bor.b     #imm3,@(disp12,Rn)</span>
<span>(imm of (disp<var title="add"></var>Rn)) <var title="binary or"></var> T <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10010101dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010101</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>O</em>r</span>
<span title="note">ORs a specified bit in memory at the address indicated by (disp + Rn) with the
<abbr title="Test condition bit flag">T</abbr> bit, and stores the result in the <abbr title="Test condition bit flag">T</abbr> bit. The bit number is specified by 3-bit
immediate data. Data is read from memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BORM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 0) && (assignbit == 0))
    T = 0;
  else
    T = 1;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row73" />
<label class="summary SH2A" for="row73">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bornot.b  #imm3,@(disp12,Rn)</span>
<span><var title="binary not"></var>(imm of (disp<var title="add"></var>Rn)) <var title="binary or"></var> T <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10011101dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10011101</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>Or</em> <em>Not</em></span>
<span title="note">ORs the value obtained by inverting a specified bit of memory at the address
indicated by (disp + Rn) with the <abbr title="Test condition bit flag">T</abbr> bit, and stores the result in the <abbr title="Test condition bit flag">T</abbr> bit.
The bit number is specified by 3-bit immediate data. With this instruction,
data is read from memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BORNOTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if ((T == 1) || (assignbit == 0))
    T = 1;
  else
    T = 0;

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row74" />
<label class="summary SH2A" for="row74">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bset.b    #imm3,@(disp12,Rn)</span>
<span>1 <var title="store into (right)"></var> (imm of (disp<var title="add"></var>Rn))</span>
<span id="0011nnnn0iii10010001dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010001</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>Set</em></span>
<span title="note">Sets to 1 a specified bit of memory at the address indicated by (disp + Rn).
The bit number is specified by 3-bit immediate data. After data is read from
memory as a byte unit, the specified bit is set to 1, and the resulting data is
then written to memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BSETM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  temp |= (0x00000001 &lt;&lt; imm);
  Write_8 (R[n] + disp, temp);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row75" />
<label class="summary SH2A" for="row75">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bset      #imm3,Rn</span>
<span>1 <var title="store into (right)"></var> imm of Rn</span>
<span id="10000110nnnn1iii" class="colorized"><var title="Opcode Identifier">10000110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">1</var><var title="Unsigned Immediate Data (3 bits)">iii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>Set</em></span>
<span title="note">Sets to 1 a specified bit of the <abbr title="Least Significant Bit">LSB</abbr> 8 bits of a general register Rn. The bit
number is specified by 3-bit immediate data.</span>
<span title="section">Operation</span>
<span title="operation">void BSET (int i, int n)
{
  long imm, temp;
  imm = (0x00000007 & (long)i);
  R[n] |= (0x00000001 &lt;&lt; imm);
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row76" />
<label class="summary SH2A" for="row76">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bst.b     #imm3,@(disp12,Rn)</span>
<span>T <var title="store into (right)"></var> (imm of (disp<var title="add"></var>Rn))</span>
<span id="0011nnnn0iii10010010dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010010</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>St</em>ore</span>
<span title="note">Transfers the contents of the <abbr title="Test condition bit flag">T</abbr> bit to a specified 1-bit location of memory at
the address indicated by (disp + Rn). The bit number is specified by 3-bit
immediate data. After data is read from memory as a byte unit, transfer from the
<abbr title="Test condition bit flag">T</abbr> bit to the specified bit is executed, and the resulting data is then written
to memory as a byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BSTM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);

  if (T == 0)
    temp &= (~(0x00000001 &lt;&lt; imm));
  else
    temp |= (0x00000001 &lt;&lt; imm);

  Write_8 (R[n] + disp, temp);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row77" />
<label class="summary SH2A" for="row77">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bst       #imm3,Rn</span>
<span>T <var title="store into (right)"></var> imm of Rn</span>
<span id="10000111nnnn0iii" class="colorized"><var title="Opcode Identifier">10000111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it <em>St</em>ore</span>
<span title="note">Transfers the contents of the <abbr title="Test condition bit flag">T</abbr> bit to a specified 1-bit location of the
<abbr title="Least Significant Bit">LSB</abbr> 8 bits of a general register Rn. The bit number is specified by 3-bit
immediate data.</span>
<span title="section">Operation</span>
<span title="operation">void BST (int i, int n)
{
  long disp, imm;
  disp = (0x00000FFF & (long)d);
  imm = (0x00000007 & (long)i);

  if (T == 0)
    R[n] &= (~(0x00000001 &lt;&lt; imm));
  else
    R[n] |= (0x00000001 &lt;&lt; imm);

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row78" />
<label class="summary SH2A" for="row78">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bxor.b    #imm3,@(disp12,Rn)</span>
<span>(imm of (disp<var title="add"></var>Rn)) <var title="binary xor"></var> T <var title="store into (right)"></var> T</span>
<span id="0011nnnn0iii10010110dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">0</var><var title="Unsigned Immediate Data (3 bits)">iii</var><var title="Opcode Identifier">10010110</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>B</em>it E<em>x</em>clusive <em>Or</em></span>
<span title="note">Exclusive-ORs a specified bit in memory at the address indicated by (disp + Rn)
with the <abbr title="Test condition bit flag">T</abbr> bit, and stores the result in the <abbr title="Test condition bit flag">T</abbr> bit. The bit number is specified
by 3-bit immediate data. With this instruction, data is read from memory as a
byte unit.</span>
<span title="section">Operation</span>
<span title="operation">void BXORM (int d, int i, int n)
{
  long disp = (0x00000FFF & (long)d);
  long imm = (0x00000007 & (long)i);
  long temp = Read_8 (R[n] + disp);
  long assignbit = (0x00000001 &lt;&lt; imm) & temp;

  if (assignbit == 0)
  {
    if (T == 0)
      T = 0;
    else
      T = 1;
  }
  else
  {
    if (T == 0)
      T = 1;
    else
      T = 0;
  }

  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<span class="section_title">Arithmetic Operation Instructions</span>
<input name="instruction" type="radio" id="row79" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row79">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>add       Rm,Rn</span>
<span>Rn <var title="add"></var> Rm <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm1100" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Add</em> Binary</span>
<span title="note">Adds together the contents of general registers Rn and Rm and stores the
result in Rn.</span>
<span title="section">Operation</span>
<span title="operation">void ADD (int m, int n)
{
  R[n] += R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">add r0,r1 ! Before execution: r0 = 0x7FFFFFFF, r1 = 0x00000001 
          ! After execution:  r1 = 0x80000000</span>
</span>
</label>
<input name="instruction" type="radio" id="row80" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row80">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>add       #imm,Rn</span>
<span>Rn <var title="add"></var> (sign extension)imm</span>
<span id="0111nnnniiiiiiii" class="colorized"><var title="Opcode Identifier">0111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Add</em> Binary</span>
<span title="note">Adds together the contents of general register Rn and the immediate value
and stores the result in Rn.  The 8-bit immediate value is sign-extended to
32 bits, which allows it to be used for immediate subtraction or decrement
operations.</span>
<span title="section">Operation</span>
<span title="operation">void ADDI (int i, int n)
{
  if ((i & 0x80) == 0)
    R[n] += (0x000000FF & (long)i);
  else
    R[n] += (0xFFFFFF00 | (long)i);

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">add #0x01,r2 ! Before execution: r2 = 0x00000000 
             ! After execution:  r2 = 0x00000001 
add #0xFE,r3 ! Before execution: r3 = 0x00000001 
             ! After execution:  r3 = 0xFFFFFFFF</span>
</span>
</label>
<input name="instruction" type="radio" id="row81" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row81">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>addc      Rm,Rn</span>
<span>Rn <var title="add"></var> Rm <var title="add"></var> T <var title="store into (right)"></var> Rn, carry <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm1110" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1110</var></span>
<span>Carry <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Add</em> with <em>C</em>arry</span>
<span title="note">Adds together the contents of general registers Rn and Rm and the <abbr title="Test condition bit flag">T</abbr> bit, and
stores the result in Rn.  A carry resulting from the operation is reflected in
the <abbr title="Test condition bit flag">T</abbr> bit.  This instruction can be used to implement additions exceeding 32
bits.</span>
<span title="section">Operation</span>
<span title="operation">void ADDC (int m, int n)
{
  unsigned long tmp0, tmp1;
  tmp1 = R[n] + R[m];
  tmp0 = R[n];
  R[n] = tmp1 + T;

  if (tmp0&gt;tmp1)
    T = 1;
  else
    T = 0;

  if (tmp1 > R[n])
    T = 1;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">     clrt     ! r0:r1 (64 bits) + r2:r3 (64 bits) = r0:r1 (64 bits)       
ADDC r3   ,r1 ! Before execution: T = 0, r1 = 0x00000001, r3 = 0xFFFFFFFF 
              ! After execution:  T = 1, r1 = 0x00000000                  
ADDC r2   ,r0 ! Before execution: T = 1, r0 = 0x00000000, r2 = 0x00000000 
              ! After execution:  T = 0, r0 = 0x00000001</span>
</span>
</label>
<input name="instruction" type="radio" id="row82" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row82">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>addv      Rm,Rn</span>
<span>Rn <var title="add"></var> Rm <var title="store into (right)"></var> Rn, overflow <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm1111" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1111</var></span>
<span>Overflow <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Add</em> with `<em>V</em> Flag` Overflow Check</span>
<span title="note">Adds together the contents of general registers Rn and Rm and stores the result
in Rn.  If overflow occurs, the <abbr title="Test condition bit flag">T</abbr> bit is set.</span>
<span title="section">Operation</span>
<span title="operation">void ADDV (int m, int n)
{
  long dest, src, ans;

  if ((long)R[n] >= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)R[m] >= 0)
    src = 0;
  else
    src = 1;

  src += dest;
  R[n] += R[m];

  if ((long)R[n] >= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (src == 0 || src == 2)
  {
    if (ans == 1)
      T = 1;
    else
      T = 0;
  }
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">addv r0,r1 ! Before execution: r0 = 0x00000001, r1 = 0x7FFFFFFE, T = 0 
           ! After execution:  r1 = 0x7FFFFFFF, T = 0                  
addv r0,r1 ! Before execution: r0 = 0x00000002, r1 = 0x7FFFFFFE, T = 0 
           ! After execution:  r1 = 0x80000000, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row83" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row83">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/eq    #imm,R0</span>
<span>If R0 <var title="equality"></var> (sign extension)imm: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="10001000iiiiiiii" class="colorized"><var title="Opcode Identifier">10001000</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>Eq</em>ual To</span>
<span title="note">Compares general register R0 and the sign-extended 8-bit immediate data and sets
the <abbr title="Test condition bit flag">T</abbr> bit if the values are equal.  If they are not equal the <abbr title="Test condition bit flag">T</abbr> bit is cleared.
The contents of R0 are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPIM (int i)
{
  long imm;

  if ((i & 0x80) == 0)
    imm = (0x000000FF & (long i));
  else
    imm = (0xFFFFFF00 | (long i));

  if (R[0] == imm)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row84" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row84">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/eq    Rm,Rn</span>
<span>If Rn <var title="equality"></var> Rm: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm0000" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0000</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>Eq</em>ual To</span>
<span title="note">Compares general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if they are equal.
The contents of Rn and Rm are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPEQ (int m, int n)
{
  if (R[n] == R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row85" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row85">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/hs    Rm,Rn</span>
<span>If Rn <var title="greater than or equal"></var> Rm (unsigned): 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm0010" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0010</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>H</em>igher or <em>S</em>ame (Unsigned Greater Than or Equal To)</span>
<span title="note">Compares general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if Rn is greater or
equal Rm.  The values for the comparison are interpreted as unsigned integer
values.  The contents of Rn and Rm are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPHI (int m, int n)
{
  if ((unsigned long)R[n] >= (unsigned long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row86" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row86">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/ge    Rm,Rn</span>
<span>If Rn <var title="greater than or equal"></var> Rm (signed): 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm0011" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0011</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If Signed <em>G</em>reater Than or <em>E</em>qual To</span>
<span title="note">Compares general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if Rn is greater or
equal Rm.  The values for the comparison are interpreted as signed integer
values.  The contents of Rn and Rm are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPGE (int m, int n)
{
  if ((long)R[n] >= (long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row87" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row87">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/hi    Rm,Rn</span>
<span>If Rn <var title="greater than"></var> Rm (unsigned): 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm0110" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>Hi</em>gher (Unsigned Greater Than)</span>
<span title="note">Compares general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if Rn is greater Rm.
The values for the comparison are interpreted as unsigned integer values.
The contents of Rn and Rm are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPHI (int m, int n)
{
  if ((unsigned long)R[n] > (unsigned long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row88" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row88">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/gt    Rm,Rn</span>
<span>If Rn <var title="greater than"></var> Rm (signed): 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm0111" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0111</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If Signed <em>G</em>reater <em>T</em>han</span>
<span title="note">Compares general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if Rn is greater Rm.
The values for the comparison are interpreted as signed integer values.
The contents of Rn and Rm are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPGT (int m, int n)
{
  if ((long)R[n] > (long)R[m])
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row89" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row89">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/pl    Rn</span>
<span>If Rn <var title="greater than"></var> 0 (signed): 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0100nnnn00010101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00010101</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>Pl</em>us (Signed Greater Than Zero)</span>
<span title="note">Compares general register Rn and sets the <abbr title="Test condition bit flag">T</abbr> bit if Rn is greater 0.  The value
in Rn for the comparison is interpreted as signed integer.  The contents of Rn
are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPPL (int n)
{
  if ((long)R[n] > 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row90" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row90">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/pz    Rn</span>
<span>If Rn <var title="greater than or equal"></var> 0 (signed): 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0100nnnn00010001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00010001</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>P</em>ositive or <em>Z</em>ero (Signed Greater Than or Equal To Zero)</span>
<span title="note">Compares general register Rn and sets the <abbr title="Test condition bit flag">T</abbr> bit if Rn is greater or equal 0.
The value in Rn for the comparison is interpreted as signed integer.  The
contents of Rn are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void CMPPZ (int n)
{
  if ((long)R[n] >= 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row91" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row91">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>cmp/str   Rm,Rn</span>
<span>If Rn and Rm have an equal byte: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0010nnnnmmmm1100" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1100</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>C</em>o<em>mp</em>are If <em>Str</em>ings Equal</span>
<span title="note">Compares general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if any of the 4 bytes
in Rn are equal to the corresponding byte in Rm. The contents of Rn and Rm are
not changed.</span>
<span title="section">Note</span>
<span title="note">This instruction can be used to speed up some string operations such as
finding the string length of a zero terminated string or string matching.</span>
<span title="section">Operation</span>
<span title="operation">void CMPSTR (int m, int n)
{
  unsigned long temp;
  long HH, HL, LH, LL;
  temp = R[n] ^ R[m];
  HH = (temp & 0xFF000000) &gt;&gt; 24;
  HL = (temp & 0x00FF0000) &gt;&gt; 16;
  LH = (temp & 0x0000FF00) &gt;&gt; 8;
  LL = temp & 0x000000FF;
  HH = HH && HL && LH && LL;

  if (HH == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">cmp/str  r2,r3    ! r2 = "ABCD", r3 = "XYCZ"
bt       target   ! T = 1, so branch is taken.</span>
</span>
</label>
<input name="instruction" type="radio" id="row92" />
<label class="summary SH2A" for="row92">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clips.b   Rn</span>
<span>If Rn <var title="greater than"></var> 0x0000007F: 0x0000007F <var title="store into (right)"></var> Rn, 1 <var title="store into (right)"></var> CS
If Rn <var title="less than"></var> 0xFFFFFF80: 0xFFFFFF80 <var title="store into (right)"></var> Rn, 1 <var title="store into (right)"></var> CS</span>
<span id="0100nnnn10010001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10010001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>CLIP</em> as <em>S</em>igned</span>
<span title="note">Determines saturation. Signed data is used with this instruction. The saturation
upper-limit value is stored in general register Rn if the contents of Rn exceed
the saturation upper-limit value, or the saturation lower-limit value is stored
in Rn if the contents of Rn are less than the saturation lower-limit value, and
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit is set to 1.
The saturation upper-limit value is 0x0000007F (127).
The saturation lower-limit value is 0xFFFFFF80 (-128).</span>
<span title="section">Note</span>
<span title="note">The <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value or are not less than the saturation
lower-limit value.</span>
<span title="section">Operation</span>
<span title="operation">void CLIPSB (int n)
{
  if (R[n] > 0x0000007F)
  {
    R[n] = 0x0000007F;
    CS = 1;
  }
  else if (R[n] &lt; 0xFFFFFF80)
  {
    R[n] = 0xFFFFFF80;
    CS = 1;
  }

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row93" />
<label class="summary SH2A" for="row93">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clips.w   Rn</span>
<span>If Rn <var title="greater than"></var> 0x00007FFF: 0x00007FFF <var title="store into (right)"></var> Rn, 1 <var title="store into (right)"></var> CS
If Rn <var title="less than"></var> 0xFFFF8000: 0xFFFF8000 <var title="store into (right)"></var> Rn, 1 <var title="store into (right)"></var> CS</span>
<span id="0100nnnn10010101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10010101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>CLIP</em> as <em>S</em>igned</span>
<span title="note">Determines saturation. Signed data is used with this instruction. The saturation
upper-limit value is stored in general register Rn if the contents of Rn exceed
the saturation upper-limit value, or the saturation lower-limit value is stored
in Rn if the contents of Rn are less than the saturation lower-limit value, and
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit is set to 1.
The saturation upper-limit value is 0x00007FFF (32767).
The saturation lower-limit value is 0xFFFF8000 (-32768).</span>
<span title="section">Note</span>
<span title="note">The <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value or are not less than the saturation
lower-limit value.</span>
<span title="section">Operation</span>
<span title="operation">void CLIPSW (int n)
{
  if (R[n] > 0x00007FFF)
  {
    R[n] = 0x00007FFF;
    CS = 1;
  }
  else if (R[n] &lt; 0xFFFF8000)
  {
    R[n] = 0xFFFF8000;
    CS = 1;
  }

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row94" />
<label class="summary SH2A" for="row94">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clipu.b   Rn</span>
<span>If Rn <var title="greater than"></var> 0x000000FF: 0x000000FF <var title="store into (right)"></var> Rn, 1 <var title="store into (right)"></var> CS</span>
<span id="0100nnnn10000001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>CLIP</em> as <em>U</em>nsigned</span>
<span title="note">Determines saturation. Unsigned data is used with this instruction. If the
contents of general register Rn exceed the saturation value, the saturation
value is stored in Rn and the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit is set to 1.
The saturation value is 0x000000FF (255).</span>
<span title="section">Note</span>
<span title="note">The <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value.</span>
<span title="section">Operation</span>
<span title="operation">void CLIPUB (int n)
{
  if (R[n] > 0x000000FF)
  {
    R[n] = 0x000000FF;
    CS = 1;
  }

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row95" />
<label class="summary SH2A" for="row95">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clipu.w   Rn</span>
<span>If Rn <var title="greater than"></var> 0x0000FFFF: 0x0000FFFF <var title="store into (right)"></var> Rn, 1 <var title="store into (right)"></var> CS</span>
<span id="0100nnnn10000101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>CLIP</em> as <em>U</em>nsigned</span>
<span title="note">Determines saturation. Unsigned data is used with this instruction. If the
contents of general register Rn exceed the saturation value, the saturation
value is stored in Rn and the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit is set to 1.
The saturation value is 0x0000FFFF (65535).</span>
<span title="section">Note</span>
<span title="note">The <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bit value does not change if the contents of general register Rn do not
exceed the saturation upper-limit value.</span>
<span title="section">Operation</span>
<span title="operation">void CLIPUW (int n)
{
  if (R[n] > 0x0000FFFF)
  {
    R[n] = 0x0000FFFF;
    CS = 1;
  }

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row96" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row96">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>div0s     Rm,Rn</span>
<span>MSB of Rn <var title="store into (right)"></var> Q, MSB of Rm <var title="store into (right)"></var> M, M <var title="binary xor"></var> Q <var title="store into (right)"></var> T</span>
<span id="0010nnnnmmmm0111" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0111</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Div</em>ide `Step <em>0</em>` as <em>S</em>igned</span>
<span title="note">Performs initial settings for signed division. This instruction is followed by
a DIV1 instruction that executes 1-digit division, for example, and repeated
division steps are executed to find the quotient. See the description of the
DIV1 instruction for details.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be used to compare the signs of Rm and Rn.  If the
signs of Rm and Rn are equal, <abbr title="Test condition bit flag">T</abbr> will be set to 0.  If the signs of Rm and Rn
are not equal, <abbr title="Test condition bit flag">T</abbr> will be set to 1.</span>
<span title="section">Operation</span>
<span title="operation">void DIV0S (int m, int n)
{
  if ((R[n] & 0x80000000) == 0)
    Q = 0;
  else
    Q = 1;

  if ((R[m] & 0x80000000) == 0)
    M = 0;
  else
    M = 1;

  T = ! (M == Q);
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row97" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row97">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>div0u</span>
<span>0 <var title="store into (right)"></var> M, 0 <var title="store into (right)"></var> Q, 0 <var title="store into (right)"></var> T</span>
<span id="0000000000011001" class="colorized"><var title="Opcode Identifier">0000000000011001</var></span>
<span>0 <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Div</em>ide `Step <em>0</em>` as <em>U</em>nsigned</span>
<span title="note">Performs initial settings for unsigned division. This instruction is followed by
a DIV1 instruction that executes 1-digit division, for example, and repeated
division steps are executed to find the quotient. See the description of the
DIV1 instruction for details.</span>
<span title="section">Operation</span>
<span title="operation">void DIV0U (void)
{
  M = Q = T = 0;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row98" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row98">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>div1      Rm,Rn</span>
<span>1<var title="subtract"></var>step division (Rn <var title="divide"></var> Rm)</span>
<span id="0011nnnnmmmm0100" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0100</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Div</em>ide <em>1</em> Step</span>
<span title="note">Performs 1-digit division (1-step division) of the 32-bit contents of general
register Rn (dividend) by the contents of Rm (divisor).
The quotient is obtained by repeated execution of this instruction alone or in
combination with other instructions. The specified registers and the <abbr title="Divide-step M flag">M</abbr>, <abbr title="Divide-step Q flag">Q</abbr>, and
<abbr title="Test condition bit flag">T</abbr> bits must not be modified during these repeated executions.
<br /><br />
In 1-step division, the dividend is shifted 1 bit to the left, the divisor is
subtracted from this, and the quotient bit is reflected in the <abbr title="Divide-step Q flag">Q</abbr> bit according
to whether the result is positive or negative.
<br /><br />
Detection of division by zero or overflow is not provided. Check for division by
zero and overflow division before executing the division. A remainder operation
is not provided. Find the remainder by finding the product of the divisor and
the obtained quotient, and subtracting this value from the dividend:
<br /><br />
<code>remainder = dividend - (divisor × quotient)</code>
<br /><br />
Initial settings should first be made with the DIV0S or DIV0U instruction. DIV1
is executed once for each bit of the divisor. If a quotient of more than 17
bits is required, place an ROTCL instruction before the DIV1 instruction. See
the examples for details of the division sequence.</span>
<span title="section">Operation</span>
<span title="operation">void DIV1 (int m, int n)
{
  unsigned long tmp0, tmp2;
  unsigned char old_q, tmp1;

  old_q = Q;
  Q = (0x80000000 & R[n]) != 0;
  tmp2 = R[m];
  R[n] &lt;&lt;= 1;
  R[n] |= (unsigned long)T;

  if (old_q == 0)
  {
    if (M == 0)
    {
      tmp0 = R[n];
      R[n] -= tmp2;
      tmp1 = R[n] > tmp0;

      if (Q == 0)
        Q = tmp1;
      else if (Q == 1)
        Q = tmp1 == 0;
    }

    else if (M == 1)
    {
      tmp0 = R[n];
      R[n] += tmp2;
      tmp1 = R[n] &lt; tmp0;

      if (Q == 0)
        Q = tmp1 == 0;
      else if (Q == 1)
        Q = tmp1;
    }
  }

  else if (old_q == 1)
  {
    if (M == 0)
    {
      tmp0 = R[n];
      R[n] += tmp2;
      tmp1 = R[n] &lt; tmp0;

      if (Q == 0)
        Q = tmp1;
      else if (Q == 1)
        Q = tmp1 == 0;
    }

    else if (M == 1)
    {
       tmp0 = R[n];
       R[n] -= tmp2;
       tmp1 = R[n] > tmp0;

       if (Q == 0)
         Q = tmp1 == 0;
       else if (Q == 1)
         Q = tmp1;
    }
  }

  T = (Q == M);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">! r1 (32 bits) / r0 (16 bits) = r1 (16 bits)  (unsigned)

shll16  r0        ! Set divisor in upper 16 bits, clear lower 16 bits to 0

tst     r0,r0     ! Check for division by zero
bt      zero_div

cmp/hs  r0,r1     ! Check for overflow
bt      over_div

div0u             ! Flag initialization

.rept 16
div1    r0,r1     ! Repeat 16 times
.endr

rotcl   r1
extu.w  r1,r1     ! r1 = quotient

- - - - - - - - - - - - - - - -

! r1:r2 (64 bits) / r0 (32 bits) = r2 (32 bits)  (unsigned)

tst     r0,r0     ! Check for division by zero
bt      zero_div

cmp/hs  r0,r1     ! Check for overflow
bt      over_div

div0u             ! Flag initialization

.rept 32
rotcl   r2        ! Repeat 32 times
div1    r0,r1
.endr

rotcl   r2        ! r2 = quotient

- - - - - - - - - - - - - - - -

! r1 (16 bits) / r0 (16 bits) = r1 (16 bits)  (signed)

shll16  r0        ! Set divisor in upper 16 bits, clear lower 16 bits to 0
exts.w  r1,r1     ! Dividend sign-extended to 32 bits
mov     #0,r2
mov     r1,r3
rotcl   r3
subc    r2,r1     ! If dividend is negative, subtract 1
div0s   r0,r1     ! Flag initialization

.rept 16
div1    r0,r1     ! Repeat 16 times
.endr

exts.w  r1,r1
rotcl   r1        ! r1 = quotient (one's complement notation)
addc    r2,r1     ! If MSB of quotient is 1, add 1 to convert to two's complement notation
exts.w  r1,r1     ! r1 = quotient (two's complement notation)

- - - - - - - - - - - - - - - -

! r2 (32 bits) / r0 (32 bits) = r2 (32 bits)  (signed)

mov     r2,r3
rotcl   r3
subc    r1,r1     ! Dividend sign-extended to 64 bits (r1:r2)
mov     #0,r3
subc    r3,r2     ! If dividend is negative, subtract 1 to convert to one's complement notation
div0s   r0,r1     ! Flag initialization

.rept 32
rotcl   r2        ! Repeat 32 times
div1    r0,r1
.endr

rotcl   r2        ! r2 = quotient (one's complement notation)
addc    r3,r2     ! If MSB of quotient is 1, add 1 to convert to two's complement notation
                  ! r2 = quotient (two's complement notation)

- - - - - - - - - - - - - - - -
! r4 (8 bits) / r5 (8 bits) = r0 (8 bits)  (unsigned)

extu.b  r4,r4     ! Optional, not needed if value is known to be zero extended.
extu.b  r5,r5     ! Optional, not needed if value is known to be zero extended.
shll8   r5
div0u

.rept 8
div1    r5,r4     ! Repeat 8 times
.endr

rotcl   r4
extu.b  r4,r0</span>
</span>
</label>
<input name="instruction" type="radio" id="row99" />
<label class="summary SH2A" for="row99">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>divs      R0,Rn</span>
<span>Signed, Rn <var title="divide"></var> R0 <var title="store into (right)"></var> Rn
32 <var title="divide"></var> 32 <var title="store into (right)"></var> 32 bits</span>
<span id="0100nnnn10010100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10010100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>36</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>36</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Div</em>ide as <em>S</em>igned</span>
<span title="note">Executes division of the 32-bit contents of a general register Rn (dividend) by
the contents of R0 (divisor). This instruction executes signed division and
finds the quotient only. A remainder operation is not provided. To obtain the
remainder, find the product of the divisor and the obtained quotient, and
subtract this value from the dividend. The sign of the remainder will be the
same as that of the dividend.</span>
<span title="section">Note</span>
<span title="note">An overflow exception will occur if the negative maximum value (0x00000000) is
divided by -1. If division by zero is performed a division by zero exception
will occur.
<br /><br />
If an interrupt is generated while this instruction is being executed, execution
will be halted. The return address will be the start address of this instruction,
and this instruction will be re-executed.  This avoids increased interrupt
latency.</span>
<span title="section">Operation</span>
<span title="operation">void DIVS (int n)
{
  R[n] = R[n] / R[0];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Overflow exception</var>
  <var>Division by zero exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row100" />
<label class="summary SH2A" for="row100">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>divu      R0,Rn</span>
<span>Unsigned, Rn <var title="divide"></var> R0 <var title="store into (right)"></var> Rn
32 <var title="divide"></var> 32 <var title="store into (right)"></var> 32 bits</span>
<span id="0100nnnn10000100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>36</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>36</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Div</em>ide as <em>U</em>nsigned</span>
<span title="note">Executes division of the 32-bit contents of a general register Rn (dividend) by
the contents of R0 (divisor). This instruction executes unsigned division and
finds the quotient only. A remainder operation is not provided. To obtain the
remainder, find the product of the divisor and the obtained quotient, and
subtract this value from the dividend.</span>
<span title="section">Note</span>
<span title="note">A division by zero exception will occur if division by zero is performed.
<br /><br />
If an interrupt is generated while this instruction is being executed, execution
will be halted. The return address will be the start address of this instruction,
and this instruction will be re-executed.  This avoids increased interrupt
latency.</span>
<span title="section">Operation</span>
<span title="operation">void DIVU (int n)
{
  R[n]= (unsigned long)R[n] / (unsigned long)R[0];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Division by zero exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row101" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row101">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dmuls.l   Rm,Rn</span>
<span>Signed, Rn <var title="multiply"></var> Rm <var title="store into (right)"></var> MACH:MACL
32 <var title="multiply"></var> 32 <var title="store into (right)"></var> 64 bits</span>
<span id="0011nnnnmmmm1101" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var>3</var><var>3</var><var>2-5</var><var></var><var>4/4</var><var>2</var><var></var></span>
<span class="details">
<span title="section"><em>D</em>ouble-length <em>Mul</em>tiply as <em>S</em>igned</span>
<span title="note">Performs 32-bit multiplication of the contents of general register Rn by the
contents of Rm, and stores the 64-bit result in the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> and <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> registers.
The multiplication is performed as a signed arithmetic operation.</span>
<span title="section">Note</span>
<span title="note">On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void DMULS (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;
  long tempm, tempn, fnLmL;

  tempn = (long)R[n];
  tempm = (long)R[m];

  if (tempn &lt; 0)
    tempn = 0 - tempn;

  if (tempm &lt; 0)
    tempm = 0 - tempm;

  if ((long)(R[n] ^ R[m]) &lt; 0)
    fnLmL = -1;
  else
    fnLmL = 0;

  temp1 = (unsigned long)tempn;
  temp2 = (unsigned long)tempm;

  RnL = temp1 & 0x0000FFFF;
  RnH = (temp1 &gt;&gt; 16) & 0x0000FFFF;

  RmL = temp2 & 0x0000FFFF;
  RmH = (temp2 &gt;&gt; 16) & 0x0000FFFF;

  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0;
  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) & 0xFFFF0000;
  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) & 0x0000FFFF) + temp3;

  if (fnLmL &lt; 0)
  {
    Res2 = ~Res2;
    if (Res0 == 0)
      Res2++;
    else
      Res0 = (~Res0) + 1;
  }

  MACH = Res2;
  MACL = Res0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">dmuls.l r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555     
                ! After execution:  MACH = 0xFFFFFFFF, MACL = 0xFFFF5556 
sts     MACH,r0 ! Operation result (top)                                 
sts     MACL,r0 ! Operation result (bottom)</span>
</span>
</label>
<input name="instruction" type="radio" id="row102" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row102">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dmulu.l   Rm,Rn</span>
<span>Unsigned, Rn <var title="multiply"></var> Rm <var title="store into (right)"></var> MACH:MACL
32 <var title="multiply"></var> 32 <var title="store into (right)"></var> 64 bits</span>
<span id="0011nnnnmmmm0101" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var>2</var><var>2</var><var>2-5</var><var></var><var>4/4</var><var>2</var><var></var></span>
<span class="details">
<span title="section"><em>D</em>ouble-length <em>Mul</em>tiply as <em>U</em>nsigned</span>
<span title="note">Performs 32-bit multiplication of the contents of general register Rn by the
contents of Rm, and stores the 64-bit result in the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> and <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> registers.
The multiplication is performed as an unsigned arithmetic operation.</span>
<span title="section">Note</span>
<span title="note">On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void DMULU (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;

  RnL = R[n] & 0x0000FFFF;
  RnH = (R[n] &gt;&gt; 16) & 0x0000FFFF;

  RmL = R[m] & 0x0000FFFF;
  RmH = (R[m] &gt;&gt; 16) & 0x0000FFFF;

  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0
  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) & 0xFFFF0000;
  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) & 0x0000FFFF) + temp3;

  MACH = Res2;
  MACL = Res0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">dmulu.l r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555     
                ! After execution:  MACH = 0xFFFFFFFF, MACL = 0xFFFF5556 
sts     MACH,r0 ! Operation result (top)                                 
sts     MACL,r0 ! Operation result (bottom</span>
</span>
</label>
<input name="instruction" type="radio" id="row103" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row103">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dt        Rn</span>
<span>Rn<var title="subtract"></var>1 <var title="store into (right)"></var> Rn
If Rn <var title="equality"></var> 0: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0100nnnn00010000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00010000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>D</em>ecrement and <em>T</em>est</span>
<span title="note">Decrements the contents of general register Rn by 1 and compares the result
with zero. If the result is zero, the <abbr title="Test condition bit flag">T</abbr> bit is set to 1.
If the result is nonzero, the <abbr title="Test condition bit flag">T</abbr> bit is cleared to 0.</span>
<span title="section">Operation</span>
<span title="operation">void DT (int n)
{
  R[n]--;

  if (R[n] == 0)
    T = 1;
  else T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">    mov   #4,r4      ! Set loop count
loop:
    add   r0,r1
    dt    r5         ! Decrement r5 value and check for 0.
    bf    loop       ! if T = 0 branch to loop
                     ! (in this example, 4 loop iterations are executed)</span>
</span>
</label>
<input name="instruction" type="radio" id="row104" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row104">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>exts.b    Rm,Rn</span>
<span>Rm sign<var title="subtract"></var>extended from byte <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1110" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Ext</em>end as <em>S</em>igned</span>
<span title="note">Sign-extends the contents of general register Rm and stores the result in Rn.
The value of Rm bit 7 is transferred to Rn bits 8 to 31.</span>
<span title="section">Operation</span>
<span title="operation">void EXTSB (int m, int n)
{
  R[n] = R[m];

  if ((R[m] & 0x00000080) == 0)
    R[n] & = 0x000000FF;
  else
    R[n] |= 0xFFFFFF00;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">exts.b r0,r1 ! Before execution: r0 = 0x00000080 
             ! After execution:  r1 = 0xFFFFFF80</span>
</span>
</label>
<input name="instruction" type="radio" id="row105" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row105">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>exts.w    Rm,Rn</span>
<span>Rm sign<var title="subtract"></var>extended from word <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1111" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Ext</em>end as <em>S</em>igned</span>
<span title="note">Sign-extends the contents of general register Rm and stores the result in Rn.
The value of Rm bit 15 is transferred to Rn bits 16 to 31.</span>
<span title="section">Operation</span>
<span title="operation">void EXTSW (int m, int n)
{
  R[n] = R[m];

  if ((R[m] & 0x00008000) == 0)
    R[n] & = 0x0000FFFF;
  else
    R[n] |= 0xFFFF0000;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">exts.w r0,r1 ! Before execution: r0 = 0x00008000 
             ! After execution:  r1 = 0xFFFF8000</span>
</span>
</label>
<input name="instruction" type="radio" id="row106" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row106">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>extu.b    Rm,Rn</span>
<span>Rm zero<var title="subtract"></var>extended from byte <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1100" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Ext</em>end as <em>U</em>nsigned</span>
<span title="note">Zero-extends the contents of general register Rm and stores the result in Rn.
0 is transferred to Rn bits 8 to 31.</span>
<span title="section">Operation</span>
<span title="operation">void EXTUB (int m, int n)
{
  R[n] = R[m];
  R[n] &= 0x000000FF;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">extu.b r0,r1 ! Before execution: r0 = 0xFFFFFF80 
             ! After execution:  r1 = 0x00000080</span>
</span>
</label>
<input name="instruction" type="radio" id="row107" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row107">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>extu.w    Rm,Rn</span>
<span>Rm zero<var title="subtract"></var>extended from word <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1101" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Ext</em>end as <em>U</em>nsigned</span>
<span title="note">Zero-extends the contents of general register Rm and stores the result in Rn.
0 is transferred to Rn bits 16 to 31.</span>
<span title="section">Operation</span>
<span title="operation">void EXTUW (int m, int n)
{
  R[n] = R[m];
  R[n] &= 0x0000FFFF;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">extu.w r0,r1 ! Before execution: r0 = 0xFFFF8000 
             ! After execution:  r1 = 0x00008000</span>
</span>
</label>
<input name="instruction" type="radio" id="row108" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row108">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mac.l     @Rm+,@Rn+</span>
<span>Signed, (Rn) <var title="multiply"></var> (Rm) <var title="add"></var> MAC <var title="store into (right)"></var> MAC
32 <var title="multiply"></var> 32 <var title="add"></var> 64 <var title="store into (right)"></var> 64 bits</span>
<span id="0000nnnnmmmm1111" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var>4</var><var>4</var><var>2</var><var></var><var>2</var><var>2</var><var></var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var>5</var><var>5</var><var>2-5</var><var></var><var>2/4</var><var>5</var><var></var></span>
<span class="details">
<span title="section"><em>M</em>ultiply and <em>Ac</em>cumulate</span>
<span title="note">Performs signed multiplication of the 32-bit operands whose addresses are the
contents of general registers Rm and Rn, adds the 64-bit result to the <abbr title="Multiply and Accumulate">MAC</abbr>
register contents, and stores the result in the <abbr title="Multiply and Accumulate">MAC</abbr> register.
Operands Rm and Rn are each incremented by 4 each time they are read.
<br /><br />
When the <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> bit is cleared to 0, the 64-bit result is stored in the coupled <abbr title="Multiply and ACcumulate High (word)">MACH</abbr>
and <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> registers.
<br /><br />
When bit <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> is set to 1, addition to the <abbr title="Multiply and Accumulate">MAC</abbr> register is a saturation operation
of 48 bits starting from the <abbr title="Least Significant Bit">LSB</abbr>. For the saturation operation, only the lower
48 bits of the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register are enabled and the result is limited to a range
of 0xFFFF800000000000 (minimum) and 0x00007FFFFFFFFFFF (maximum).</span>
<span title="section">Note</span>
<span title="note">On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.  In the case of consecutive executions of
<abbr title="Multiply and Accumulate">MAC</abbr>.W/<abbr title="Multiply and Accumulate">MAC</abbr>.L, the latency is decreased to 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void MACL (int m, int n)
{
  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;
  unsigned long temp0, temp1, temp2, temp3;
  long tempm, tempn, fnLmL;

  tempn = Read_32 (R[n]);
  R[n] += 4;
  tempm = Read_32 (R[m]);
  R[m] += 4;

  if ((long)(tempn ^ tempm) &lt; 0)
    fnLmL = -1;
  else
    fnLmL = 0;

  if (tempn &lt; 0)
    tempn = 0 - tempn;
  if (tempm &lt; 0)
    tempm = 0 - tempm;

  temp1 = (unsigned long)tempn;
  temp2 = (unsigned long)tempm;

  RnL = temp1 & 0x0000FFFF;
  RnH = (temp1 &gt;&gt; 16) & 0x0000FFFF;
  RmL = temp2 & 0x0000FFFF;
  RmH = (temp2 &gt;&gt; 16) & 0x0000FFFF;
  temp0 = RmL * RnL;
  temp1 = RmH * RnL;
  temp2 = RmL * RnH;
  temp3 = RmH * RnH;

  Res2 = 0;

  Res1 = temp1 + temp2;
  if (Res1 &lt; temp1)
    Res2 += 0x00010000;

  temp1 = (Res1 &lt;&lt; 16) & 0xFFFF0000;

  Res0 = temp0 + temp1;
  if (Res0 &lt; temp0)
    Res2++;

  Res2 = Res2 + ((Res1 &gt;&gt; 16) & 0x0000FFFF) + temp3;

  if(fnLmL &lt; 0)
  {
    Res2 = ~Res2;
    if (Res0 == 0)
      Res2++;
    else
      Res0 = (~Res0) + 1;
  }

  if (S == 1)
  {
    Res0 = MACL + Res0;
    if (MACL > Res0)
      Res2++;

    Res2 += MACH & 0x0000FFFF;

    if (((long)Res2 &lt; 0) && (Res2 &lt; 0xFFFF8000))
    {
      Res2 = 0xFFFF8000;
      Res0 = 0x00000000;
    }

    if (((long)Res2 > 0) && (Res2 > 0x00007FFF))
    {
      Res2 = 0x00007FFF;
      Res0 = 0xFFFFFFFF;
    }

    MACH = (Res2 & 0x0000FFFF) | (MACH & 0xFFFF0000);
    MACL = Res0;
  }
  else
  {
    Res0 = MACL + Res0;
    if (MACL > Res0)
      Res2 ++;

    Res2 += MACH;
    MACH = Res2;
    MACL = Res0;
  }

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">      mova    TBLM,r0    ! Table address               
      mov     r0,r1                                    
      mova    TBLN,r0    ! Table address               
      clrmac             ! MAC register initialization 
      mac.l   @r0+,@r1+                                
      mac.l   @r0+,@r1+                                
      sts     MACL,r0    ! Store result into r0        
      .align  2                                        
TBLM: .data.l 0x1234ABCD                               
      .data.l 0x5678EF01                               
TBLN: .data.l 0x0123ABCD                               
      .data.l 0x4567DEF0</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row109" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row109">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mac.w     @Rm+,@Rn+</span>
<span>Signed, (Rn) <var title="multiply"></var> (Rm) <var title="add"></var> MAC <var title="store into (right)"></var> MAC
SH1: 16 <var title="multiply"></var> 16 <var title="add"></var> 42 <var title="store into (right)"></var> 42 bits
Other: 16 <var title="multiply"></var> 16 <var title="add"></var> 64 <var title="store into (right)"></var> 64 bits</span>
<span id="0100nnnnmmmm1111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>2</var><var>2</var><var></var></span>
<span class="cycle_grid"><var>2-3</var><var>2-3</var><var>4</var><var>4</var><var>2-5</var><var></var><var>2/4</var><var>4</var><var></var></span>
<span class="details">
<span title="section"><em>M</em>ultiply and <em>Ac</em>cumulate</span>
<span title="note">Performs signed multiplication of the 16-bit operands whose addresses are the
contents of general registers Rm and Rn, adds the 32-bit result to the <abbr title="Multiply and Accumulate">MAC</abbr>
register contents, and stores the result in the <abbr title="Multiply and Accumulate">MAC</abbr> register.
Operands Rm and Rn are each incremented by 2 each time they are read.
<br /><br />
If the <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> bit is 0, a 16 × 16 + 64 → 64-bit multiply-and-accumulate operation
is performed, and the 64-bit result is stored in the linked <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> and <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr>
registers.
<br /><br />
If the <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> bit is 1, a 16 × 16 + 32 → 32-bit multiply-and-accumulate operation is
performed, and the addition to the <abbr title="Multiply and Accumulate">MAC</abbr> register contents is a saturation
operation. In a saturation operation, only the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register is valid, and the
result range is limited to 0x80000000 (minimum value) to 0x7FFFFFFF
(maximum value). If overflow occurs, the <abbr title="Least Significant Bit">LSB</abbr> of the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register is set to 1.
0x80000000 (minimum value) is stored in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register if the result
overflows in the negative direction, and 0x7FFFFFFF (maximum value) is stored
if the result overflows in the positive direction</span>
<span title="section">Note</span>
<span title="note">When the <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> bit is 0, the SH2 and SH-<abbr title="Digital Signal Processor">DSP</abbr> <abbr title="Central Processing Unit">CPU</abbr> perform a 16 × 16 + 64 → 64 bit
multiply and accumulate operation and the SH1 <abbr title="Central Processing Unit">CPU</abbr> performs a 16 × 16 + 42 →
42 bit multiply and accumulate operation.
<br /><br />
On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.  In the case of consecutive executions of
<abbr title="Multiply and Accumulate">MAC</abbr>.W/<abbr title="Multiply and Accumulate">MAC</abbr>.L, the latency is decreased to 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void MACW (int m, int n)
{
  long tempm, tempn, dest, src, ans;
  unsigned long templ;

  tempn = Read_16 (R[n]);
  R[n] += 2;
  tempm = Read_16 (R[m]);
  R[m] += 2;

  templ = MACL;
  tempm = ((long)(short)tempn * (long)(short)tempm);

  if ((long)MACL >= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)tempm >= 0)
  {
    src = 0;
    tempn = 0;
  }
  else
  {
    src = 1;
    tempn = 0xFFFFFFFF;
  }

  src += dest;
  MACL += tempm;

  if ((long)MACL >= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (S == 1)
  {
    if (ans == 1)
    {
      #if SH1
      if (src == 0 || src == 2)
        MACH |= 0x00000001;
      #endif

      if (src == 0)
        MACL = 0x7FFFFFFF;
      if (src == 2)
        MACL = 0x80000000;
    }
  }
  else
  {
    MACH += tempn;
    if (templ > MACL)
      MACH += 1;

    #if SH1
    if ((MACH & 0x00000200) == 0)
      MACH &= 0x000003FF;
    else
      MACH |= 0xFFFFFC00;
    #endif
  }

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">      mova    TBLM,r0   ! Table address               
      mov     r0,r1                                   
      mova    TBLN,r0   ! Table address               
      clrmac            ! MAC register initialization 
      mac.w   @r0+,@r1+                               
      mac.w   @r0+,@r1+                               
      sts     MACL,r0   ! Store result into r0        
      .align  2                                       
TBLM: .data.w 0x1234                                  
      .data.w 0x5678                                  
TBLN: .data.w 0x0123                                  
      .data.w 0x4567</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row110" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row110">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mul.l     Rm,Rn</span>
<span>Rn <var title="multiply"></var> Rm <var title="store into (right)"></var> MACL
32 <var title="multiply"></var> 32 <var title="store into (right)"></var> 32 bits</span>
<span id="0000nnnnmmmm0111" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var>2-4</var><var>3</var><var>3</var><var>2-4</var><var></var><var>4/4</var><var>2</var><var></var></span>
<span class="details">
<span title="section"><em>Mul</em>tiply</span>
<span title="note">Performs 32-bit multiplication of the contents of general registers Rn and Rm,
and stores the lower 32 bits of the result in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register. The contents
of <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> are not changed.</span>
<span title="section">Note</span>
<span title="note">On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void MULL (int m, int n)
{
  MACL = R[n] * R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mull r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555 
             ! After execution:  MACL = 0xFFFF5556                
sts  MACL,r0 ! Operation result</span>
</span>
</label>
<input name="instruction" type="radio" id="row111" />
<label class="summary SH2A" for="row111">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mulr      R0,Rn</span>
<span>R0 <var title="multiply"></var> Rn <var title="store into (right)"></var> Rn
32 <var title="multiply"></var> 32 <var title="store into (right)"></var> 32 bits</span>
<span id="0100nnnn10000000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>4</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Mul</em>tiply to <em>R</em>egister</span>
<span title="note">Performs 32-bit multiplication of the contents of general register R0 by Rn,
and stores the lower 32 bits of the result in general register Rn.</span>
<span title="section">Operation</span>
<span title="operation">void MULR (int n)
{
  R[n] = R[0] * R[n];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row112" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row112">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>muls.w    Rm,Rn</span>
<span>Signed, Rn <var title="multiply"></var> Rm <var title="store into (right)"></var> MACL
16 <var title="multiply"></var> 16 <var title="store into (right)"></var> 32 bits</span>
<span id="0010nnnnmmmm1111" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>1</var><var>1</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1-3</var><var>1-3</var><var>2</var><var>2</var><var>1-3</var><var></var><var>4/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mul</em>tiply as <em>S</em>igned [<em>W</em>ord]</span>
<span title="note">Performs 16-bit multiplication of the contents of general registers Rn and Rm,
and stores the 32-bit result in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register. The multiplication is
performed as a signed arithmetic operation. The contents of <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> are not
changed.</span>
<span title="section">Note</span>
<span title="note">On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void MULS (int m, int n)
{
  MACL = ((long)(short)R[n] * (long)(short)R[m]);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">muls r0,r1   ! Before execution: r0 = 0xFFFFFFFE, r1 = 0x00005555 
             ! After execution:  MACL = 0xFFFF5556                
sts  MACL,r0 ! Operation result</span>
</span>
</label>
<input name="instruction" type="radio" id="row113" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row113">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>mulu.w    Rm,Rn</span>
<span>Unsigned, Rn <var title="multiply"></var> Rm <var title="store into (right)"></var> MACL
16 <var title="multiply"></var> 16 <var title="store into (right)"></var> 32 bits</span>
<span id="0010nnnnmmmm1110" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>1</var><var>1</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1-3</var><var>1-3</var><var>2</var><var>2</var><var>1-3</var><var></var><var>4/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mul</em>tiply as <em>U</em>nsigned [<em>W</em>ord]</span>
<span title="note">Performs 16-bit multiplication of the contents of general registers Rn and Rm,
and stores the 32-bit result in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register. The multiplication is
performed as an unsigned arithmetic operation. The contents of <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> are not
changed.</span>
<span title="section">Note</span>
<span title="note">On SH4, when <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of <abbr title="Multiply and Accumulate">MAC</abbr>*/MUL* is 5 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void MULU (int m, int n)
{
  MACL = ((unsigned long)(unsigned short)R[n]* (unsigned long)(unsigned short)R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">mulu r0,r1   ! Before execution: r0 = 0x00000002, r1 = 0xFFFFAAAA 
             ! After execution:  MACL = 0x00015554                
sts  MACL,r0 ! Operation result</span>
</span>
</label>
<input name="instruction" type="radio" id="row114" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row114">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>neg       Rm,Rn</span>
<span>0 <var title="subtract"></var> Rm <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm1011" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Neg</em>ate</span>
<span title="note">Finds the two's complement of the contents of general register Rm and stores
the result in Rn. That is, it subtracts Rm from 0 and stores the result in Rn.</span>
<span title="section">Operation</span>
<span title="operation">void NEG (int m, int n)
{
  R[n] = 0 - R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">neg r0,r1 ! Before execution: r0 = 0x00000001 
          ! After execution:  r1 = 0xFFFFFFFF</span>
</span>
</label>
<input name="instruction" type="radio" id="row115" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row115">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>negc      Rm,Rn</span>
<span>0 − Rm <var title="subtract"></var> T <var title="store into (right)"></var> Rn, borrow <var title="store into (right)"></var> T</span>
<span id="0110nnnnmmmm1010" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1010</var></span>
<span>Borrow <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Neg</em>ate with <em>C</em>arry</span>
<span title="note">Subtracts the contents of general register Rm and the <abbr title="Test condition bit flag">T</abbr> bit from 0 and stores
the result in Rn. A borrow resulting from the operation is reflected in the
<abbr title="Test condition bit flag">T</abbr> bit. This instruction can be  used for sign inversion of a value exceeding
32 bits.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be used to efficiently store the reversed <abbr title="Test condition bit flag">T</abbr> bit value
in a general register, if the MOVRT instruction is not available.</span>
<span title="section">Operation</span>
<span title="operation">void NEGC (int m, int n)
{
  unsigned long temp;
  temp = 0 - R[m];
  R[n] = temp - T;

  if (0 &lt; temp)
    T = 1;
  else
    T = 0;

  if (temp &lt; R[n])
    T = 1;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">! Sign inversion of r0:r1 (64 bits)

clrt
negc   r1,r1    ! Before execution: r1 = 0x00000001, T = 0
                ! After execution:  r1 = 0xFFFFFFFF, T = 1
negc   r0,r0    ! Before execution: r0 = 0x00000000, T = 1
                ! After execution:  r0 = 0xFFFFFFFF, T = 1

- - - - - - - - - - - - - - - -

! Store reversed T bit in r0

mov    #-1,r1
negc   r1,r0    ! r0 = 0 - (-1) - T
                ! r0 = 1 - T
                ! Notice that T bit will be modified by the negc operation.
                ! In this case, T will be always set to 1.</span>
</span>
</label>
<input name="instruction" type="radio" id="row116" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row116">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sub       Rm,Rn</span>
<span>Rn <var title="subtract"></var> Rm <var title="store into (right)"></var> Rn</span>
<span id="0011nnnnmmmm1000" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sub</em>tract Binary</span>
<span title="note">Subtracts the contents of general register Rm from the contents of general
register Rn and stores the result in Rn. For immediate data subtraction,
ADD #imm,Rn should be used.</span>
<span title="section">Operation</span>
<span title="operation">void SUB (int m, int n)
{
  R[n] -= R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">sub r0,r1 ! Before execution: r0 = 0x00000001, r1 = 0x80000000 
          ! After execution:  r1 = 0x7FFFFFFF</span>
</span>
</label>
<input name="instruction" type="radio" id="row117" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row117">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>subc      Rm,Rn</span>
<span>Rn − Rm <var title="subtract"></var> T <var title="store into (right)"></var> Rn, borrow <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm1010" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1010</var></span>
<span>Borrow <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sub</em>tract with <em>C</em>arry</span>
<span title="note">Subtracts the contents of general register Rm and the <abbr title="Test condition bit flag">T</abbr> bit from the contents of
general register Rn, and stores the result in Rn. A borrow resulting from the
operation is reflected in the <abbr title="Test condition bit flag">T</abbr> bit. This instruction is used for subtractions
exceeding 32 bits.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be used to store the <abbr title="Test condition bit flag">T</abbr> bit to all the bits of a
general register.</span>
<span title="section">Operation</span>
<span title="operation">void SUBC (int m, int n)
{
  unsigned long tmp0, tmp1;
  tmp1 = R[n] - R[m];
  tmp0 = R[n];
  R[n] = tmp1 - T;

  if (tmp0 &lt; tmp1)
    T = 1;
  else
    T = 0;

  if (tmp1 &lt; R[n])
    T = 1;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">! r0:r1(64 bits) - r2:r3(64 bits) = r0:r1(64 bits)

clrt
subc   r3,r1    ! Before execution: T = 0, r1 = 0x00000000, r3 = 0x00000001
                ! After execution:  T = 1, r1 = 0xFFFFFFFF
subc   r2,r0    ! Before execution: T = 1, r0 = 0x00000000, r2 = 0x00000000
                ! After execution:  T = 1, r0 = 0xFFFFFFFF

- - - - - - - - - - - - - - - -

! Store T bit to all bits of r0

subc   r0,r0    ! r0 = r0 - r0 - T
                ! r0 = 0 - T
                ! Notice that the T bit is modified by the subc operation.</span>
</span>
</label>
<input name="instruction" type="radio" id="row118" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row118">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>subv      Rm,Rn</span>
<span>Rn <var title="subtract"></var> Rm <var title="store into (right)"></var> Rn, underflow <var title="store into (right)"></var> T</span>
<span id="0011nnnnmmmm1011" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1011</var></span>
<span>Underflow <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sub</em>tract with `<em>V</em> Flag` Underflow Check</span>
<span title="note">Subtracts the contents of general register Rm from the contents of general
register Rn, and stores the result in Rn. If underflow occurs, the <abbr title="Test condition bit flag">T</abbr> bit is set.</span>
<span title="section">Operation</span>
<span title="operation">void SUBV (int m, int n)
{
  long dest, src, ans;

  if ((long)R[n] >= 0)
    dest = 0;
  else
    dest = 1;

  if ((long)R[m] >= 0)
    src = 0;
  else
    src = 1;

  src += dest;
  R[n] -= R[m];

  if ((long)R[n] >= 0)
    ans = 0;
  else
    ans = 1;

  ans += dest;

  if (src == 1)
  {
    if (ans == 1)
      T = 1;
    else
      T = 0;
  }
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">subv   r0,r1    ! Before execution: r0 = 0x00000002, r1 = 0x80000001
                ! After execution:  r1 = 0x7FFFFFFF, T = 1

subv   r2,r3    ! Before execution: r2 = 0xFFFFFFFE, r3 = 0x7FFFFFFE
                ! After execution:  r3 = 0x80000000, T = 1</span>
</span>
</label>
<span class="section_title">Logic Operation Instructions</span>
<input name="instruction" type="radio" id="row119" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row119">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>and       Rm,Rn</span>
<span>Rn <var title="binary and"></var> Rm <var title="store into (right)"></var> Rn</span>
<span id="0010nnnnmmmm1001" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>And</em></span>
<span title="note">ANDs the contents of general registers Rn and Rm and stores the result in Rn.</span>
<span title="section">Operation</span>
<span title="operation">void AND (int m, int n)
{
  R[n] &= R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">and r0,r1 ! Before execution: r0 = 0xAAAAAAAA, r1 = 0x55555555 
          ! After execution:  r1 = 0x00000000</span>
</span>
</label>
<input name="instruction" type="radio" id="row120" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row120">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>and       #imm,R0</span>
<span>R0 <var title="binary and"></var> (zero extend)imm <var title="store into (right)"></var> R0</span>
<span id="11001001iiiiiiii" class="colorized"><var title="Opcode Identifier">11001001</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>And</em></span>
<span title="note">ANDs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.</span>
<span title="section">Note</span>
<span title="note">Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
always cleared to zero.</span>
<span title="section">Operation</span>
<span title="operation">void ANDI (int i)
{
  R[0] &= (0x000000FF & (long)i);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">and #0x0F,r0 ! Before execution: r0 = 0xFFFFFFFF 
             ! After execution:  r0 = 0x0000000F</span>
</span>
</label>
<input name="instruction" type="radio" id="row121" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row121">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>and.b     #imm,@(R0,GBR)</span>
<span>(R0 <var title="add"></var> GBR) <var title="binary and"></var> (zero extend)imm <var title="store into (right)"></var> (R0 <var title="add"></var> GBR)</span>
<span id="11001101iiiiiiii" class="colorized"><var title="Opcode Identifier">11001101</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>4</var><var>3</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>2</var><var>2</var><var>3</var><var></var><var>4</var><var>3</var><var></var></span>
<span class="details">
<span title="section">Logical <em>And</em></span>
<span title="note">ANDs the contents of the memory byte indicated by the indirect <abbr title="Global Base Register">GBR</abbr> address with
the immediate value and writes the result back to the memory byte.</span>
<span title="section">Operation</span>
<span title="operation">void ANDM (long i)
{
  long temp = Read_8 (GBR + R[0]);
  temp &= 0x000000FF & (long)i;
  Write_8 (GBR + R[0], temp);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">and.b #0x80,@(r0,GBR) ! Before execution: @(r0,GBR) = 0xA5 
                      ! After execution:  @(r0,GBR) = 0x80</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row122" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row122">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>not       Rm,Rn</span>
<span><var title="binary not"></var>Rm <var title="store into (right)"></var> Rn</span>
<span id="0110nnnnmmmm0111" class="colorized"><var title="Opcode Identifier">0110</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>Not</em> Complement</span>
<span title="note">Finds the one's complement of the contents of general register Rm and stores
the result in Rn. That is, it inverts the Rm bits and stores the result in Rn.</span>
<span title="section">Operation</span>
<span title="operation">void NOT (int m, int n)
{
  R[n] = ~R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">not r0,r1 ! Before execution: r0 = 0xAAAAAAAA 
          ! After execution:  r1 = 0x55555555</span>
</span>
</label>
<input name="instruction" type="radio" id="row123" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row123">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>or        Rm,Rn</span>
<span>Rn <var title="binary or"></var> Rm <var title="store into (right)"></var> Rn</span>
<span id="0010nnnnmmmm1011" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>Or</em></span>
<span title="note">ORs the contents of general registers Rn and Rm and stores the result in Rn.</span>
<span title="section">Operation</span>
<span title="operation">void OR (int m, int n)
{
  R[n] |= R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">or r0,r1 ! Before execution: r0 = 0xAAAA5555, r1 = 0x55550000 
         ! After execution:  r1 = 0xFFFF5555</span>
</span>
</label>
<input name="instruction" type="radio" id="row124" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row124">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>or        #imm,R0</span>
<span>R0 <var title="binary or"></var> (zero extend)imm <var title="store into (right)"></var> R0</span>
<span id="11001011iiiiiiii" class="colorized"><var title="Opcode Identifier">11001011</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>Or</em></span>
<span title="note">ORs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.</span>
<span title="section">Note</span>
<span title="note">Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
not modified.</span>
<span title="section">Operation</span>
<span title="operation">void ORI (int i)
{
  R[0] |= (0x000000FF & (long)i);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">or #0xF0,r0 ! Before execution: r0 = 0x00000008 
            ! After execution:  r0 = 0x000000F8</span>
</span>
</label>
<input name="instruction" type="radio" id="row125" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row125">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>or.b      #imm,@(R0,GBR)</span>
<span>(R0 <var title="add"></var> GBR) <var title="binary or"></var> (zero extend)imm <var title="store into (right)"></var> (R0 <var title="add"></var> GBR)</span>
<span id="11001111iiiiiiii" class="colorized"><var title="Opcode Identifier">11001111</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>4</var><var>3</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>2</var><var>2</var><var>3</var><var></var><var>4</var><var>3</var><var></var></span>
<span class="details">
<span title="section">Logical <em>Or</em></span>
<span title="note">ORs the contents of the memory byte indicated by the indirect <abbr title="Global Base Register">GBR</abbr> address with
the immediate value and writes the result back to the memory byte.</span>
<span title="section">Operation</span>
<span title="operation">void ORM (int i)
{
  long temp = Read_8 (GBR + R[0]);
  temp |= (0x000000FF & (long)i);
  Write_8 (GBR + R[0], temp);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">or.b #0x50,@(r0,GBR) ! Before execution: @(r0,GBR) = 0xA5 
                     ! After execution:  @(r0,GBR) = 0xF5</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row126" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row126">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tas.b     @Rn</span>
<span>If (Rn) <var title="equality"></var> 0: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T
1 <var title="store into (right)"></var> MSB of (Rn)</span>
<span id="0100nnnn00011011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00011011</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>5</var><var>4</var><var></var></span>
<span class="cycle_grid"><var>4</var><var>4</var><var>3</var><var>3</var><var>3/4</var><var></var><var>5</var><var>4</var><var></var></span>
<span class="details">
<span title="section"><em>T</em>est <em>a</em>nd <em>S</em>et</span>
<span title="note">Reads byte data from the address specified by general register Rn, and sets the
<abbr title="Test condition bit flag">T</abbr> bit to 1 if the data is 0, or clears the <abbr title="Test condition bit flag">T</abbr> bit to 0 if the data is not 0.
Then, data bit 7 is set to 1, and the data is written to the address specified
by Rn. During this operation, the bus is not released.
<br /><br />

On SH4 and SH4A this instruction purges the cache block corresponding to the
memory area specified by the contents of general register Rn.
The purge operation is executed as follows.<br />
In a purge operation, data is accessed using the contents of general register Rn
as the effective address. If there is a cache hit and the corresponding cache
block is dirty (U bit = 1), the contents of that cache block are written back to
external memory, and the cache block is then invalidated (by clearing the <abbr title="Overflow bit flag">V</abbr> bit
to 0). If there is a cache hit and the corresponding cache block is clean (U bit
= 0), the cache block is simply invalidated (by clearing the <abbr title="Overflow bit flag">V</abbr> bit to 0). A
purge is not executed in the event of a cache miss, or if the accessed memory
location is non-cacheable.</span>
<span title="section">Note</span>
<span title="note">The two TAS.B memory accesses are executed automatically. Another memory access
is not executed between the two TAS.B accesses.
<br /><br />
On SH3 the destination of the TAS instruction should be placed in a
non-cacheable space when the cache is enabled.</span>
<span title="section">Operation</span>
<span title="operation">void TAS (int n)
{
  int temp = Read_8 (R[n]); // Bus Lock

  if (temp == 0)
    T = 1;
  else
    T = 0;

  temp |= 0x00000080;
  Write_8 (R[n], temp);  // Bus unlock
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">_LOOP: tas.b @r7   ! r7 = 1000                             
       bf    _LOOP ! Loops until data in address 1000 is 0</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row127" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row127">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tst       Rm,Rn</span>
<span>If Rn <var title="binary and"></var> Rm <var title="equality"></var> 0: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="0010nnnnmmmm1000" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1000</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>T</em>e<em>st</em></span>
<span title="note">ANDs the contents of general registers Rn and Rm, and sets the <abbr title="Test condition bit flag">T</abbr> bit if the
result is zero. If the result is nonzero, the <abbr title="Test condition bit flag">T</abbr> bit is cleared. The contents of
Rn are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void TST (int m, int n)
{
  if ((R[n] & R[m]) == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">tst r0,r0 ! Before execution: r0 = 0x00000000 
          ! After execution:  T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row128" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row128">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tst       #imm,R0</span>
<span>If R0 <var title="binary and"></var> (zero extend)imm <var title="equality"></var> 0: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="11001000iiiiiiii" class="colorized"><var title="Opcode Identifier">11001000</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical <em>T</em>e<em>st</em></span>
<span title="note">ANDs the contents of general register R0 and the zero-extended immediate value
and sets the <abbr title="Test condition bit flag">T</abbr> bit if the result is zero. If the result is nonzero, the <abbr title="Test condition bit flag">T</abbr> bit
is cleared. The contents of Rn are not changed.</span>
<span title="section">Note</span>
<span title="note">Since the 8-bit immediate value is zero-extended, this instruction can only be
used to test the lower 8 bits of R0.</span>
<span title="section">Operation</span>
<span title="operation">void TSTI (int i)
{
  long temp = R[0] & (0x000000FF & (long)i);

  if (temp == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">tst #0x80,r0 ! Before execution: r0 = 0xFFFFFF7F 
             ! After execution:  T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row129" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row129">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>tst.b     #imm,@(R0,GBR)</span>
<span>If (R0 <var title="add"></var> GBR) <var title="binary and"></var> (zero extend)imm <var title="equality"></var> 0: 1 <var title="store into (right)"></var> T
Else 0: <var title="store into (right)"></var> T</span>
<span id="11001100iiiiiiii" class="colorized"><var title="Opcode Identifier">11001100</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>3</var><var>3</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>3</var><var>3</var><var>3</var><var></var><var>3</var><var>3</var><var></var></span>
<span class="details">
<span title="section">Logical <em>T</em>e<em>st</em></span>
<span title="note">ANDs the contents of the memory byte indicated by the indirect <abbr title="Global Base Register">GBR</abbr> address with
the zero-extended immediate value and sets the <abbr title="Test condition bit flag">T</abbr> bit if the result is zero.
If the result is nonzero, the <abbr title="Test condition bit flag">T</abbr> bit is cleared.
The contents of the memory byte are not changed.</span>
<span title="section">Operation</span>
<span title="operation">void TSTM (int i)
{
  long temp = Read_8 (GBR + R[0]);
  temp &= (0x000000FF & (long)i);

  if (temp == 0)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">tst.b #0xA5,@(r0,GBR) ! Before execution: @(r0,GBR) = 0xA5 
                      ! After execution:  T = 0</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row130" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row130">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xor       Rm,Rn</span>
<span>Rn <var title="binary xor"></var> Rm <var title="store into (right)"></var> Rn</span>
<span id="0010nnnnmmmm1010" class="colorized"><var title="Opcode Identifier">0010</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical E<em>x</em>clusive <em>Or</em></span>
<span title="note">XORs the contents of general registers Rn and Rm and stores the result in Rn.</span>
<span title="section">Operation</span>
<span title="operation">void XOR (long m, long n)
{
  R[n] ^= R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">xor r0,r1 ! Before execution: r0 = 0xAAAAAAAA, r1 = 0x55555555 
          ! After execution:  r1 = 0xFFFFFFFF</span>
</span>
</label>
<input name="instruction" type="radio" id="row131" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row131">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xor       #imm,R0</span>
<span>R0 <var title="binary xor"></var> (zero extend)imm <var title="store into (right)"></var> R0</span>
<span id="11001010iiiiiiii" class="colorized"><var title="Opcode Identifier">11001010</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Logical E<em>x</em>clusive <em>Or</em></span>
<span title="note">XORs the contents of general register R0 and the zero-extended immediate value
and stores the result in R0.</span>
<span title="section">Note</span>
<span title="note">Since the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are
not modified.</span>
<span title="section">Operation</span>
<span title="operation">void XORI (int i)
{
  R[0] ^= (0x000000FF & (long)i);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">xor #0xF0,r0 ! Before execution: r0 = 0xFFFFFFFF 
             ! After execution:  r0 = 0xFFFFFF0F</span>
</span>
</label>
<input name="instruction" type="radio" id="row132" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row132">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>xor.b     #imm,@(R0,GBR)</span>
<span>(R0 <var title="add"></var> GBR) <var title="binary xor"></var> (zero extend)imm <var title="store into (right)"></var> (R0 <var title="add"></var> GBR)</span>
<span id="11001110iiiiiiii" class="colorized"><var title="Opcode Identifier">11001110</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>4</var><var>3</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>3</var><var>3</var><var>2</var><var></var><var>4</var><var>3</var><var></var></span>
<span class="details">
<span title="section">Logical E<em>x</em>clusive <em>Or</em></span>
<span title="note">XORs the contents of the memory byte indicated by the indirect <abbr title="Global Base Register">GBR</abbr> address with
the immediate value and writes the result back to the memory byte.</span>
<span title="section">Operation</span>
<span title="operation">void XORM (int i)
{
  int temp = Read_8 (GBR + R[0]);
  temp ^= (0x000000FF & (long)i);
  Write_8 (GBR + R[0], temp);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">xor.b #0xA5,@(r0,GBR) ! Before execution: @(r0,GBR) = 0xA5 
                      ! After execution:  @(r0,GBR) = 0x00</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var><br /></var>
  <var>Exceptions are checked taking a data access by this instruction as a byte load</var>
  <var>and a byte store.</var>
</span>
</span>
</label>
<span class="section_title">Shift Instructions</span>
<input name="instruction" type="radio" id="row133" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row133">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotcl     Rn</span>
<span>T <var title="shift bits left"></var> Rn <var title="shift bits left"></var> T</span>
<span id="0100nnnn00100100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100100</var></span>
<span>MSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Rot</em>ate with <em>C</em>arry <em>L</em>eft</span>
<span title="note">Rotates the contents of general register Rn one bit to the left through the
<abbr title="Test condition bit flag">T</abbr> bit, and stores the result in Rn. The bit rotated out of the operand is
transferred to the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Rotate with Carry Left" class="image_filter" src="rotcl.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void ROTCL (int n)
{
  long temp;

  if ((R[n] & 0x80000000) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &lt;&lt;= 1;

  if (T == 1)
    R[n] |= 0x00000001;
  else
    R[n] &= 0xFFFFFFFE;

  if (temp == 1)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">rotcl r0 ! Before execution: r0 = 0x80000000, T = 0 
         ! After execution:  r0 = 0x00000000, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row134" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row134">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotcr     Rn</span>
<span>T <var title="shift bits right"></var> Rn <var title="shift bits right"></var> T</span>
<span id="0100nnnn00100101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100101</var></span>
<span>LSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Rot</em>ate with <em>C</em>arry <em>R</em>ight</span>
<span title="note">Rotates the contents of general register Rn one bit to the right through the
<abbr title="Test condition bit flag">T</abbr> bit, and stores the result in Rn. The bit rotated out of the operand is
transferred to the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Rotate with Carry Right" class="image_filter" src="rotcr.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void ROTCR (int n)
{
  long temp;

  if ((R[n] & 0x00000001) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &gt;&gt;= 1;

  if (T == 1)
    R[n] |= 0x80000000;
  else
    R[n] &= 0x7FFFFFFF;

  if (temp == 1)
    T = 1;
  else
    T = 0;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">rotcr r0 ! Before execution: r0 = 0x00000001, T = 1 
         ! After execution:  r0 = 0x80000000, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row135" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row135">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotl      Rn</span>
<span>T <var title="shift bits left"></var> Rn <var title="shift bits left"></var> MSB</span>
<span id="0100nnnn00000100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000100</var></span>
<span>MSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Rot</em>ate <em>L</em>eft</span>
<span title="note">Rotates the contents of general register Rn one bit to the left, and stores the
result in Rn. The bit rotated out of the operand is transferred to the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Rotate Left" class="image_filter" src="rotl.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void ROTL (int n)
{
  if ((R[n] & 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;

  if (T == 1)
    R[n] |= 0x00000001;
  else
    R[n] &= 0xFFFFFFFE;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">rotl r0 ! Before execution: r0 = 0x80000000, T = 0 
        ! After execution:  r0 = 0x00000001, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row136" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row136">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rotr      Rn</span>
<span>LSB <var title="shift bits right"></var> Rn <var title="shift bits right"></var> T</span>
<span id="0100nnnn00000101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000101</var></span>
<span>LSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Rot</em>ate <em>R</em>ight</span>
<span title="note">Rotates the contents of general register Rn one bit to the right, and stores the
result in Rn. The bit rotated out of the operand is transferred to the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Rotate Right" class="image_filter" src="rotr.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void ROTR (int n)
{
  if ((R[n] & 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  R[n] &gt;&gt;= 1;

  if (T == 1)
    R[n] |= 0x80000000;
  else
    R[n] &= 0x7FFFFFFF;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">rotr r0 ! Before execution: r0 = 0x00000001, T = 0 
        ! After execution:  r0 = 0x80000000, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row137" />
<label class="summary SH2A SH3 SH4 SH4A" for="row137">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shad      Rm,Rn</span>
<span>If Rm <var title="greater than or equal"></var> 0: Rn <var title="shift bits left"></var> Rm <var title="store into (right)"></var> Rn
If Rm <var title="less than"></var> 0: Rn <var title="shift bits right"></var> <var title="absolute value">Rm</var> <var title="store into (right)"></var> [MSB <var title="store into (right)"></var> Rn]</span>
<span id="0100nnnnmmmm1100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>A</em>rithmetic <em>D</em>ynamically</span>
<span title="note">Arithmetically shifts the contents of general register Rn. General register Rm
specifies the shift direction and the number of bits to be shifted.
<br /><br />
Rn register contents are shifted to the left if the Rm register value is
positive, and to the right if negative. In a shift to the right, the <abbr title="Most Significant Bit">MSB</abbr> is
added at the upper end.
<br /><br />
The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)
of the Rm register. If the value is negative (<abbr title="Most Significant Bit">MSB</abbr> = 1), the Rm register is
represented as a two's complement. The left shift range is 0 to 31, and the
right shift range, 1 to 32.
<br /><img alt="Shift Arithmetic Dynamically" class="image_filter" src="shad.svg" height="220" /></span>
<span title="section">Note</span>
<span title="note">On SH4, if there is a load of the shift amount immediately before an SHAD/SHLD
instruction, the latency of the load is increased by 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void SHAD (int m, int n)
{
  int sgn = R[m] & 0x80000000;

  if (sgn == 0)
    R[n] &lt;&lt;= (R[m] & 0x1F);
  else if ((R[m] & 0x1F) == 0)
  {
    if ((R[n] & 0x80000000) == 0)
      R[n] = 0;
    else
      R[n] = 0xFFFFFFFF;
  }
  else
    R[n] = (long)R[n] &gt;&gt; ((~R[m] & 0x1F) + 1);

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row138" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row138">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shal      Rn</span>
<span>T <var title="shift bits left"></var> Rn <var title="shift bits left"></var> 0</span>
<span id="0100nnnn00100000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100000</var></span>
<span>MSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>A</em>rithmetic <em>L</em>eft</span>
<span title="note">Arithmetically shifts the contents of general register Rn one bit to the left
and stores the result in Rn. The bit shifted out of the operand is transferred
to the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Shift Arithmetic Left" class="image_filter" src="shal.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void SHAL (int n)
{
  if ((R[n] & 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shal r0 ! Before execution: r0 = 0x80000001, T = 0 
        ! After execution:  r0 = 0x00000002, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row139" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row139">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shar      Rn</span>
<span>MSB <var title="shift bits right"></var> Rn <var title="shift bits right"></var> T</span>
<span id="0100nnnn00100001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100001</var></span>
<span>LSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>A</em>rithmetic <em>R</em>ight</span>
<span title="note">Arithmetically shifts the contents of general register Rn one bit to the right
and stores the result in Rn. The bit shifted out of the operand is transferred
to the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Shift Arithmetic Right" class="image_filter" src="shar.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void SHAR (int n)
{
  long temp;

  if ((R[n] & 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  if ((R[n] & 0x80000000) == 0)
    temp = 0;
  else
    temp = 1;

  R[n] &gt;&gt;= 1;

  if (temp == 1)
    R[n] |= 0x80000000;
  else
    R[n] &= 0x7FFFFFFF;

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shar r0 ! Before execution: r0 = 0x80000001, T = 0 
        ! After execution:  r0 = 0xC0000000, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row140" />
<label class="summary SH2A SH3 SH4 SH4A" for="row140">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shld      Rm,Rn</span>
<span>If Rm <var title="greater than or equal"></var> 0: Rn <var title="shift bits left"></var> Rm <var title="store into (right)"></var> Rn
If Rm <var title="less than"></var> 0: Rn <var title="shift bits right"></var> <var title="absolute value">Rm</var> <var title="store into (right)"></var> [0 <var title="store into (right)"></var> Rn]</span>
<span id="0100nnnnmmmm1101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>D</em>ynamically</span>
<span title="note">Logically shifts the contents of general register Rn. General register Rm
specifies the shift direction and the number of bits to be shifted.
<br /><br />
Rn register contents are shifted to the left if the Rm register value is
positive, and to the right if negative. In a shift to the right, 0s are added
at the upper end.
<br /><br />
The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)
of the Rm register. If the value is negative (<abbr title="Most Significant Bit">MSB</abbr> = 1), the Rm register is
represented as a two's complement. The left shift range is 0 to 31, and the
right shift range, 1 to 32.
<br /><img alt="Shift Logical Dynamically" class="image_filter" src="shld.svg" height="220" /></span>
<span title="section">Note</span>
<span title="note">On SH4, if there is a load of the shift amount immediately before an SHAD/SHLD
instruction, the latency of the load is increased by 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void SHLD (int m, int n)
{
  int sgn = R[m] & 0x80000000;

  if (sgn == 0)
    R[n] &lt;&lt;= (R[m] & 0x1F);
  else if ((R[m] & 0x1F) == 0)
    R[n] = 0;
  else
    R[n] = (unsigned)R[n] &gt;&gt; ((~R[m] & 0x1F) + 1);

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row141" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row141">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll      Rn</span>
<span>T <var title="shift bits left"></var> Rn <var title="shift bits left"></var> 0</span>
<span id="0100nnnn00000000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000000</var></span>
<span>MSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>L</em>eft</span>
<span title="note">Logically shifts the contents of general register Rn one bit to the left and
stores the result in Rn. The bit shifted out of the operand is transferred to
the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Shift Logical Left" class="image_filter" src="shll.svg" height="100" /></span>
<span title="section">Note</span>
<span title="note">Effectively, the operation performed is the same as the SHAL instruction.</span>
<span title="section">Operation</span>
<span title="operation">void SHLL (int n)
{
  if ((R[n] & 0x80000000) == 0)
    T = 0;
  else
    T = 1;

  R[n] &lt;&lt;= 1;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shll r0 ! Before execution: r0 = 0x80000001, T = 0 
        ! After execution:  r0 = 0x00000002, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row142" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row142">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll2     Rn</span>
<span>Rn <var title="shift bits left"></var> 2 <var title="store into (right)"></var> Rn</span>
<span id="0100nnnn00001000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00001000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>L</em>eft <em>2</em> Bits</span>
<span title="note">Logically shifts the contents of general register Rn 2 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Left 2 Bits" class="image_filter" src="shll2.svg" height="120" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLL2 (int n)
{
  R[n] &lt;&lt;= 2;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shll2 r0 ! Before execution: r0 = 0x12345678 
         ! After execution:  r0 = 0x48D159E0</span>
</span>
</label>
<input name="instruction" type="radio" id="row143" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row143">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll8     Rn</span>
<span>Rn <var title="shift bits left"></var> 8 <var title="store into (right)"></var> Rn</span>
<span id="0100nnnn00011000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00011000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>L</em>eft <em>8</em> Bits</span>
<span title="note">Logically shifts the contents of general register Rn 8 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Left 8 Bits" class="image_filter" src="shll8.svg" height="120" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLL8 (int n)
{
  R[n] &lt;&lt;= 8;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shll8 r0 ! Before execution: r0 = 0x12345678 
         ! After execution:  r0 = 0x34567800</span>
</span>
</label>
<input name="instruction" type="radio" id="row144" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row144">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shll16    Rn</span>
<span>Rn <var title="shift bits left"></var> 16 <var title="store into (right)"></var> Rn</span>
<span id="0100nnnn00101000" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00101000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>L</em>eft <em>16</em> Bits</span>
<span title="note">Logically shifts the contents of general register Rn 16 bits to the left and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Left 16 Bits" class="image_filter" src="shll16.svg" height="120" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLL16 (int n)
{
  R[n] &lt;&lt;= 16;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shll16 r0 ! Before execution: r0 = 0x12345678 
          ! After execution:  r0 = 0x56780000</span>
</span>
</label>
<input name="instruction" type="radio" id="row145" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row145">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr      Rn</span>
<span>0 <var title="shift bits right"></var> Rn <var title="shift bits right"></var> T</span>
<span id="0100nnnn00000001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000001</var></span>
<span>LSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>R</em>ight</span>
<span title="note">Logically shifts the contents of general register Rn one bit to the right and
stores the result in Rn. The bit shifted out of the operand is transferred to
the <abbr title="Test condition bit flag">T</abbr> bit.
<br /><img alt="Shift Logical Right" class="image_filter" src="shlr.svg" height="100" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLR (int n)
{
  if ((R[n] & 0x00000001) == 0)
    T = 0;
  else
    T = 1;

  R[n] &gt;&gt;= 1;
  R[n] &= 0x7FFFFFFF;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shlr r0 ! Before execution: r0 = 0x80000001, T = 0 
        ! After execution:  r0 = 0x40000000, T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row146" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row146">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr2     Rn</span>
<span>Rn <var title="shift bits right"></var> 2 <var title="store into (right)"></var> [0 <var title="store into (right)"></var> Rn]</span>
<span id="0100nnnn00001001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00001001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>R</em>ight <em>2</em> Bits</span>
<span title="note">Logically shifts the contents of general register Rn 2 bits to the right, and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Right 2 Bits" class="image_filter" src="shlr2.svg" height="120" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLR2 (int n)
{
  R[n] &gt;&gt;= 2;
  R[n] &= 0x3FFFFFFF;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shlr2 r0 ! Before execution: r0 = 0x12345678 
         ! After execution:  r0 = 0x048D159E</span>
</span>
</label>
<input name="instruction" type="radio" id="row147" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row147">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr8     Rn</span>
<span>Rn <var title="shift bits right"></var> 8 <var title="store into (right)"></var> [0 <var title="store into (right)"></var> Rn]</span>
<span id="0100nnnn00011001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00011001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>R</em>ight <em>8</em> Bits</span>
<span title="note">Logically shifts the contents of general register Rn 8 bits to the right, and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Right 8 Bits" class="image_filter" src="shlr8.svg" height="120" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLR8 (int n)
{
  R[n] &gt;&gt;= 8;
  R[n] &= 0x00FFFFFF;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shlr8 r0 ! Before execution: r0 = 0x12345678 
         ! After execution:  r0 = 0x00123456</span>
</span>
</label>
<input name="instruction" type="radio" id="row148" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row148">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>shlr16    Rn</span>
<span>Rn <var title="shift bits right"></var> 16 <var title="store into (right)"></var> [0 <var title="store into (right)"></var> Rn]</span>
<span id="0100nnnn00101001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00101001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>EX</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Sh</em>ift <em>L</em>ogical <em>R</em>ight <em>16</em> Bits</span>
<span title="note">Logically shifts the contents of general register Rn 16 bits to the right and
stores the result in Rn. The bits shifted out of the operand are discarded.
<br /><img alt="Shift Logical Right 16 Bits" class="image_filter" src="shlr16.svg" height="120" /></span>
<span title="section">Operation</span>
<span title="operation">void SHLR16 (int n)
{
  R[n] &gt;&gt;= 16;
  R[n] &= 0x0000FFFF;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">shlr16 r0 ! Before execution: r0 = 0x12345678 
          ! After execution:  r0 = 0x00001234</span>
</span>
</label>
<span class="section_title">Branch Instructions</span>
<input name="instruction" type="radio" id="row149" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row149">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bf        label</span>
<span>If T <var title="equality"></var> 0: disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
Else: nop</span>
<span id="10001011dddddddd" class="colorized"><var title="Opcode Identifier">10001011</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1/3</var><var>1/3</var><var>1</var><var></var><var>1</var><var>1-3</var><var></var></span>
<span class="cycle_grid"><var>1/3</var><var>1/3</var><var>1/3</var><var>1/3</var><var>1/3</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>B</em>ranch if <em>F</em>alse</span>
<span title="note">This is a conditional branch instruction that references the <abbr title="Test condition bit flag">T</abbr> bit. The branch
is taken if <abbr title="Test condition bit flag">T</abbr> = 0, and not taken if <abbr title="Test condition bit flag">T</abbr> = 1. The branch destination is address
(<abbr title="Program Counter">PC</abbr> + 4 + displacement × 2).  The <abbr title="Program Counter">PC</abbr> source value is the BF instruction address.
As the 8-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -256 to +254 bytes from the BF
instruction.</span>
<span title="section">Note</span>
<span title="note">If the branch destination cannot be reached, the branch must be handled by using
BF in combination with a BRA or JMP instruction, for example.
<br /><br />
On some SH4 implementations a branch with a displacement value of zero does not
cause the pipeline I-stage to be stalled even if the branch is taken.  This can
be utilized for efficient conditional operations.
<br /><br />
On some SH2E implementations (SH7055) there is an <abbr title="Floating Point Unit">FPU</abbr> related hardware bug
which affects this instruction.  The recommended workaround is to use bt/s with
a nop in the delay slot.
See also documents "sh2eoc.pdf" and "win_update_a.pdf".</span>
<span title="section">Operation</span>
<span title="operation">void BF (int d)
{
  int disp;
  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 0)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">          clrt          ! T is always cleared to 0                                                                      
          bt   TARGET_T ! Does not branch, because T = 0                                                                
          bf   TARGET_F ! Branches to TARGET_F, because T = 0                                                           
          nop                                                                                                           
          nop           ! ← The PC location is used to calculate the branch destination address of the BF instruction 
TARGET_F:               ! ← Branch destination of the BF instruction</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row150" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row150">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bf/s      label</span>
<span>If T <var title="equality"></var> 0: disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
Else: nop
(Delayed branch)</span>
<span id="10001111dddddddd" class="colorized"><var title="Opcode Identifier">10001111</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var>1/2</var><var>1/2</var><var>1</var><var></var><var>1</var><var>1-3</var><var></var></span>
<span class="cycle_grid"><var></var><var>1/2</var><var>1/2</var><var>1/2</var><var>1/2</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">This is a delayed conditional branch instruction that references the <abbr title="Test condition bit flag">T</abbr> bit.
If <abbr title="Test condition bit flag">T</abbr> = 1, the next instruction is executed and the branch is not taken.
If <abbr title="Test condition bit flag">T</abbr> = 0, the branch is taken after execution of the next instruction.
<br /><br />
The branch destination is address (<abbr title="Program Counter">PC</abbr> + 4 + displacement × 2). The <abbr title="Program Counter">PC</abbr> source
value is the BF/<abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> instruction address.  As the 8-bit displacement is multiplied
by two after sign-extension, the branch destination can be located in the range
from -256 to +254 bytes from the BF/<abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> instruction.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, when the branch condition is satisfied,
the instruction following this instruction is executed before the branch
destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
If this instruction is located in the delay slot immediately following a delayed
branch instruction, it is identified as a slot illegal instruction.
<br /><br />
If the branch destination cannot be reached, the branch must be handled by using
BF/<abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> in combination with a BRA or JMP instruction, for example.</span>
<span title="section">Operation</span>
<span title="operation">void BFS (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;
  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 0)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 4;

  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">          clrt          ! T is always 0                                                                                   
          bt/s TARGET_T ! Does not branch, because T = 0                                                                  
          nop                                                                                                             
          bf/s TARGET_F ! Branches to TARGET_F, because T = 0                                                             
          add  r0,r1    ! Executed before branch .                                                                        
          nop           ! ← The PC location is used to calculate the branch destination address of the BF/S instruction 
TARGET_F:               ! ← Branch destination of the BF/S instruction</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row151" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row151">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bt        label</span>
<span>If T <var title="equality"></var> 1: disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
Else: nop</span>
<span id="10001001dddddddd" class="colorized"><var title="Opcode Identifier">10001001</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1/3</var><var>1/3</var><var>1</var><var></var><var>1</var><var>1-3</var><var></var></span>
<span class="cycle_grid"><var>1/3</var><var>1/3</var><var>1/3</var><var>1/3</var><var>1/3</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>B</em>ranch if <em>T</em>rue</span>
<span title="note">This is a conditional branch instruction that references the <abbr title="Test condition bit flag">T</abbr> bit. The branch
is taken if <abbr title="Test condition bit flag">T</abbr> = 1, and not taken if <abbr title="Test condition bit flag">T</abbr> = 0.  The branch destination is address
(<abbr title="Program Counter">PC</abbr> + 4 + displacement × 2). The <abbr title="Program Counter">PC</abbr> source value is the BT instruction address.
As the 8-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -256 to +254 bytes from the BT
instruction.</span>
<span title="section">Note</span>
<span title="note">If the branch destination cannot be reached, the branch must be handled by using
BT in combination with a BRA or JMP instruction, for example.
<br /><br />
On some SH4 implementations a branch with a displacement value of zero does not
cause the pipeline I-stage to be stalled even if the branch is taken.  This can
be utilized for efficient conditional operations.
<br /><br />
On some SH2E implementations (SH7055) there is an <abbr title="Floating Point Unit">FPU</abbr> related hardware bug
which affects this instruction.  The recommended workaround is to use bt/s with
a nop in the delay slot.
See also documents "sh2eoc.pdf" and "win_update_a.pdf".</span>
<span title="section">Operation</span>
<span title="operation">void BT (int d)
{
  int disp;
  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 1)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">          sett          ! T is always 1                                                                                 
          bf   TARGET_F ! Does not branch, because T = 1                                                                
          bt   TARGET_T ! Branches to TARGET_T, because T = 1                                                           
          nop                                                                                                           
          nop           ! ← The PC location is used to calculate the branch destination address of the BT instruction 
TARGET_T:               ! ← Branch destination of the BT instruction</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row152" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row152">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bt/s      label</span>
<span>If T <var title="equality"></var> 1: disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
Else: nop
(Delayed branch)</span>
<span id="10001101dddddddd" class="colorized"><var title="Opcode Identifier">10001101</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var>1/2</var><var>1/2</var><var>1</var><var></var><var>1</var><var>1-3</var><var></var></span>
<span class="cycle_grid"><var></var><var>1/2</var><var>1/2</var><var>1/2</var><var>1/2</var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">This is a conditional branch instruction that references the <abbr title="Test condition bit flag">T</abbr> bit. The branch
is taken if <abbr title="Test condition bit flag">T</abbr> = 1, and not taken if <abbr title="Test condition bit flag">T</abbr> = 0.  The <abbr title="Program Counter">PC</abbr> source value is the BT/<abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr>
instruction address. As the 8-bit displacement is multiplied by two after
sign-extension, the branch destination can be located in the range from -256 to
+254 bytes from the BT/<abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> instruction.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, when the branch condition is satisfied,
the instruction following this instruction is executed before the branch
destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.
<br /><br />
If the branch destination cannot be reached, the branch must be handled by using
BT/<abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> in combination with a BRA or JMP instruction, for example.</span>
<span title="section">Operation</span>
<span title="operation">void BTS (int d)
{
  int disp;
  unsigned temp;
  temp = PC;

  if ((d & 0x80) == 0)
    disp = (0x000000FF & d);
  else
    disp = (0xFFFFFF00 | d);

  if (T == 1)
    PC = PC + 4 + (disp &lt;&lt; 1);
  else
    PC += 4;

  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">          sett          ! T is always 1                                                                                   
          bf/s TARGET_F ! Does not branch, because T = 1                                                                  
          nop                                                                                                             
          bt/s TARGET_T ! Branches to TARGET, because T = 1                                                               
          add  r0,r1    ! Executes before branching.                                                                      
          nop           ! ← The PC location is used to calculate the branch destination address of the BT/S instruction 
TARGET_T:               ! ← Branch destination of the BT/S instruction</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row153" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row153">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bra       label</span>
<span>disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
(Delayed branch)</span>
<span id="1010dddddddddddd" class="colorized"><var title="Opcode Identifier">1010</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1</var><var>1-3</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Bra</em>nch</span>
<span title="note">This is an unconditional branch instruction. The branch destination is address
(<abbr title="Program Counter">PC</abbr> + 4 + displacement × 2). The <abbr title="Program Counter">PC</abbr> source value is the BRA instruction address.
As the 12-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -4096 to +4094 bytes from the BRA
instruction. If the branch destination cannot be reached, this branch can be
performed with a JMP instruction.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void BRA (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;

  if ((d & 0x800) == 0)
    disp = (0x00000FFF & d);
  else
    disp = (0xFFFFF000 | d);

  PC = PC + 4 + (disp &lt;&lt; 1);
  Delay_Slot(temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">        bra TARGET ! Branches to TARGET                                                                             
        add r0,r1  ! Executes ADD before branching                                                                  
        nop        ! ← The PC location is used to calculate the branch destination address of the BRA instruction 
TARGET:            ! ← Branch destination of the BRA instruction</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row154" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row154">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>braf      Rm</span>
<span>Rm <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
(Delayed branch)</span>
<span id="0000mmmm00100011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00100011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Bra</em>nch <em>F</em>ar</span>
<span title="note">This is an unconditional branch instruction. The branch destination is address
(<abbr title="Program Counter">PC</abbr> + 4 + Rm).</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void BRAF (int m)
{
  unsigned int temp;
  temp = PC;
  PC = PC + 4 + R[m];
  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">         mov.l #(TARGET-BSRF_PC),r0 ! Sets displacement.                                   
         bra   TARGET               ! Branches to TARGET                                   
         add   r0,r1                ! Executes ADD before branching                        
BRAF_PC:                            ! ← The PC location is used to calculate the         
                                    !   branch destination address of the BRAF instruction 
         nop                                                                               
TARGET:                             ! ← Branch destination of the BRAF instruction</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row155" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row155">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bsr       label</span>
<span>PC <var title="add"></var> 4 <var title="store into (right)"></var> PR, disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
(Delayed branch)</span>
<span id="1011dddddddddddd" class="colorized"><var title="Opcode Identifier">1011</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>BR</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1</var><var>1-3</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>B</em>ranch to <em>S</em>ub<em>r</em>outine</span>
<span title="note">Branches to address (<abbr title="Program Counter">PC</abbr> + 4 + displacement × 2), and stores address (<abbr title="Program Counter">PC</abbr> + 4) in
<abbr title="Procedure Register">PR</abbr>. The <abbr title="Program Counter">PC</abbr> source value is the BSR instruction address.
As the 12-bit displacement is multiplied by two after sign-extension, the branch
destination can be located in the range from -4096 to +4094 bytes from the BSR
instruction. If the branch destination cannot be reached, this branch can be
performed with a JSR instruction.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void BSR (int d)
{
  int disp;
  unsigned int temp;
  temp = PC;

  if ((d & 0x800) == 0)
    disp = (0x00000FFF & d);
  else
    disp = (0xFFFFF000 | d);

  PR = PC + 4;
  PC = PC + 4 + (disp &lt;&lt; 1);
  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">        bsr TARGET ! Branches to TARGET                                              
        mov r3,r4  ! Executes the MOV instruction before branching                   
        add r0,r1  ! ← The PC location is used to calculate the branch destination 
                   !   address of the BSR instruction (return address for when the   
                   !   subroutine procedure is completed (PR data))                  
TARGET:            ! ← Procedure entrance                                          
        mov r2,r3                                                                    
        rts        ! Returns to the above ADD instruction                            
        mov #1,r0  ! Executes MOV before branching</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row156" />
<label class="summary SH2 SH2E SH2A SH3 SH4 SH4A" for="row156">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>bsrf      Rm</span>
<span>PC <var title="add"></var> 4 <var title="store into (right)"></var> PR, Rm <var title="add"></var> PC <var title="add"></var> 4 <var title="store into (right)"></var> PC
(Delayed branch)</span>
<span id="0000mmmm00000011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00000011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var></var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>B</em>ranch to <em>S</em>ub<em>r</em>outine <em>F</em>ar</span>
<span title="note">Branches to address (<abbr title="Program Counter">PC</abbr> + 4 + Rm), and stores address (<abbr title="Program Counter">PC</abbr> + 4) in <abbr title="Procedure Register">PR</abbr>. The <abbr title="Program Counter">PC</abbr>
source value is the BSRF instruction address. The branch destination address is
the result of adding the 32-bit contents of general register Rm to <abbr title="Program Counter">PC</abbr> + 4.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void BSRF (int m)
{
  unsigned int temp;
  temp = PC;
  PR = PC + 4;
  PC = PC + 4 + R[m];
  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">         mov.l     #(TARGET-BSRF_PC),r0 ! Sets displacement.                                                         
         brsf      r0                   ! Branches to TARGET                                                         
         mov       r3,r4                ! Executes the MOV instruction before                                        
         branching                                                                                                   
BSRF_PC:                                ! ← The PC location is used to calculate the branch destination with BSRF. 
         add       r0,r1                                                                                             
TARGET:                                 ! ←Procedure entrance                                                      
         mov       r2,r3                                                                                             
         rts                            ! Returns to the above ADD instruction                                       
         mov       #1,r0                ! Executes MOV before branching</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row157" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row157">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jmp       @Rm</span>
<span>Rm <var title="store into (right)"></var> PC
(Delayed branch)</span>
<span id="0100mmmm00101011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00101011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>4</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>J</em>u<em>mp</em></span>
<span title="note">Unconditionally makes a delayed branch to the address specified by Rm.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void JMP (int m)
{
  unsigned int temp;
  temp = PC;
  PC = R[m];
  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">           mov.l   JMP_TABLE,r0 ! Address of r0 = TARGET        
           jmp     @r0          ! Branches to TARGET            
           mov     r0,r1        ! Executes MOV before branching 
           .align  4                                            
JMP_TABLE: .data.l TARGET       ! Jump table                    
TARGET:    add     #1,r1        ! ← Branch destination</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row158" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row158">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jsr       @Rm</span>
<span>PC <var title="add"></var> 4 <var title="store into (right)"></var> PR, Rm <var title="store into (right)"></var> PC
(Delayed branch)</span>
<span id="0100mmmm00001011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00001011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>4</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>J</em>ump to <em>S</em>ub<em>r</em>outine</span>
<span title="note">Makes a delayed branch to the subroutine procedure at the specified address
after execution of the following instruction. Return address (<abbr title="Program Counter">PC</abbr> + 4) is saved
in <abbr title="Procedure Register">PR</abbr>, and a branch is made to the address indicated by general register Rm.
JSR is used in combination with RTS for subroutine procedure calls.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a slot
illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void JSR (int m)
{
  unsigned int temp;
  temp = PC;
  PR = PC + 4;
  PC = R[m];
  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">           mov.l   JSR_TABLE,r0 ! Address of r0 = TARGET                                                      
           jsr     @r0          ! Branches to TARGET                                                          
           xor     r1,r1        ! Executes XOR before branching                                               
           add     r0,r1        ! ← Return address for when the subroutine procedure is completed (PR data) 
           .align  4                                                                                          
JSR_TABLE: .data.l TARGET       ! Jump table                                                                  
TARGET:    nop                  ! ← Procedure entrance                                                      
           mov     r2,r3                                                                                      
           rts                  ! Returns to the above ADD instruction                                        
           mov     #70,r1       ! Executes MOV before RTS</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row159" />
<label class="summary SH2A" for="row159">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jsr/n     @Rm</span>
<span>PC <var title="add"></var> 2 <var title="store into (right)"></var> PR, Rm <var title="store into (right)"></var> PC</span>
<span id="0100mmmm01001011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01001011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>J</em>ump to <em>S</em>ub<em>r</em>outine with <em>N</em>o Delay Slot</span>
<span title="note">Branches to a subroutine procedure at the designated address. The contents of
<abbr title="Program Counter">PC</abbr> are stored in <abbr title="Procedure Register">PR</abbr> and execution branches to the address indicated by the
contents of general register Rm as 32-bit data. The stored contents of <abbr title="Program Counter">PC</abbr>
indicate the starting address of the second instruction after the present
instruction. This instruction is used with RTS as a subroutine procedure call.</span>
<span title="section">Note</span>
<span title="note">This is not a delayed branch instruction.</span>
<span title="section">Operation</span>
<span title="operation">void JSRN (int m)
{
  unsigned long temp;
  temp = PC;
  PR = PC + 2;
  PC = R[m];
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row160" />
<label class="summary SH2A" for="row160">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>jsr/n     @@(disp8,TBR)</span>
<span>PC <var title="add"></var> 2 <var title="store into (right)"></var> PR, (disp <var title="multiply"></var> 4 <var title="add"></var> TBR) <var title="store into (right)"></var> PC</span>
<span id="10000011dddddddd" class="colorized"><var title="Opcode Identifier">10000011</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>5</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>5</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>J</em>ump to <em>S</em>ub<em>r</em>outine with <em>N</em>o Delay Slot</span>
<span title="note">Branches to a subroutine procedure at the designated address. The contents of <abbr title="Program Counter">PC</abbr>
are stored in <abbr title="Procedure Register">PR</abbr> and execution branches to the address indicated by the address
read from memory address (disp × 4 + TBR). The stored contents of <abbr title="Program Counter">PC</abbr> indicate
the starting address of the second instruction after the present instruction.
This instruction is used with RTS as a subroutine procedure call.</span>
<span title="section">Note</span>
<span title="note">This is not a delayed branch instruction.</span>
<span title="section">Operation</span>
<span title="operation">void JSRNM (int d)
{
  long disp = (0x000000FF & d);
  PR = PC + 2;
  PC = Read_32 (TBR + (disp &lt;&lt; 2));
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row161" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row161">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rts</span>
<span>PR <var title="store into (right)"></var> PC
Delayed branch</span>
<span id="0000000000001011" class="colorized"><var title="Opcode Identifier">0000000000001011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>BR</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1-4</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>2</var><var>2</var><var>2</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>R</em>e<em>t</em>urn from <em>S</em>ubroutine</span>
<span title="note">Returns from a subroutine procedure by restoring the <abbr title="Program Counter">PC</abbr> from <abbr title="Procedure Register">PR</abbr>. Processing
continues from the address indicated by the restored <abbr title="Program Counter">PC</abbr> value. This instruction
can be used to return from a subroutine procedure called by a BSR or JSR
instruction to the source of the call.</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following this
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction.
<br /><br />
If the following instruction is a branch instruction, it is identified as a
slot illegal instruction.
<br /><br />
The instruction that restores <abbr title="Procedure Register">PR</abbr> must be executed before the RTS instruction.
This restore instruction cannot be in the RTS delay slot.</span>
<span title="section">Operation</span>
<span title="operation">void RTS (void)
{
  unsigned int temp;
  temp = PC;
  PC = PR;
  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">        mov.l   TABLE,r3 ! r3 = Address of TARGET                                                      
        jsr     @r3      ! Branches to TARGET                                                          
        nop              ! Executes NOP before branching                                               
        add     r0,r1    ! ← Return address for when the subroutine procedure is completed (PR data) 
TABLE:  .data.l TARGET   ! Jump table                                                                  
TARGET: mov     r1,r0    ! ← Procedure entrance                                                      
        rts              ! PR data → PC                                                              
        mov     #12,r0   ! Executes MOV before branching</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row162" />
<label class="summary SH2A" for="row162">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rts/n</span>
<span>PR <var title="store into (right)"></var> PC</span>
<span id="0000000001101011" class="colorized"><var title="Opcode Identifier">0000000001101011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>R</em>e<em>t</em>urn from <em>S</em>ubroutine with <em>N</em>o Delay Slot</span>
<span title="note">Performs a return from a subroutine procedure. That is, the <abbr title="Program Counter">PC</abbr> is restored from
<abbr title="Procedure Register">PR</abbr>, and processing is resumed from the address indicated by the <abbr title="Program Counter">PC</abbr>. This
instruction enables a return to be made from a subroutine procedure called by a
BSR or JSR instruction to the origin of the call.</span>
<span title="section">Note</span>
<span title="note">This is not a delayed branch instruction.</span>
<span title="section">Operation</span>
<span title="operation">void RTSN (void)
{
  PC = PR;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row163" />
<label class="summary SH2A" for="row163">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rtv/n     Rm</span>
<span>Rm <var title="store into (right)"></var> R0, PR <var title="store into (right)"></var> PC</span>
<span id="0000mmmm01111011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01111011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>R</em>e<em>t</em>urn to <em>V</em>alue and from Subroutine with <em>N</em>o Delay Slot</span>
<span title="note">Performs a return from a subroutine procedure after a transfer from specified
general register Rm to R0. That is, after the Rm value is stored in R0, the <abbr title="Program Counter">PC</abbr>
is restored from <abbr title="Procedure Register">PR</abbr>, and processing is resumed from the address indicated by the
<abbr title="Program Counter">PC</abbr>. This instruction enables a return to be made from a subroutine procedure
called by a BSR or JSR instruction to the origin of the call.</span>
<span title="section">Note</span>
<span title="note">This is not a delayed branch instruction.</span>
<span title="section">Operation</span>
<span title="operation">void RTVN (int m)
{
  R[0] = R[m];
  PC = PR;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<span class="section_title">System Control Instructions</span>
<input name="instruction" type="radio" id="row164" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row164">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clrmac</span>
<span>0 <var title="store into (right)"></var> MACH, 0 <var title="store into (right)"></var> MACL</span>
<span id="0000000000101000" class="colorized"><var title="Opcode Identifier">0000000000101000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Cl</em>ea<em>r</em> <em>MAC</em> Register</span>
<span title="note">Clears the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> and <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> registers.</span>
<span title="section">Operation</span>
<span title="operation">void CLRMAC (void)
{
  MACH = 0;
  MACL = 0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">clrmac           ! Clears and initializes the MAC register 
mac.w  @r0+,@r1+ ! Multiply and accumulate operation       
mac.w  @r0+,@r1+</span>
</span>
</label>
<input name="instruction" type="radio" id="row165" />
<label class="summary SH3 SH4 SH4A" for="row165">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clrs</span>
<span>0 <var title="store into (right)"></var> S</span>
<span id="0000000001001000" class="colorized"><var title="Opcode Identifier">0000000001001000</var></span>
<span>0 <var title="store into (right)"></var> S</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Cl</em>ea<em>r</em> <em>S</em> Bit</span>
<span title="note">Clears the <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> bit to 0.</span>
<span title="section">Operation</span>
<span title="operation">void CLRS (void)
{
  S = 0;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row166" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row166">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>clrt</span>
<span>0 <var title="store into (right)"></var> T</span>
<span id="0000000000001000" class="colorized"><var title="Opcode Identifier">0000000000001000</var></span>
<span>0 <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Cl</em>ea<em>r</em> <em>T</em> Bit</span>
<span title="note">Clears the <abbr title="Test condition bit flag">T</abbr> bit.</span>
<span title="section">Operation</span>
<span title="operation">void CLRT (void)
{
  T = 0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">clrt ! Before execution: T = 1 
     ! After execution:  T = 0</span>
</span>
</label>
<input name="instruction" type="radio" id="row167" />
<label class="summary SH4A" for="row167">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>icbi      @Rn</span>
<span>Invalidate instruction cache block indicated by logical address</span>
<span id="0000nnnn11100011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11100011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>16</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>13</var><var></var></span>
<span class="details">
<span title="section"><em>I</em>nstruction <em>C</em>ache <em>B</em>lock <em>I</em>nvalidate</span>
<span title="note">Accesses the instruction cache at the effective address indicated by the
contents of Rn. When the cache is hit, the corresponding cache block is
invalidated (the <abbr title="Overflow bit flag">V</abbr> bit is cleared to 0). At this time, write-back is not
performed. No operation is performed in the case of a cache miss or access to
a non-cache area.</span>
<span title="section">Note</span>
<span title="note">When a program is overwriting RAM to modify its own execution, the corresponding
block of the instruction cache should be invalidated by the ICBI instruction.
This prevents execution of the program from the instruction cache, where the
non-overwritten instructions are stored.</span>
<span title="section">Operation</span>
<span title="operation">void ICBI (int n)
{
  invalidate_instruction_cache_block (R[n]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Instruction TLB multiple-hit exception</var>
  <var>Instruction TLB miss exception</var>
  <var>Instruction TLB protection violation exception</var>
  <var>Instruction address error</var>
  <var>Slot illegal instruction exception</var>
  <var>Exceptions may occur when invalidation is not performed.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row168" />
<label class="summary SH2A" for="row168">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldbank    @Rm,R0</span>
<span>(Specified register bank entry) <var title="store into (right)"></var> R0</span>
<span id="0100mmmm11100101" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11100101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>6</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>5</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> register <em>Bank</em></span>
<span title="note">The register bank entry indicated by the contents of general register Rm is
transferred to general register R0. The register bank number and register stored
in the bank are specified by general register Rm.
<br /><img alt="Load register Bank" class="image_filter" src="ldbank.svg" height="400" /></span>
<span title="section">Note</span>
<span title="note">The architecture supports a maximum of 512 banks. However, the number of banks
differs depending on the product.</span>
<span title="section">Operation</span>
<span title="operation">void LDBANK (int m)
{
  R[0] = Read_Bank_32 (R[m]);
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row169" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row169">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,SR</span>
<span>Rm <var title="store into (right)"></var> SR</span>
<span id="0100mmmm00001110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00001110</var></span>
<span>LSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>3</var><var>3</var><var>1</var><var></var><var>4</var><var>7</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>5</var><var></var><var>4</var><var>4</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores the source operand in the control register <abbr title="Status Register">SR</abbr>.</span>
<span title="section">Note</span>
<span title="note">This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.</span>
<span title="section">Operation</span>
<span title="operation">void LDCSR (int m)
{
  #if SH1 || SH2 || SH2 || SH3
  SR = R[m] & 0x0FFF0FFF;

  #elif SH2A
  SR = R[m] & 0x000063F3;

  #elif SH4 || SH4A
  SR = R[m] & 0x700083F3;

  #endif

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">ldc r0,SR ! Before execution: r0 = 0xFFFFFFFF, SR = 0x00000000 
          ! After execution:  SR = 0x0FFF0FFF</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row170" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row170">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,SR</span>
<span>(Rm) <var title="store into (right)"></var> SR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00000111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00000111</var></span>
<span>LSB <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>5</var><var>5</var><var>2</var><var></var><var>4</var><var>9</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>4</var><var>4</var><var>7</var><var></var><var>4/4</var><var>4</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores the source operand in the control register <abbr title="Status Register">SR</abbr>.</span>
<span title="section">Note</span>
<span title="note">This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMSR (int m)
{
  #if SH1 || SH2 || SH2 || SH3
  SR = Read_32 (R[m]) & 0x0FFF0FFF;

  #elif SH2A
  SR = Read_32 (R[m]) & 0x000063F3;

  #elif SH4 || SH4A
  SR = Read_32 (R[m]) & 0x700083F3;

  #endif

  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row171" />
<label class="summary SH2A" for="row171">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,TBR</span>
<span>Rm <var title="store into (right)"></var> TBR</span>
<span id="0100mmmm01001010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01001010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register TBR.</span>
<span title="section">Operation</span>
<span title="operation">void LDCTBR (int m)
{
  TBR = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row172" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row172">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,GBR</span>
<span>Rm <var title="store into (right)"></var> GBR</span>
<span id="0100mmmm00011110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00011110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1/3</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register <abbr title="Global Base Register">GBR</abbr>.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be issued in user mode.</span>
<span title="section">Operation</span>
<span title="operation">void LDCGBR (int m)
{
  GBR = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row173" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row173">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,GBR</span>
<span>(Rm) <var title="store into (right)"></var> GBR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00010111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>2</var><var>2</var><var>1/5</var><var></var><var>3/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register <abbr title="Global Base Register">GBR</abbr>.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be issued in user mode.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMGBR (int m)
{
  GBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">ldc.l @r15+,GBR ! Before execution: r15 = 0x10000000                    
                ! After execution:  r15 = 0x10000004, GBR = @0x10000000</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row174" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row174">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,VBR</span>
<span>Rm <var title="store into (right)"></var> VBR</span>
<span id="0100mmmm00101110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00101110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1/3</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register <abbr title="Vector Base Register">VBR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDCVBR (int m)
{
  VBR = R[m];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row175" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row175">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,VBR</span>
<span>(Rm) <var title="store into (right)"></var> VBR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00100111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00100111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>2</var><var>2</var><var>1/5</var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register <abbr title="Vector Base Register">VBR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMVBR (int m)
{
  VBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row176" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row176">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,MOD</span>
<span>Rm <var title="store into (right)"></var> MOD</span>
<span id="0100mmmm01011110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01011110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/3</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register MOD.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMOD (int m)
{
  MOD = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row177" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row177">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,MOD</span>
<span>(Rm) <var title="store into (right)"></var> MOD, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01010111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01010111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register MOD.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 3 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMMOD (int m)
{
  MOD = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row178" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row178">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,RE</span>
<span>Rm <var title="store into (right)"></var> RE</span>
<span id="0100mmmm01111110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01111110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/3</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register RE.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDCRE (int m)
{
  RE = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row179" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row179">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,RE</span>
<span>(Rm) <var title="store into (right)"></var> RE, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01110111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01110111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register RE.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 3 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMRE (int m)
{
  RE = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row180" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row180">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,RS</span>
<span>Rm <var title="store into (right)"></var> RS</span>
<span id="0100mmmm01101110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01101110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/3</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register RS.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDCRS (int m)
{
  RS = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row181" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row181">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,RS</span>
<span>(Rm) <var title="store into (right)"></var> RS, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01100111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01100111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to <em>C</em>ontrol Register</span>
<span title="note">Stores a source operand in control register RS.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 3 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMRS (int m)
{
  RS = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row182" />
<label class="summary SH4A" for="row182">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,SGR</span>
<span>Rm <var title="store into (right)"></var> SGR</span>
<span id="0100mmmm00111010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register SGR.</span>
<span title="section">Note</span>
<span title="note">Not sure whether it is also available on SH4.
It is not marked as new instruction for SH4A but is also not listed in SH4
manuals.</span>
<span title="section">Operation</span>
<span title="operation">void LDCSGR (int m)
{
  SGR = R[m];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row183" />
<label class="summary SH4A" for="row183">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,SGR</span>
<span>(Rm) <var title="store into (right)"></var> SGR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00110110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00110110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register SGR.</span>
<span title="section">Note</span>
<span title="note">Not sure whether it is also available on SH4.
It is not marked as new instruction for SH4A but is also not listed in SH4
manuals.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMSGR (int m)
{
  SGR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row184" />
<label class="summary SH3 SH4 SH4A" for="row184">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,SSR</span>
<span>Rm <var title="store into (right)"></var> SSR</span>
<span id="0100mmmm00111110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00111110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/3</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register SSR.</span>
<span title="section">Operation</span>
<span title="operation">void LDCSSR (int m)
{
  SSR = R[m],
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row185" />
<label class="summary SH3 SH4 SH4A" for="row185">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,SSR</span>
<span>(Rm) <var title="store into (right)"></var> SSR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00110111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00110111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register SSR.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMSSR (int m)
{
  SSR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row186" />
<label class="summary SH3 SH4 SH4A" for="row186">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,SPC</span>
<span>Rm <var title="store into (right)"></var> SPC</span>
<span id="0100mmmm01001110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01001110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/3</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register SPC.</span>
<span title="section">Operation</span>
<span title="operation">void LDCSPC (int m)
{
  SPC = R[m];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row187" />
<label class="summary SH3 SH4 SH4A" for="row187">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,SPC</span>
<span>(Rm) <var title="store into (right)"></var> SPC, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01000111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01000111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register SPC.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMSPC (int m)
{
  SPC = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row188" />
<label class="summary SH4 SH4A" for="row188">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,DBR</span>
<span>Rm <var title="store into (right)"></var> DBR</span>
<span id="0100mmmm11111010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register DBR.</span>
<span title="section">Operation</span>
<span title="operation">void LDCDBR (int m)
{
  DBR = R[m];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row189" />
<label class="summary SH4 SH4A" for="row189">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,DBR</span>
<span>(Rm) <var title="store into (right)"></var> DBR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm11110110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">11110110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>4</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/3</var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in control register DBR.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMDBR (int m)
{
  DBR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row190" />
<label class="summary SH3 SH4 SH4A" for="row190">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc       Rm,Rn_BANK</span>
<span>Rm <var title="store into (right)"></var> Rn_BANK (n <var title="equality"></var> 0<var title="subtract"></var>7)</span>
<span id="0100mmmm1nnn1110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">1110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/3</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in banked general register.
Rn_BANK0 is accessed when the RB bit in the <abbr title="Status Register">SR</abbr> register is 1, and Rn_BANK1 is
accessed when this bit is 0.</span>
<span title="section">Operation</span>
<span title="operation">void LDCRn_BANK (int m)
{
  Rn_BANK = R[m];
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row191" />
<label class="summary SH3 SH4 SH4A" for="row191">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldc.l     @Rm+,Rn_BANK</span>
<span>(Rm) <var title="store into (right)"></var> Rn_BANK, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm1nnn0111" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/5</var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a source operand in banked general register.
Rn_BANK0 is accessed when the RB bit in the <abbr title="Status Register">SR</abbr> register is 1, and Rn_BANK1 is
accessed when this bit is 0.</span>
<span title="section">Operation</span>
<span title="operation">void LDCMRn_BANK (int m)
{
  Rn_BANK = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row192" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row192">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldre      @(disp,PC)</span>
<span>disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="store into (right)"></var> RE</span>
<span id="10001110dddddddd" class="colorized"><var title="Opcode Identifier">10001110</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> Effective Address to <em>RE</em> Register</span>
<span title="note">Stores the effective address of the source operand in the repeat end register
RE. The effective address is an address specified by <abbr title="Program Counter">PC</abbr> + displacement. The <abbr title="Program Counter">PC</abbr>
is the address four bytes after this instruction. The 8-bit displacement is
sign-extended and doubled. Consequently, the relative interval from the branch
destination is -256 to +254 bytes.</span>
<span title="section">Note</span>
<span title="note">The effective address value designated for the RE reregister is different from
the actual repeat end address. Refer to RS and RE Design Rules, for more
information.
<br /><br />
When this instruction is arranged immediately after the delayed
branch instruction, <abbr title="Program Counter">PC</abbr> becomes the "first address +2" of the branch destination.
<br /><br />
On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDRE (int d)
{
  long disp;

  if ((d & 0x80) == 0)
    disp = (0x000000FF & (long)d);
  else
    disp = (0xFFFFFF00 | (long)d);

  RE = PC + (disp &lt;&lt; 1);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...</span>
</span>
</label>
<input name="instruction" type="radio" id="row193" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row193">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldrs      @(disp,PC)</span>
<span>disp <var title="multiply"></var> 2 <var title="add"></var> PC <var title="store into (right)"></var> RS</span>
<span id="10001100dddddddd" class="colorized"><var title="Opcode Identifier">10001100</var><var title="Displacement (8 bits)">dddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> Effective Address to <em>RS</em> Register</span>
<span title="note">Stores the effective address of the source operand in the repeat start register
RS. The effective address is an address specified by <abbr title="Program Counter">PC</abbr> + displacement. The <abbr title="Program Counter">PC</abbr>
is the address four bytes after this instruction. The 8-bit displacement is
sign-extended and doubled. Consequently, the relative interval from the branch
destination is -256 to +254 bytes.</span>
<span title="section">Note</span>
<span title="note">When the instructions of the repeat (loop) program are below 3, the effective
address value designated for the RS register is different from the actual repeat
start address. Refer to "RS and RE setting rule", for more information. If this
<br /><br />
instruction is arranged immediately after the delayed branch instruction, the <abbr title="Program Counter">PC</abbr>
becomes "the first address +2" of the branch destination.
<br /><br />
On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDRS (int d)
{
  long disp;

  if ((d & 0x80) == 0)
    disp = (0x000000FF & (long)d);
  else
    disp = (0xFFFFFF00 | (long)d);

  RS = PC + (disp &lt;&lt; 1);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...</span>
</span>
</label>
<input name="instruction" type="radio" id="row194" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row194">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,MACH</span>
<span>Rm <var title="store into (right)"></var> MACH</span>
<span id="0100mmmm00001010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00001010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the system register <abbr title="Multiply and ACcumulate High (word)">MACH</abbr>.</span>
<span title="section">Note</span>
<span title="note">On SH1, only the lower 10 bits are stored in <abbr title="Multiply and ACcumulate High (word)">MACH</abbr>.
<br /><br />
On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.   When an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by
<abbr title="Multiply and Accumulate">MAC</abbr>.W/<abbr title="Multiply and Accumulate">MAC</abbr>.L, the latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMACH (int m)
{
  MACH = R[m];

  #if SH1
  if ((MACH & 0x00000200) == 0)
    MACH &= 0x000003FF;
  else
    MACH |= 0xFFFFFC00;
  #endif

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row195" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row195">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,MACH</span>
<span>(Rm) <var title="store into (right)"></var> MACH, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00000110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00000110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the system register <abbr title="Multiply and ACcumulate High (word)">MACH</abbr>.</span>
<span title="section">Note</span>
<span title="note">On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.   When an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by
<abbr title="Multiply and Accumulate">MAC</abbr>.W/<abbr title="Multiply and Accumulate">MAC</abbr>.L, the latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMMACH (int m)
{
  MACH = Read_32 (R[m]);

  #if SH1
  if ((MACH & 0x00000200) == 0)
    MACH &= 0x000003FF;
  else
    MACH |= 0xFFFFFC00;
  #endif

  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">lds.l @r15+,MACL ! Before execution: r15 = 0x10000000                    
                 ! After execution:  r15 = 0x10000004, MACL = @0x1000000</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row196" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row196">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,MACL</span>
<span>Rm <var title="store into (right)"></var> MACL</span>
<span id="0100mmmm00011010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00011010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the system register <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr>.</span>
<span title="section">Note</span>
<span title="note">On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.   When an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by
<abbr title="Multiply and Accumulate">MAC</abbr>.W/<abbr title="Multiply and Accumulate">MAC</abbr>.L, the latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMACL (int m)
{
  MACL = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row197" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row197">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,MACL</span>
<span>(Rm) <var title="store into (right)"></var> MACL, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00010110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>1/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the system register <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr>.</span>
<span title="section">Note</span>
<span title="note">On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.   When an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by
<abbr title="Multiply and Accumulate">MAC</abbr>.W/<abbr title="Multiply and Accumulate">MAC</abbr>.L, the latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMMACL (int m)
{
  MACL = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">lds.l @r15+,MACL ! Before execution: r15 = 0x10000000                     
                 ! After execution:  r15 = 0x10000004, MACL = @0x10000000</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row198" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row198">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,PR</span>
<span>Rm <var title="store into (right)"></var> PR</span>
<span id="0100mmmm00101010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the system register <abbr title="Procedure Register">PR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDSPR (int m)
{
  PR = R[m];
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">lds r0,PR ! Before execution: r0 = 0x12345678, PR = 0x00000000 
          ! After execution:  PR = 0x12345678</span>
</span>
</label>
<input name="instruction" type="radio" id="row199" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row199">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,PR</span>
<span>(Rm) <var title="store into (right)"></var> PR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm00100110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00100110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the system register <abbr title="Procedure Register">PR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMPR (int m)
{
  PR = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row200" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row200">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,DSR</span>
<span>Rm <var title="store into (right)"></var> DSR</span>
<span id="0100mmmm01101010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem Register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDSDSR (int m)
{
  DSR = R[m] & 0x0000000F;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row201" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row201">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,A0</span>
<span>Rm <var title="store into (right)"></var> A0</span>
<span id="0100mmmm01111010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register A0.</span>
<span title="section">Operation</span>
<span title="operation">void LDSA0 (long m)
{
 A0 = R[m];

 if ((A0 & 0x80000000) == 0)
   A0G = 0x00;
 else
   A0G = 0xFF;

 PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row202" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row202">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,DSR</span>
<span>(Rm) <var title="store into (right)"></var> DSR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01100110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01100110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem Register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr>.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMDSR (int m)
{
  DSR = Read_32 (R[m]) & 0x0000000F;
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row203" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row203">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,A0</span>
<span>(Rm) <var title="store into (right)"></var> A0, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01110110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01110110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register A0.  The <abbr title="Most Significant Bit">MSB</abbr> of the data is
copied into A0G.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMA0 (int m)
{
  A0 = Read_32 (R[m]);

  if ((A0 & 0x80000000) == 0)
    A0G = 0x00;
  else
    A0G = 0xFF;

  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row204" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row204">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,X0</span>
<span>Rm <var title="store into (right)"></var> X0</span>
<span id="0100mmmm10001010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">10001010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register X0.</span>
<span title="section">Operation</span>
<span title="operation">void LDSX0 (int m)
{
  X0 = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row205" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row205">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,X0</span>
<span>(Rm) <var title="store into (right)"></var> X0, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100nnnn10000110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register X0.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMX0 (int m)
{
  X0 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row206" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row206">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,X1</span>
<span>Rm <var title="store into (right)"></var> X1</span>
<span id="0100mmmm10011010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">10011010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register X1.</span>
<span title="section">Operation</span>
<span title="operation">void LDSX1 (int m)
{
  X1 = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row207" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row207">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,X1</span>
<span>(Rm) <var title="store into (right)"></var> X1, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100nnnn10010110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10010110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register X1.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMX1 (int m)
{
  X1 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row208" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row208">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,Y0</span>
<span>Rm <var title="store into (right)"></var> Y0</span>
<span id="0100mmmm10101010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">10101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register Y0.</span>
<span title="section">Operation</span>
<span title="operation">void LDSY0 (int m)
{
  Y0 = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row209" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row209">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,Y0</span>
<span>(Rm) <var title="store into (right)"></var> Y0, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100nnnn10100110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10100110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/5</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register Y0.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMY0 (int m)
{
  Y0 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row210" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row210">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,Y1</span>
<span>Rm <var title="store into (right)"></var> Y1</span>
<span id="0100mmmm10111010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">10111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register Y1.</span>
<span title="section">Operation</span>
<span title="operation">void LDSY1 (int m)
{
  Y1 = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row211" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row211">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,Y1</span>
<span>(Rm) <var title="store into (right)"></var> Y1, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100nnnn10110110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10110110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Stores the source operand into the <abbr title="Digital Signal Processor">DSP</abbr> register Y1.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMY1 (int m)
{
  Y1 = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row212" />
<label class="summary SH3 SH4 SH4A" for="row212">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ldtlb</span>
<span>PTEH<var title="divide"></var>PTEL <var title="store into (right)"></var> TLB</span>
<span id="0000000000111000" class="colorized"><var title="Opcode Identifier">0000000000111000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> PTEH/PTEL to <em>TLB</em></span>
<span title="note">Loads the contents of the <abbr title="Page Table Entry High Register">PTEH</abbr>/<abbr title="Page Table Entry Low Register">PTEL</abbr> registers into the <abbr title="Translation Lookaside Buffer">TLB</abbr> (translation
lookaside buffer) specified by <abbr title="MMU (Memory Management Unit) Control Register">MMUCR</abbr>.URC (random counter field in the MMC
control register).
<br /><br />
LDTLB is a privileged instruction, and can only be used in privileged mode. Use of this
instruction in user mode will cause an illegal instruction exception.</span>
<span title="section">Note</span>
<span title="note">As this instruction loads the contents of the <abbr title="Page Table Entry High Register">PTEH</abbr>/<abbr title="Page Table Entry Low Register">PTEL</abbr> registers into a <abbr title="Translation Lookaside Buffer">TLB</abbr>, it
should be used either with the <abbr title="Memory Management Unit">MMU</abbr> disabled, or in the P1 or P2 virtual space
with the <abbr title="Memory Management Unit">MMU</abbr> enabled (see the <abbr title="Memory Management Unit">MMU</abbr> section of the applicable hardware manual for
details).
<br /><br />
After this instruction is issued, there must be at least one instruction between
the LDTLB instruction and issuance of an instruction relating to address to the
P0, U0, and P3 areas (i.e. BRAF, BSRF, JMP, JSR, RTS, or RTE).
<br /><br />
If the instruction is issued in an exception handler, it should be at least two
instructions prior to an RTE instruction that terminates the handler.</span>
<span title="section">Operation</span>
<span title="operation">void LDTLB (void)
{
  #if SH3
  TLB_tag = PTEH;
  TLB_data = PTEL;

  #elif SH4
  TLB[MMUCR.URC].ASID = PTEH & 0x000000FF;
  TLB[MMUCR.URC].VPN = (PTEH & 0xFFFFFC00) &gt;&gt; 10;
  TLB[MMUCR.URC].PPN = (PTEH & 0x1FFFFC00) &gt;&gt; 10;
  TLB[MMUCR.URC].SZ = (PTEL & 0x00000080) &gt;&gt; 6 | (PTEL & 0x00000010) &gt;&gt; 4;
  TLB[MMUCR.URC].SH = (PTEH & 0x00000002) &gt;&gt; 1;
  TLB[MMUCR.URC].PR = (PTEH & 0x00000060) &gt;&gt; 5;
  TLB[MMUCR.URC].WT = (PTEH & 0x00000001);
  TLB[MMUCR.URC].C = (PTEH & 0x00000008) &gt;&gt; 3;
  TLB[MMUCR.URC].D = (PTEH & 0x00000004) &gt;&gt; 2;
  TLB[MMUCR.URC].V = (PTEH & 0x00000100) &gt;&gt; 8;

  #endif

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row213" />
<label class="summary SH4 SH4A" for="row213">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movca.l   R0,@Rn</span>
<span>R0 <var title="store into (right)"></var> (Rn) (without fetching cache block)</span>
<span id="0000nnnn11000011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11000011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3-7</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Mov</em>e with <em>C</em>ache Block <em>A</em>llocation</span>
<span title="note">Stores the contents of general register R0 in the memory location indicated by
effective address Rn. This instruction differs from other store instructions as
follows.
<br /><br />
If write-back is selected for the accessed memory, and a cache miss occurs, the
cache block will be allocated but an R0 data write will be performed to that
cache block without performing a block read. Other cache block contents are
undefined.</span>
<span title="section">Operation</span>
<span title="operation">void MOVCAL (int n)
{
  if (is_write_back_memory (R[n]) && look_up_in_operand_cache (R[n]) == MISS)
    allocate_operand_cache_block (R[n]);

  Write_32 (R[n], R[0]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row214" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row214">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nop</span>
<span>No operation</span>
<span id="0000000000001001" class="colorized"><var title="Opcode Identifier">0000000000001001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>MT</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Note</span>
<span title="note">Increments the program counter (<abbr title="Program Counter">PC</abbr>), advancing the processing flow to execution
of the next instruction.</span>
<span title="section">Operation</span>
<span title="operation">void NOP (void)
{
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">nop ! Executes in one cycle</span>
</span>
</label>
<input name="instruction" type="radio" id="row215" />
<label class="summary SH4 SH4A" for="row215">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ocbi      @Rn</span>
<span>Invalidate operand cache block</span>
<span id="0000nnnn10010011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10010011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1-2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>O</em>perand <em>C</em>ache <em>B</em>lock <em>I</em>nvalidate</span>
<span title="note">Accesses data using the contents indicated by effective address Rn. In the case
of a hit in the cache, the corresponding cache block is invalidated (the <abbr title="Overflow bit flag">V</abbr> bit
is cleared to 0). If there is unwritten information (U bit = 1), write-back is
not performed even if write-back mode is selected. No operation is performed in
the case of a cache miss or an access to a non-cache area.</span>
<span title="section">Operation</span>
<span title="operation">void OCBI (int n)
{
  invalidate_operand_cache_block (R[n]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>Note that the above exceptions are generated even if OCBI does not operate.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row216" />
<label class="summary SH4 SH4A" for="row216">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ocbp      @Rn</span>
<span>Write back and invalidate operand cache block</span>
<span id="0000nnnn10100011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10100011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1-5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>O</em>perand <em>C</em>ache <em>B</em>lock <em>P</em>urge</span>
<span title="note">Accesses data using the contents indicated by effective address Rn. If the cache
is hit and there is unwritten information (U bit = 1), the corresponding cache
block is written back to external memory and that block is invalidated (the <abbr title="Overflow bit flag">V</abbr>
bit is cleared to 0). If there is no unwritten information (U bit = 0), the
block is simply invalidated. No operation is performed in the case of a cache
miss or an access to a non-cache area.</span>
<span title="section">Operation</span>
<span title="operation">void OCBP (int n)
{
  if (is_dirty_block (R[n]))
    write_back (R[n])

  invalidate_operand_cache_block (R[n]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Note that the above exceptions are generated even if OCBP does not operate.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row217" />
<label class="summary SH4 SH4A" for="row217">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ocbwb     @Rn</span>
<span>Write back operand cache block</span>
<span id="0000nnnn10110011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10110011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1-5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>O</em>perand <em>C</em>ache <em>B</em>lock <em>W</em>rite <em>B</em>ack</span>
<span title="note">Accesses data using the contents indicated by effective address Rn. If the cache
is hit and there is unwritten information (U bit = 1), the corresponding cache
block is written back to external memory and that block is cleaned (the U bit
is cleared to 0). In other cases (i.e. in the case of a cache miss or an access
to a non-cache area, or if the block is already clean), no operation is
performed.</span>
<span title="section">Operation</span>
<span title="operation">void OCBWB (int n)
{
  if (is_dirty_block (R[n]))
    write_back (R[n]);

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Note that the above exceptions are generated even if OCBWB does not operate.</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row218" />
<label class="summary SH2A SH3 SH4 SH4A" for="row218">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pref      @Rn</span>
<span>(Rn) <var title="store into (right)"></var> operand cache</span>
<span id="0000nnnn10000011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var>1/2</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Pref</em>etch Data to Cache</span>
<span title="note">SH4 and SH4A
<br />
Reads a 32-byte data block starting at a 32-byte boundary into the operand
cache. The lower 5 bits of the address specified by Rn are masked to zero.
<br />
This instruction is also used to trigger a Store Queue write-back operation if
the specified address points to the Store Queue area.  For more information
refer to Store Queues in the manual.
<br /><br />

SH3 and SH2A
<br />
Reads a 16-byte data block into the cache.  The address specified by Rn should
be on 32-bit boundary.  No address related error is detected in this
instruction. In case of an error, the instruction operates as NOP.</span>
<span title="section">Note</span>
<span title="note">On products with no cache, this instruction is handled as a NOP instruction.</span>
<span title="section">Operation</span>
<span title="operation">void PREF (int n)
{
  prefetch_operand_cache_block (R[n]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row219" />
<label class="summary SH4A" for="row219">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>prefi     @Rn</span>
<span>Reads 32<var title="subtract"></var>byte instruction block into instruction cache</span>
<span id="0000nnnn11010011" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11010011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>13</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>10</var><var></var></span>
<span class="details">
<span title="section"><em>Pref</em>etch <em>I</em>nstruction Cache Block</span>
<span title="note">Reads a 32-byte block of data starting at a 32-byte boundary within the
instruction cache. The lower 5 bits of the address specified by Rn are masked
by zeroes.
<br /><br />
This instruction does not generate data address error and <abbr title="Memory Management Unit">MMU</abbr> exceptions. In the
event of an error, the PREFI instruction is treated as an NOP (no operation)
instruction.
<br /><br />
When the address to be prefetched is missing from <abbr title="Unified Translation Lookaside Buffer">UTLB</abbr> or is protected, the
PREFI instruction is treated as an NOP instruction and a <abbr title="Translation Lookaside Buffer">TLB</abbr> exception does not
occur.</span>
<span title="section">Note</span>
<span title="note">This instruction can be used before the SLEEP command is issued to prefetch
instructions for execution on return from the SLEEP state.</span>
<span title="section">Operation</span>
<span title="operation">void PREFI (int n)
{
  prefetch_instruction_cache_block (R[n]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row220" />
<label class="summary SH2A" for="row220">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>resbank</span>
<span>Bank <var title="store into (right)"></var> R0 to R14, GBR, MACH, MACL, PR</span>
<span id="0000000001011011" class="colorized"><var title="Opcode Identifier">0000000001011011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>9/19</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>8/20</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>Res</em>tore from Register <em>Bank</em></span>
<span title="note">Restores the last register saved to a register bank.</span>
<span title="section">Note</span>
<span title="note">The issue cycle count is 19 when a bank overflow has occured and the registers
are restored from the stack.</span>
<span title="section">Operation</span>
<span title="operation">void RESBANK (void)
{
  int m;  // Number of register bank to which a save was last performed.

  if (BO == 0)
  {
    PR = Register_Bank[m].PR_BANK;
    GBR = Register_Bank[m].GBR_BANK;
    MACL = Register_Bank[m].MACL_BANK;
    MACH = Register_Bank[m].MACH_BANK;

    for (int i = 0; i &lt;= 14; i++)
      R[i] = Register_Bank[m].R_BANK[i];
  }
  else
  {
    for (int i = 0; i &lt;= 14; i++)
    {
      R[i] = Read_32 (R[15]);
      R[15] += 4;
    }

    PR = Read_32 (R[15]);
    R[15] += 4;
    GBR = Read_32 (R[15]);
    R[15] += 4;
    MACH = Read_32 (R[15]);
    R[15] += 4;
    MACL = Read_32 (R[15]);
    R[15] += 4;
  }

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row221" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row221">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>rte</span>
<span>Delayed branch
SH1<var title="multiply"></var>,SH2<var title="multiply"></var>: stack area <var title="store into (right)"></var> PC<var title="divide"></var>SR
SH3<var title="multiply"></var>,SH4<var title="multiply"></var>: SSR<var title="divide"></var>SPC <var title="store into (right)"></var> SR<var title="divide"></var>PC</span>
<span id="0000000000101011" class="colorized"><var title="Opcode Identifier">0000000000101011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>6</var><var>6</var><var>1</var><var></var><var>5</var><var>5</var><var></var></span>
<span class="cycle_grid"><var>4</var><var>4</var><var>5</var><var>5</var><var>4</var><var></var><var>5</var><var>4</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Returns from an exception or interrupt handling routine by restoring the <abbr title="Program Counter">PC</abbr> and
<abbr title="Status Register">SR</abbr> values.  Program execution continues from the address specified
by the restored <abbr title="Program Counter">PC</abbr> value.
<br /><br />
On SH3 and SH4 the <abbr title="Program Counter">PC</abbr> and <abbr title="Status Register">SR</abbr> values are restored from SPC and SSR.  The <abbr title="Status Register">SR</abbr> value
accessed by the instruction in the RTE delay slot is the value restored from SSR
by the RTE instruction. The <abbr title="Status Register">SR</abbr> and MD values defined prior to RTE execution are
used to fetch the instruction in the RTE delay slot.
<br /><br />
On SH1, SH2 and SH2A the <abbr title="Program Counter">PC</abbr> and <abbr title="Status Register">SR</abbr> values are from the stack (R15).</span>
<span title="section">Note</span>
<span title="note">As this is a delayed branch instruction, the instruction following the RTE
instruction is executed before the branch destination instruction.
<br /><br />
Interrupts are not accepted between this instruction and the following
instruction. An exception must not be generated by the instruction in this
instruction's delay slot. If the following instruction is a branch instruction,
it is identified as a slot illegal instruction.
<br /><br />
If this instruction is located in the delay slot immediately following a delayed
branch instruction, it is identified as a slot illegal instruction.
<br /><br />
On SH3 and SH4 the <abbr title="Status Register">SR</abbr> value accessed by the instruction in the RTE delay slot is
the value restored from SSR by the RTE instruction. The <abbr title="Status Register">SR</abbr> and MD values defined
prior to RTE execution are used to fetch the instruction in the RTE delay slot.</span>
<span title="section">Operation</span>
<span title="operation">void RTE (void)
{
  unsigned long temp = PC;

  #if SH1 || SH2 || SH2A
  PC = Read_32 (R[15]);
  R[15] += 4;
  SR = Read_32 (R[15]) & 0x000063F3;
  R[15] += 4;

  #elif SH3 || SH4 || SH4A
  SR = SSR;
  PC = SPC;

  #endif

  Delay_Slot (temp + 2);
}</span>
<span title="section">Example</span>
<span title="assembly">rte        ! Returns to the original routine 
add #8,r14 ! Executes ADD before branching</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row222" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row222">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>setrc     Rn</span>
<span>Rn[11:0] <var title="store into (right)"></var> RC (SR[27:16])</span>
<span id="0100mmmm00010100" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"><em>Set</em> Repeat Count to <em>RC</em></span>
<span title="note">Sets the repeat count to the <abbr title="Status Register">SR</abbr> register's RC counter. The bottom 12 bits of the
general register Rn are used as the repeat count.
Set repeat control flags to RF1, RF0 bits of the <abbr title="Status Register">SR</abbr> register. Use of the SETRC
instruction is subject to any limitations. Refer to the <abbr title="Digital Signal Processor">DSP</abbr> Repeat (Loop)
Control section of the manual for more information.
<br /><img alt="Set Repeat Count to RC" class="image_filter" src="setrc.svg" height="140" /></span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void SETRC (int m)
{
  long temp = (R[m] & 0x00000FFF) &lt;&lt; 16;
  SR &= 0x00000FF3;
  SR |= temp;
  RF1 = Repeat_Control_Flag1;
  RF0 = Repeat_Control_Flag0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  r14       ! Repeat n times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...</span>
</span>
</label>
<input name="instruction" type="radio" id="row223" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row223">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>setrc     #imm</span>
<span>imm <var title="store into (right)"></var> RC (SR[23:16]), 0 <var title="store into (right)"></var> SR[27:24]</span>
<span id="10000010iiiiiiii" class="colorized"><var title="Opcode Identifier">10000010</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var></span>
<span class="details">
<span title="section"><em>Set</em> Repeat Count to <em>RC</em></span>
<span title="note">Sets the repeat count to the <abbr title="Status Register">SR</abbr> register's RC counter. The 8-bit immediate value
is zero-extended and used as the repeat count.
Set repeat control flags to RF1, RF0 bits of the <abbr title="Status Register">SR</abbr> register. Use of the SETRC
instruction is subject to any limitations. Refer to the <abbr title="Digital Signal Processor">DSP</abbr> Repeat (Loop)
Control section of the manual for more information.
<br /><img alt="Set Repeat Count to RC" class="image_filter" src="setrci.svg" height="140" /></span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void SETRCI (int i)
{
  long temp = ((long)i & 0x000000FF) &lt;&lt; 16;
  SR &= 0x00000FFF;
  SR |= temp;
  RF1 = Repeat_Control_Flag1;
  RF0 = Repeat_Control_Flag0;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">    ldrs   start     ! Set repeat start address to RS
    ldre   end       ! Set repeat end address to RE
    setrc  #32       ! Repeat 32 times from &lt;instruction A&gt; to &lt;instruction B&gt;
    ...
start:
    &lt;instruction A&gt;
    ...
    ...
    ...
end:
    &lt;instruction B&gt;
    ...</span>
</span>
</label>
<input name="instruction" type="radio" id="row224" />
<label class="summary SH3 SH4 SH4A" for="row224">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sets</span>
<span>1 <var title="store into (right)"></var> S</span>
<span id="0000000001011000" class="colorized"><var title="Opcode Identifier">0000000001011000</var></span>
<span>1 <var title="store into (right)"></var> S</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Set</em> <em>S</em> Bit</span>
<span title="note">Sets the <abbr title="Saturation bit flag (for multiply-accumulate)">S</abbr> bit to 1.</span>
<span title="section">Operation</span>
<span title="operation">void SETS (void)
{
  S = 1;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">sets ! Before execution: S = 0 
     ! After execution:  S = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row225" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row225">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sett</span>
<span>1 <var title="store into (right)"></var> T</span>
<span id="0000000000011000" class="colorized"><var title="Opcode Identifier">0000000000011000</var></span>
<span>1 <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>MT</var><var>EX</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>0</var><var>0</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Set</em> <em>T</em> Bit</span>
<span title="note">Sets the <abbr title="Test condition bit flag">T</abbr> bit to 1.</span>
<span title="section">Operation</span>
<span title="operation">void SETT (void)
{
  T = 1;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">sett ! Before execution: T = 0 
     ! After execution:  T = 1</span>
</span>
</label>
<input name="instruction" type="radio" id="row226" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row226">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sleep</span>
<span>Sleep or standby</span>
<span id="0000000000011011" class="colorized"><var title="Opcode Identifier">0000000000011011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>5</var><var>5</var><var>2</var><var></var><var>4</var><var>ud</var><var></var></span>
<span class="cycle_grid"><var>3</var><var>3</var><var>0</var><var>0</var><var>4</var><var></var><var>4</var><var>ud</var><var></var></span>
<span class="details">
<span title="section"><em>Sleep</em></span>
<span title="note">Places the <abbr title="Central Processing Unit">CPU</abbr> in the power-down state.
<br /><br />
In power-down mode, the <abbr title="Central Processing Unit">CPU</abbr> retains its internal state, but immediately stops
executing instructions and waits for an interrupt request. When it receives an
interrupt request, the <abbr title="Central Processing Unit">CPU</abbr> exits the power-down state.
<br /><br />
SLEEP is a privileged instruction, and can only be used in privileged mode. Use
of this instruction in user mode will cause an illegal instruction exception.</span>
<span title="section">Note</span>
<span title="note">SLEEP performance depends on the standby control register (STBCR). See
Power-Down Modes in the target product's hardware manual, for details.
<br /><br />
The number of cycles given is for the transition to sleep mode. "ud" means
the number of cycles is undefined.
<br /><br />
Some SH4 implementations have a hardware bug which restricts the instructions
that should follow this instruction for safe operation.  There are two
recommended workarounds:
Put 8 NOP instructions following the SLEEP instruction.
Put 5 "OR R0,R0" instructions following the SLEEP instruction
<br />
For more information see the document "tnsh7456ae.pdf".</span>
<span title="section">Operation</span>
<span title="operation">void SLEEP (void)
{
  Sleep_standby();
}</span>
<span title="section">Example</span>
<span title="assembly">sleep ! Enters power-down mode</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row227" />
<label class="summary SH2A" for="row227">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stbank    R0,@Rn</span>
<span>R0 <var title="store into (right)"></var> (specified register bank entry)</span>
<span id="0100nnnn11100001" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11100001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>7</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>6</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>St</em>ore Register <em>Bank</em></span>
<span title="note">R0 is transferred to the register bank entry indicated by the contents of
general register Rn. The register bank number and register stored in the bank
are specified by general register Rn.
<br /><img alt="Store Register Bank" class="image_filter" src="stbank.svg" height="400" /></span>
<span title="section">Note</span>
<span title="note">The architecture supports a maximum of 512 banks. However, the number of banks
differs depending on the product.</span>
<span title="section">Operation</span>
<span title="operation">void STBANK (int n)
{
  Write_Bank_32 (R[n], R[0])
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row228" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row228">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       SR,Rn</span>
<span>SR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00000010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register <abbr title="Status Register">SR</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.</span>
<span title="section">Operation</span>
<span title="operation">void STCSR (int n)
{
  R[n] = SR;
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">stc SR,r0 ! Before execution: r0 = 0xFFFFFFFF, SR = 0x00000000 
          ! After execution:  r0 = 0x00000000</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row229" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row229">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     SR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, SR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00000011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>2</var><var>2</var><var>1/2</var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register <abbr title="Status Register">SR</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">This instruction is only usable in privileged mode. Issuing this instruction in
user mode will cause an illegal instruction exception.</span>
<span title="section">Operation</span>
<span title="operation">void STCMSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SR);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row230" />
<label class="summary SH2A" for="row230">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       TBR,Rn</span>
<span>TBR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01001010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01001010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register TBR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCTBR (int n)
{
  R[n] = TBR;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row231" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row231">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       GBR,Rn</span>
<span>GBR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00010010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00010010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register <abbr title="Global Base Register">GBR</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be issued in user mode.</span>
<span title="section">Operation</span>
<span title="operation">STCGBR (int n)
{
  R[n] = GBR;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row232" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row232">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     GBR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, GBR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00010011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00010011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>1</var><var>1</var><var>1/2</var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register <abbr title="Global Base Register">GBR</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">This instruction can also be issued in user mode.</span>
<span title="section">Operation</span>
<span title="operation">void STCMGBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], GBR);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">stc.l GBR,@-r15 ! Before execution: r15 = 0x10000004             
                ! After execution:  r15 = 0x10000000, @r15 = GBR</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row233" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row233">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       VBR,Rn</span>
<span>VBR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00100010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register <abbr title="Vector Base Register">VBR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCVBR (int n)
{
  R[n] = VBR;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row234" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row234">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     VBR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, VBR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00100011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>1</var><var>1</var><var>1/2</var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register <abbr title="Vector Base Register">VBR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCMVBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], VBR);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row235" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row235">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       MOD,Rn</span>
<span>MOD <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01010010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01010010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register MOD in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCMOD (int n)
{
  R[n] = MOD;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row236" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row236">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     MOD,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, MOD <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01010011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01010011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/2</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register MOD in the destination.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STCMMOD (int n)
{
  R[n] -= 4;
  Write_32 (R[n], MOD);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row237" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row237">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       RE,Rn</span>
<span>RE <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01110010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01110010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register RE in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCRE (int n)
{
  R[n] = RE;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row238" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row238">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     RE,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, RE <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01110011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01110011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/2</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register RE in the destination.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STCMRE (int n)
{
  R[n] -= 4;
  Write_32 (R[n], RE);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row239" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row239">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       RS,Rn</span>
<span>RS <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01100010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01100010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register RS in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCRS (int n)
{
  R[n] = RS;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row240" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row240">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     RS,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, RS <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01100011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01100011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1/2</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register RS in the destination.</span>
<span title="section">Note</span>
<span title="note">On the SH-<abbr title="Digital Signal Processor">DSP</abbr> the latency of this instruction is 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STCMRS (int n)
{
  R[n] -= 4;
  Write_32 (R[n], RS);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row241" />
<label class="summary SH4 SH4A" for="row241">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       SGR,Rn</span>
<span>SGR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00111010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register SGR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCSGR (int n)
{
  R[n] = SGR;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row242" />
<label class="summary SH4 SH4A" for="row242">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     SGR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, SGR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00110010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00110010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>3/3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register SGR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCMSGR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SGR);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row243" />
<label class="summary SH3 SH4 SH4A" for="row243">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       SSR,Rn</span>
<span>SSR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00110010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00110010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register SSR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCSSR (int n)
{
  R[n] = SSR;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row244" />
<label class="summary SH3 SH4 SH4A" for="row244">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     SSR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, SSR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00110011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00110011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1/2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register SSR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCMSSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SSR);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row245" />
<label class="summary SH3 SH4 SH4A" for="row245">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       SPC,Rn</span>
<span>SPC <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01000010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01000010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register SPC in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCSPC (int n)
{
  R[n] = SPC;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row246" />
<label class="summary SH3 SH4 SH4A" for="row246">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     SPC,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, SPC <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01000011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01000011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register SPC in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCMSPC (int n)
{
  R[n] -= 4;
  Write_32 (R[n], SPC);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row247" />
<label class="summary SH4 SH4A" for="row247">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       DBR,Rn</span>
<span>DBR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn11111010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register DBR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCDBR (int n)
{
  R[n] = DBR;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row248" />
<label class="summary SH4 SH4A" for="row248">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     DBR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, DBR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn11110010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">11110010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores control register DBR in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STCMDBR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], DBR);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row249" />
<label class="summary SH3 SH4 SH4A" for="row249">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc       Rm_BANK,Rn</span>
<span>Rm_BANK <var title="store into (right)"></var> Rn (m <var title="equality"></var> 0<var title="subtract"></var>7)</span>
<span id="0000nnnn1mmm0010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">0010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a banked general register in the destination. Rn_BANK0 is accessed when
the RB bit in the <abbr title="Status Register">SR</abbr> register is 1, and Rn_BANK1 is accessed when this bit is 0.</span>
<span title="section">Operation</span>
<span title="operation">void STCRm_BANK (int n)
{
  R[n] = Rm_BANK;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row250" />
<label class="summary SH3 SH4 SH4A" for="row250">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>stc.l     Rm_BANK,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, Rm_BANK <var title="store into (right)"></var> (Rn) (m <var title="equality"></var> 0<var title="subtract"></var>7)</span>
<span id="0100nnnn1mmm0011" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">0011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>2</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var>2</var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores a banked general register in the destination. Rn_BANK0 is accessed when
the RB bit in the <abbr title="Status Register">SR</abbr> register is 1, and Rn_BANK1 is accessed when this bit is 0.</span>
<span title="section">Operation</span>
<span title="operation">void STCMRm_BANK (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Rm_BANK);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
  <var>General illegal instruction exception</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row251" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row251">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       MACH,Rn</span>
<span>MACH <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00001010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00001010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores system register <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">On SH1, the value of bit 9 is transferred to and stored in the higher 22 bits
(bits 31 to 10) of the destination.
<br /><br />
On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STSMACH (int n)
{
  R[n] = MACH;

  #if SH1
  if ((R[n] & 0x00000200) == 0)
    R[n] &= 0x000003FF;
  else
    R[n] |= 0xFFFFFC00;

  #endif

  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">sts MACH,r0 ! Before execution: r0 = 0xFFFFFFFF, MACH = 0x00000000 
            ! After execution:  r0 = 0x00000000</span>
</span>
</label>
<input name="instruction" type="radio" id="row252" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row252">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     MACH,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, MACH <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00000010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00000010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores system register <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">On SH1, the value of bit 9 is transferred to and stored in the higher 22 bits
(bits 31 to 10) of the destination.
<br /><br />
On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STSMMACH (int n)
{
  R[n] -= 4;

  #if SH1
  if ((MACH & 0x00000200) == 0)
    Write_32 (R[n], MACH & 0x000003FF);
  else
    Write_32 (R[n], MACH | 0xFFFFFC00)

  #else
  Write_32 (R[n], MACH);

  #endif

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row253" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row253">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       MACL,Rn</span>
<span>MACL <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00011010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00011010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>2</var><var>2</var><var>1</var><var></var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores system register <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STSMACL (int n)
{
  R[n] = MACL;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row254" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row254">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     MACL,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, MACL <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00010010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00010010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores system register <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">On SH4, when an LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is followed by an STS.L <abbr title="Multiply and Accumulate">MAC</abbr>*,@-Rn instruction, the
latency of the LDS to <abbr title="Multiply and Accumulate">MAC</abbr>* is 4 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void STSMMACL (int n)
{
  R[n] -= 4;
  Write_32 (R[n], MACL);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row255" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row255">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       PR,Rn</span>
<span>PR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn00101010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores system register <abbr title="Procedure Register">PR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSPR (int n)
{
  R[n] = PR;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row256" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row256">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     PR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, PR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn00100010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00100010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var>1</var><var>1</var><var>1</var><var>1</var><var>1</var><var></var><var>2/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores system register <abbr title="Procedure Register">PR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMPR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], PR);
  PC += 2;
}</span>
<span title="section">Example</span>
<span title="assembly">sts.l PR,@-r15 ! Before execution: r15 = 0x10000004            
               ! After execution:  r15 = 0x10000000, @r15 = PR</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Initial page write exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row257" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row257">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       DSR,Rn</span>
<span>DSR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01101010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>St</em>ore from FPU <em>S</em>ystem Register</span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSDSR (int n)
{
  R[n] = DSR;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row258" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row258">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     DSR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, DSR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01100010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01100010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>St</em>ore from FPU <em>S</em>ystem Register</span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMDSR (int n)
{
  R[n] -= 4;
  Write_32 (R[n], DSR);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row259" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row259">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       A0,Rn</span>
<span>A0 <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01111010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register A0 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSA0 (int n)
{
  R[n] = A0;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row260" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row260">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     A0,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, A0 <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01110010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01110010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register A0 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMA0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], A0);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row261" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row261">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       X0,Rn</span>
<span>X0 <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn10001010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10001010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register X0 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSX0 (int n)
{
  R[n] = X0;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row262" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row262">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     X0,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, X0 <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn10000010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10000010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register X0 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMX0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], X0);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row263" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row263">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       X1,Rn</span>
<span>X1 <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn10011010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10011010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register X1 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSX1 (int n)
{
  R[n] = X1;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row264" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row264">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     X1,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, X1 <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn10010010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10010010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register X1 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMX1 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], X1);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row265" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row265">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       Y0,Rn</span>
<span>Y0 <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn10101010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register Y0 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSY0 (int n)
{
  R[n] = Y0;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row266" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row266">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     Y0,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, Y0 <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn10100010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10100010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register Y0 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMY0 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Y0);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row267" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row267">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       Y1,Rn</span>
<span>Y1 <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn10111010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10111010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register Y1 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSY1 (int n)
{
  R[n] = Y1;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row268" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row268">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     Y1,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, Y1 <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn10110010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10110010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores <abbr title="Digital Signal Processor">DSP</abbr> register Y1 in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMY1 (int n)
{
  R[n] -= 4;
  Write_32 (R[n], Y1);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row269" />
<label class="summary SH4A" for="row269">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>synco</span>
<span>Prevents the next instruction from being issued until instructions issued before this instruction has been completed.</span>
<span id="0000000010101011" class="colorized"><var title="Opcode Identifier">0000000010101011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>ud</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>ud</var><var></var></span>
<span class="details">
<span title="section"><em>Sync</em>hronize Data <em>O</em>peration</span>
<span title="note">This instruction is used to synchronize data operations. When this instruction
is executed, the subsequent bus accesses are not executed until the execution of
all preceding bus accesses has been completed.</span>
<span title="section">Note</span>
<span title="note">The SYNCO instruction can not guarantee the ordering of receipt timing which is
notified by the memory-mapped peripheral resources through the method except bus
when the register is changed by bus accesses. Refer to the description of each
registers to guarantee this ordering.
<br /><br />
Common example usages are:
Ordering access to memory areas which are shared with other memory users
Flushing all write buffers
Stopping memory-access operations from merging and becoming ineffective
Waiting for the completion of cache-control instructions</span>
<span title="section">Operation</span>
<span title="operation">void SYNCO (void)
{
  synchronize_data_operaiton ();
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row270" />
<label class="summary SH1 SH2 SH2E SH2A SH3 SH4 SH4A" for="row270">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>trapa     #imm</span>
<span>SH1<var title="multiply"></var>,SH2<var title="multiply"></var>: PC<var title="divide"></var>SR <var title="store into (right)"></var> stack area, (imm<var title="multiply"></var>4 <var title="add"></var> VBR) <var title="store into (right)"></var> PC
SH3<var title="multiply"></var>,SH4<var title="multiply"></var>: PC<var title="divide"></var>SR <var title="store into (right)"></var> SPC<var title="divide"></var>SSR, imm<var title="multiply"></var>4 <var title="store into (right)"></var> TRA, 0x160 <var title="store into (right)"></var> EXPEVT, VBR <var title="add"></var> 0x0100 <var title="store into (right)"></var> PC</span>
<span id="11000011iiiiiiii" class="colorized"><var title="Opcode Identifier">11000011</var><var title="Unsigned Immediate Data (8 bits)">iiiiiiii</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>CO</var><var></var></span>
<span class="cycle_grid"><var>2</var><var>2</var><var>5</var><var>5</var><var>2</var><var></var><var>7</var><var>14</var><var></var></span>
<span class="cycle_grid"><var>8</var><var>8</var><var>6</var><var>6</var><var>8</var><var></var><var>7</var><var>13</var><var></var></span>
<span class="details">
<span title="section"><em>Trap</em> <em>A</em>lways</span>
<span title="note">Starts trap exception handling.

SH1, SH2 and SH2A:
<br />
The <abbr title="Program Counter">PC</abbr> and <abbr title="Status Register">SR</abbr> values are stored on the stack, and the program branches to an
address specified by the vector. The vector is a memory address obtained by
zero-extending the 8-bit immediate data and then quadrupling it. The <abbr title="Program Counter">PC</abbr> is the
start address of the next instruction. TRAPA and RTE are both used together for
system calls.
<br /><br />

SH3, SH4 and SH4A:
<br />
The values of (<abbr title="Program Counter">PC</abbr> + 2), <abbr title="Status Register">SR</abbr>, and R15 are saved to SPC, SSR and SGR, and 8-bit
immediate data is stored in the <abbr title="TRAPA (Trap Always instruction) Exception Register">TRA</abbr> register (bits 9 to 2). The processor mode
is switched to privileged mode (the MD bit in <abbr title="Status Register">SR</abbr> is set to 1), and the BL bit
and RB bit in <abbr title="Status Register">SR</abbr> are set to 1.  As a result, exception and interrupt requests
are masked (not accepted), and the BANK1 registers (R0_BANK1 to R7_BANK1) are
selected. Exception code 0x160 is written to the <abbr title="Exception Event Register">EXPEVT</abbr> register (bits 11 to 0).
The program branches to address (<abbr title="Vector Base Register">VBR</abbr> + 0x00000100), indicated by the sum of the
<abbr title="Vector Base Register">VBR</abbr> register contents and offset 0x00000100.</span>
<span title="section">Note</span>
<span title="note">Some SH4 implementations have a hardware bug which restricts the instructions
that should follow this instruction for safe operation.  There are two
recommended workarounds:
Put 8 NOP instructions following the TRAPA instruction.
Put 5 "OR R0,R0" instructions following the TRAPA instruction
<br />
For more information see the document "tnsh7456ae.pdf".
<br /><br />
Some SH2E implementations (SH7055) have an <abbr title="Floating Point Unit">FPU</abbr> related hardware bug which
affects this instruction.  The recommended workaround is to align the addresses
of trapa handlers to 4 bytes and not to place any <abbr title="Floating Point Unit">FPU</abbr> or <abbr title="Floating Point Unit">FPU</abbr> related
instructions at addresses 4n + 2 in the handler.</span>
<span title="section">Operation</span>
<span title="operation">void TRAPA (int i)
{
  int imm = (0x000000FF & i);

  #if SH1 || SH2 || SH2A
  R[15] -= 4;
  Write_32 (R[15], SR);
  R[15] -= 4;
  Write_32 (R[15], PC + 2);
  PC = Read_32 (VBR + (imm &lt;&lt; 2));

  #elif SH3 || SH4 || SH4A
  TRA = imm &lt;&lt; 2;
  SSR = SR;
  SPC = PC + 2;
  SGR = R15;
  SR.MD = 1;
  SR.BL = 1;
  SR.RB = 1;
  EXPEVT = 0x00000160;
  PC = VBR + 0x00000100;

  #endif
}</span>
<span title="section">Example</span>
<span title="assembly">         vbr   +0x80                                                                  
         trapa #0x20 ! Branches to an address specified by data in address VBR + 0x80 
         tst   #0,r0 ! ← Return address from the trap routine (stacked PC value)    
10000000       0                                                                      
10000000       2                                                                      
10000000       4</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Unconditional trap</var>
  <var>Slot illegal instruction exception</var>
</span>
</span>
</label>
<span class="section_title">32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)</span>
<input name="instruction" type="radio" id="row271" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row271">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      FRm,FRn</span>
<span>FRm <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm1100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers FRm contents to FRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV (int m, int n)
{
  FR[n] = FR[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row272" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row272">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    @Rm,FRn</span>
<span>(Rm) <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm1000" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0/2</var><var></var><var>1</var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers contents of memory at address indicated by Rm to FRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_LOAD (int m, int n)
{
  FR[n] = Read_32 (R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row273" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row273">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    FRm,@Rn</span>
<span>FRm <var title="store into (right)"></var> (Rn)</span>
<span id="1111nnnnmmmm1010" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers FRm contents to memory at address indicated by Rn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_STORE (int m, int n)
{
  Write_32 (R[n], FR[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row274" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row274">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    @Rm+,FRn</span>
<span>(Rm) <var title="store into (right)"></var> FRn, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="1111nnnnmmmm1001" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1/2</var><var></var><var>1</var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers contents of memory at address indicated by Rm to FRn, and adds 4 to
Rm.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_RESTORE (int m, int n)
{
  FR[n] = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row275" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row275">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    FRm,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, FRm <var title="store into (right)"></var> (Rn)</span>
<span id="1111nnnnmmmm1011" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1/0</var><var></var><var>1</var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Subtracts 4 from Rn, and transfers FRm contents to memory at address indicated
by resulting Rn value.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_SAVE (int m, int n)
{
  Write_32 (R[n] - 4, FR[m]);
  R[n] -= 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row276" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row276">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    @(R0,Rm),FRn</span>
<span>(R0 <var title="add"></var> Rm) <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm0110" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0/2</var><var></var><var>1</var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers contents of memory at address indicated by (R0 + Rm) to FRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_LOAD (int m, int n)
{
  FR[n] = Read_32 (R[0] + R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row277" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row277">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    FRm,@(R0,Rn)</span>
<span>FRm <var title="store into (right)"></var> (R0 <var title="add"></var> Rn)</span>
<span id="1111nnnnmmmm0111" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers FRm contents to memory at address indicated by (R0 + Rn).</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_STORE (int m, int n)
{
  Write_32 (R[0] + R[n], FR[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row278" />
<label class="summary SH2A" for="row278">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    @(disp12,Rm),FRn</span>
<span>(disp <var title="multiply"></var> 4 <var title="add"></var> Rm) <var title="store into (right)"></var> FRn</span>
<span id="0011nnnnmmmm00010111dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010111</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers memory contents at the address indicated by (disp + Rn) to FRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_DISP12_LOAD (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  FR[n] = Read_32 (R[m] + (disp &lt;&lt; 2));
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row279" />
<label class="summary SH2A" for="row279">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.s    FRm,@(disp12,Rn)</span>
<span>FRm <var title="store into (right)"></var> (disp <var title="multiply"></var> 4 <var title="add"></var> Rn)</span>
<span id="0011nnnnmmmm00010011dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010011</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers FRm contents to memory at the address indicated by (disp + Rn).</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_DISP12_STORE (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  Write_32 (R[n] + (disp &lt;&lt; 2), FR[m]);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<span class="section_title">64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)</span>
<input name="instruction" type="radio" id="row280" />
<label class="summary SH2A SH4 SH4A" for="row280">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      DRm,DRn</span>
<span>DRm <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmm01100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">01100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers DRm contents to DRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = DR[m &gt;&gt; 1];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row281" />
<label class="summary SH4 SH4A" for="row281">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      DRm,XDn</span>
<span>DRm <var title="store into (right)"></var> XDn</span>
<span id="1111nnn1mmm01100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">01100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers DRm contents to XDn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_DRXD (int m, int n)
{
  XD[n &gt;&gt; 1] = DR[m &gt;&gt; 1];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row282" />
<label class="summary SH4 SH4A" for="row282">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      XDm,DRn</span>
<span>XDm <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmm11100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">11100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers XDm contents to DRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_XDDR (int m, int n)
{
  DR[n &gt;&gt; 1] = XD[m &gt;&gt; 1];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row283" />
<label class="summary SH4 SH4A" for="row283">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      XDm,XDn</span>
<span>XDm <var title="store into (right)"></var> XDn</span>
<span id="1111nnn1mmm11100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">11100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers XDm contents to XDn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_XDXD (int m, int n)
{
  XD[n &gt;&gt; 1] = XD[m &gt;&gt; 1];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row284" />
<label class="summary SH2A SH4 SH4A" for="row284">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      @Rm,DRn</span>
<span>(Rm) <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmmm1000" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/4</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers contents of memory at address indicated by Rm to DRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_LOAD_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row285" />
<label class="summary SH4 SH4A" for="row285">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      @Rm,XDn</span>
<span>(Rm) <var title="store into (right)"></var> XDn</span>
<span id="1111nnn1mmmm1000" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers contents of memory at address indicated by Rm to XDn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_LOAD_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row286" />
<label class="summary SH2A SH4 SH4A" for="row286">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      DRm,@Rn</span>
<span>DRm <var title="store into (right)"></var> (Rn)</span>
<span id="1111nnnnmmm01010" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">01010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers DRm contents to memory at address indicated by Rn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_STORE_DR (int m, int n)
{
  Write_64 (R[n], DR[m &gt;&gt; 1]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row287" />
<label class="summary SH4 SH4A" for="row287">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      XDm,@Rn</span>
<span>XDm <var title="store into (right)"></var> (Rn)</span>
<span id="1111nnnnmmm11010" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">11010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers contents of memory at address indicated by (R0 + Rm) to XDn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_STORE_XD (int m, int n)
{
  Write_64 (R[n], XD[m &gt;&gt; 1]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row288" />
<label class="summary SH2A SH4 SH4A" for="row288">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      @Rm+,DRn</span>
<span>(Rm) <var title="store into (right)"></var> DRn, Rm<var title="add"></var>8 <var title="store into (right)"></var> Rm</span>
<span id="1111nnn0mmmm1001" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1/4</var><var></var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers contents of memory at address indicated by Rm to DRn, and adds 8 to
Rm.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_RESTORE_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[m]);
  R[m] += 8;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row289" />
<label class="summary SH4 SH4A" for="row289">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      @Rm+,XDn</span>
<span>(Rm) <var title="store into (right)"></var> XDn, Rm<var title="add"></var>8 <var title="store into (right)"></var> Rm</span>
<span id="1111nnn1mmmm1001" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers contents of memory at address indicated by Rm to XDn, and adds 8 to
Rm.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_RESTORE_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[m]);
  R[m] += 8;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row290" />
<label class="summary SH2A SH4 SH4A" for="row290">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      DRm,@-Rn</span>
<span>Rn<var title="subtract"></var>8 <var title="store into (right)"></var> Rn, DRm <var title="store into (right)"></var> (Rn)</span>
<span id="1111nnnnmmm01011" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">01011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/1</var><var></var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Subtracts 8 from Rn, and transfers DRm contents to memory at address indicated
by resulting Rn value.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_SAVE_DR (int m, int n)
{
  Write_64 (R[n] - 8, DR[m &gt;&gt; 1]);
  R[n] -= 8;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row291" />
<label class="summary SH4 SH4A" for="row291">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      XDm,@-Rn</span>
<span>Rn<var title="subtract"></var>8 <var title="store into (right)"></var> Rn, (Rn) <var title="store into (right)"></var> XDm</span>
<span id="1111nnnnmmm11011" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">11011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Subtracts 8 from Rn, and transfers XDm contents to memory at address indicated
by resulting Rn value.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_SAVE_XD (int m, int n)
{
  Write_64 (R[n] - 8, XD[m &gt;&gt; 1]);
  R[n] -= 8;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row292" />
<label class="summary SH2A SH4 SH4A" for="row292">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      @(R0,Rm),DRn</span>
<span>(R0 <var title="add"></var> Rm) <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmmm0110" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/4</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers contents of memory at address indicated by (R0 + Rm) to DRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_LOAD_DR (int m, int n)
{
  DR[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row293" />
<label class="summary SH4 SH4A" for="row293">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      @(R0,Rm),XDn</span>
<span>(R0 <var title="add"></var> Rm) <var title="store into (right)"></var> XDn</span>
<span id="1111nnn1mmmm0110" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">1</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers contents of memory at address indicated by (R0 + Rm) to XDn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_LOAD_XD (int m, int n)
{
  XD[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row294" />
<label class="summary SH2A SH4 SH4A" for="row294">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      DRm,@(R0,Rn)</span>
<span>DRm <var title="store into (right)"></var> (R0 <var title="add"></var> Rn)</span>
<span id="1111nnnnmmm00111" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers DRm contents to memory at address indicated by (R0 + Rn).</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_STORE_DR (int m, int n)
{
  Write_64 (R[0] + R[n], DR[m &gt;&gt; 1]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row295" />
<label class="summary SH4 SH4A" for="row295">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov      XDm,@(R0,Rn)</span>
<span>XDm <var title="store into (right)"></var> (R0 <var title="add"></var> Rn)</span>
<span id="1111nnnnmmm10111" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">10111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e Extension</span>
<span title="note">Transfers XDm contents to memory at address indicated by (R0 + Rn).</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_STORE_XD (int m, int n)
{
  Write_64 (R[0] + R[n], XD[m &gt;&gt; 1]);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row296" />
<label class="summary SH2A" for="row296">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.d    @(disp12,Rm),DRn</span>
<span>(disp <var title="multiply"></var> 8 <var title="add"></var> Rm) <var title="store into (right)"></var> DRn</span>
<span id="0011nnn0mmmm00010111dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00010111</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/4</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers memory contents at the address indicated by (disp + Rn) to DRn.</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_DISP12_LOAD_DR (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  DR[n &gt;&gt; 1] = Read_64 (R[m] + (disp &lt;&lt; 3));
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row297" />
<label class="summary SH2A" for="row297">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmov.d    DRm,@(disp12,Rn)</span>
<span>DRm <var title="store into (right)"></var> (disp <var title="multiply"></var> 8 <var title="add"></var> Rn)</span>
<span id="0011nnnnmmm000010011dddddddddddd" class="colorized"><var title="Opcode Identifier">0011</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">000010011</var><var title="Displacement (12 bits)">dddddddddddd</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var></var><var></var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mov</em>e</span>
<span title="note">Transfers DRm contents to memory at the address indicated by (disp + Rn).</span>
<span title="section">Operation</span>
<span title="operation">void FMOV_INDEX_DISP12_STORE_DR (int m, int n, int d)
{
  long disp = (0x00000FFF & (long)d);
  Write_64 (R[n] + (disp &lt;&lt; 3), DR[m &gt;&gt; 1]);
  PC += 4;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<span class="section_title">Floating-Point Single-Precision Instructions (FPSCR.PR = 0)</span>
<input name="instruction" type="radio" id="row298" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row298">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fldi0     FRn</span>
<span>0x00000000 <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn10001101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10001101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>L</em>oa<em>d</em> <em>I</em>mmediate <em>0</em>.0</span>
<span title="note">When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.<abbr title="Procedure Register">PR</abbr> = 0, this instruction loads floating-point 0.0 (0x00000000) into
FRn.<br />
If <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.<abbr title="Procedure Register">PR</abbr> = 1, the instruction is handled as an illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void FLDI0 (int n)
{
  FR[n] = 0x00000000;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row299" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row299">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fldi1     FRn</span>
<span>0x3F800000 <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn10011101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">10011101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>L</em>oa<em>d</em> <em>I</em>mmediate <em>1</em>.0</span>
<span title="note">When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.<abbr title="Procedure Register">PR</abbr> = 0, this instruction loads floating-point 1.0 (0x3F800000) into
FRn.<br />
If FPCSR.<abbr title="Procedure Register">PR</abbr> = 1, the instruction is handled as an illegal instruction.</span>
<span title="section">Operation</span>
<span title="operation">void FLDI1 (int n)
{
  FR[n] = 0x3F800000;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row300" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row300">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>flds      FRm,FPUL</span>
<span>FRm <var title="store into (right)"></var> FPUL</span>
<span id="1111mmmm00011101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00011101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>L</em>oa<em>d</em> to <em>S</em>ystem Register</span>
<span title="note">Transfers the contents of floating-point register FRm into system register <abbr title="Floating-Point Communication Register">FPUL</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void FLDS (int m)
{
  FPUL = FR[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row301" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row301">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsts      FPUL,FRn</span>
<span>FPUL <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn00001101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00001101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>St</em>ore <em>S</em>ystem Register</span>
<span title="note">Transfers the contents of system register <abbr title="Floating-Point Communication Register">FPUL</abbr> to floating-point register FRn.</span>
<span title="section">Operation</span>
<span title="operation">void FSTS (int n)
{
  FR[n] = FPUL;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row302" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row302">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fabs      FRn</span>
<span>FRn <var title="binary and"></var> 0x7FFFFFFF <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn01011101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01011101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Abs</em>olute Value</span>
<span title="note">Clears the most significant bit of the contents of floating-point register FRn
to 0, and stores the result in FRn.</span>
<span title="section">Note</span>
<span title="note">The cause and flag fields in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.<abbr title="Procedure Register">PR</abbr> setting before this instruction.</span>
<span title="section">Operation</span>
<span title="operation">void FABS (int n)
{
  FR[n] = FR[n] & 0x7FFFFFFFF;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row303" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row303">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fneg      FRn</span>
<span>FRn <var title="binary xor"></var> 0x80000000 <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn01001101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01001101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>0</var><var></var><var>1</var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Neg</em>ate Value</span>
<span title="note">Inverts the most significant bit (sign bit) of the contents of floating-point
register FRn, and stores the result in FRn.</span>
<span title="section">Note</span>
<span title="note">The cause and flag fields in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.<abbr title="Procedure Register">PR</abbr> setting before this instruction.</span>
<span title="section">Operation</span>
<span title="operation">void FNEG (int n)
{
  FR[n] = -FR[n];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row304" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row304">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fadd      FRm,FRn</span>
<span>FRn <var title="add"></var> FRm <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm0000" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Add</em></span>
<span title="note">Arithmetically adds the two single-precision floating-point numbers in FRn and
FRm, and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Add" class="image_filter" src="fadd.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">SH2E and SH3E support only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.</span>
<span title="section">Operation</span>
<span title="operation">void FADD (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, ADD);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        break;
      default:
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case NZERO:
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;

     case NINF:
       switch (data_type_of (n))
       {
       case PINF:
         invalid (n);
         break;
       default:
         inf (n, 1);
         break;
       }
       break;
    }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have the same sign and the exponent of at least one value is 0xFE</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have different signs and neither has an exponent greater than 0x18</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row305" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row305">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsub      FRm,FRn</span>
<span>FRn <var title="subtract"></var> FRm <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm0001" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Sub</em>tract</span>
<span title="note">Arithmetically subtracts the single-precision floating-point number in FRm from
the single-precision floating-point number in FRn, and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Subtract" class="image_filter" src="fsub.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">SH2E and SH3E support only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.</span>
<span title="section">Operation</span>
<span title="operation">void FSUB (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, SUB);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        FR[n] = -FR[n];
        break;
      default:
        break;
      }
      break;

    case PZERO:
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case PINF:
        invalid (n);
        break;
      default:
        inf (n, 1);
        break;
      }
      break;

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;
    }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have the same sign and the exponent of at least one value is 0xFE</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>FRn and FRm have different signs and neither has an exponent greater than 0x18</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row306" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row306">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmul      FRm,FRn</span>
<span>FRn <var title="multiply"></var> FRm <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm0010" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mul</em>tiply</span>
<span title="note">Arithmetically multiplies the two single-precision floating-point numbers in
FRn and FRm, and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Multiply" class="image_filter" src="fmul.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">SH2E and SH3E support only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.</span>
<span title="section">Operation</span>
<span title="operation">void FMUL (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      default:
        normal_fmul (m, n);
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n,sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      default:
        inf (n, sign_of (m) ^ sign_of (n));
        break
      }
      break;
    }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of FRn) + (exponent of FRm) - 0x7F is not less than 0xFE</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>When both FRn and FRm are normalized numbers:</var>
  <var>(exponent of FRn) + (exponent of FRm) - 0x7F is not more than 0x00</var>
  <var><br /></var>
  <var>When at least FRn or FRm is not a normalized number:</var>
  <var>(exponent of FRn) + (exponent of FRm) - 0x7F is not more than 0x18</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row307" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row307">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmac      FR0,FRm,FRn</span>
<span>FR0 <var title="multiply"></var> FRm <var title="add"></var> FRn <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm1110" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">1110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>M</em>ultiply and <em>Ac</em>cumulate</span>
<span title="note">Arithmetically multiplies the two single-precision floating-point numbers in
<abbr title="Single-precision Floating-Point Register 0">FR0</abbr> and FRm, arithmetically adds the contents of FRn, and stores the result in
FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Multiply and Accumulate" class="image_filter" src="fmac.svg" height="942" /></span>
<span title="section">Note</span>
<span title="note">SH2E and SH3E support only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.
<br /><br />
This instruction rounds only the final result and does not round the
intermediate result of the multiplication.  Thus, for IEEE 754 compliant code,
this instruction cannot be used as a replacement for individual FADD and FMUL
instructions.</span>
<span title="section">Operation</span>
<span title="operation">void FMAC (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (FPSCR_PR == 1)
    undefined_operation ();

  else if (data_type_of (0) == sNaN
           || data_type_of (m) == sNaN
           || data_type_of (n) == sNaN)
    invalid (n);

  else if (data_type_of (0) == qNaN || data_type_of (m) == qNaN)
    qnan (n);

  else if (data_type_of (0) == DENORM || data_type_of (m) == DENORM)
    set_E ();

  else
    switch (data_type_of (0))
    {
    case NORM:
      switch (data_type_of (m))
      {
      case PZERO:
      case NZERO:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PZERO:
        case NZERO:
          zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
          break;
        default:
          break;
        }

      case PINF:
      case NINF:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PINF:
        case NINF:
          if (sign_of (0) ^ sign_of (m) ^ sign_of (n))
            invalid (n);
          else
            inf (n, sign_of (0) ^ sign_of (m));
          break;
        default:
          inf (n, sign_of (0) ^ sign_of (m));
          break;
        }

      case NORM:
        switch (data_type_of (n))
        {
        case DENORM:
          set_E ();
          break;
        case qNaN:
          qnan (n);
          break;
        case PINF:
        case NINF:
          inf (n, sign_of (n));
          break;
        case PZERO:
        case NZERO:
        case NORM:
          normal_fmac (m, n);
          break;
        }
        break;

      case PZERO:
      case NZERO:
        switch (data_type_of (m))
        {
        case PINF:
        case NINF:
          invalid (n);
          break;
        case PZERO:
        case NZERO:
        case NORM:
          switch (data_type_of (n))
          {
          case DENORM:
            set_E ();
            break;
          case qNaN:
            qnan (n);
            break;
          case PZERO:
          case NZERO:
            zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
            break;
          default:
            break;
          }
          break;
        }
        break;

      case PINF:
      case NINF:
        switch (data_type_of (m))
        {
        case PZERO:
        case NZERO:
          invalid (n);
          break;
        default:
          switch (data_type_of (n))
          {
          case DENORM:
            set_E ();
            break;
          case qNaN:
            qnan(n);
            break;
          default:
            inf (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));
            break
          }
          break;
        }
        break;
      }
    }
}

void normal_fmac (int m, int n)
{
  union
  {
    int double x;
    int l[4];
  } dstx, tmpx;

  float dstf, srcf;

  if (data_type_of (n) == PZERO || data_type_of (n) == NZERO)
    srcf = 0.0; // flush denormalized value
  else
    srcf = FR[n];

  tmpx.x = FR[0]; // convert single to int double
  tmpx.x *= FR[m]; //exact product
  dstx.x = tmpx.x + srcf;

  if ((dstx.x == srcf && tmpx.x != 0.0)
      || (dstx.x == tmpx.x && srcf != 0.0))
  {
    set_I ();
    if (sign_of (0) ^ sign_of (m) ^ sign_of (n))
    {
      dstx.l[3] -= 1; // correct result
      if (dstx.l[3] == 0xFFFFFFFF)
        dstx.l[2] -= 1;
      if (dstx.l[2] == 0xFFFFFFFF)
        dstx.l[1] -= 1;
      if (dstx.l[1] == 0xFFFFFFFF)
        dstx.l[0] -= 1;
    }
    else
      dstx.l[3] |= 1
  }

  if ((dstx.l[1] & 0x01FFFFFF) || dstx.l[2] || dstx.l[3])
    set_I();

  if(FPSCR_RM == 1)
  {
    dstx.l[1] &= 0xFE000000; // round toward zero
    dstx.l[2] = 0x00000000;
    dstx.l[3] = 0x00000000;
  }

  dstf = dstx.x;
  check_single_exception (&FR[n], dstf);
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>At least one of the following results is not less than 0xFD:</var>
  <var><br /></var>
  <var>(exponent of FR0) + (exponent of FRm)</var>
  <var><br /></var>
  <var>(exponent of FRn)</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>At least one of the following results is not more than 0x2E:</var>
  <var><br /></var>
  <var>(exponent of FR0) + (exponent of FRm)</var>
  <var><br /></var>
  <var>(exponent of FRn)</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row308" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row308">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fdiv      FRm,FRn</span>
<span>FRn <var title="divide"></var> FRm <var title="store into (right)"></var> FRn</span>
<span id="1111nnnnmmmm0011" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>13</var><var>12</var><var></var><var>13</var><var>12/13</var><var>14</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Div</em>ide</span>
<span title="note">Arithmetically divides the single-precision floating-point number in FRn by the
single-precision floating-point number in FRm, and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and FRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Divide" class="image_filter" src="fdiv.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">SH2E and SH3E support only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.</span>
<span title="section">Operation</span>
<span title="operation">void FDIV (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case DENORM:
        set_E ();
        break;
      default:
        normal_fdiv_single (m, n);
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
      case NINF:
        break;
      default:
        dz (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
        inf (n, 1);
        break;
      case NINF:
        inf (n, 0);
        break;
      default:
        dz (FR[n], sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case DENORM:
      set_E ();
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case DENORM:
        set_E ();
        break;
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;
    }
}

void normal_fdiv_single (int m, int n)
{
  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } tmpd;

  tmpf.f = FR[n];   // save destination value
  dstf.f /= FR[m];  // round toward nearest or even
  tmpd.d = dstf.f;  // convert single to double
  tmpd.d *= FR[m];

  if (tmpf.f != tmpd.d)
    set_I ();
  if (tmpf.f &lt; tmpd.d && FPSCR_RM == 1)
    dstf.l -= 1; // round toward zero

  check_single_exception (&FR[n], dstf.f);
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Division by zero</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of FRn) - (exponent of FRm) + 0x7F is not less than 0xFF</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of FRn) - (exponent of FRm) + 0x7F is not more than 0x01</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row309" />
<label class="summary SH2A SH3_FPU SH4 SH4A" for="row309">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsqrt     FRn</span>
<span><var title="square root">FRn</var> <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn01101101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01101101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>11</var><var></var><var>13</var><var>11/12</var><var>30</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Sq</em>uare <em>R</em>oo<em>t</em></span>
<span title="note">Finds the arithmetical square root of the single-precision floating-point number
in FRn, and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and FRn is not
updated. Appropriate processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Square Root" class="image_filter" src="fsqrt.svg" height="128" /></span>
<span title="section">Note</span>
<span title="note">SH3E supports only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.</span>
<span title="section">Operation</span>
<span title="operation">void FSQRT (int n)
{
  PC += 2;
  clear_cause ();

  switch (data_type_of (n))
  {
  case NORM:
    if (sign_of (n) == 0)
      normal_fsqrt_single (n);
    else
      invalid (n);
    break;

  case DENORM:
    if (sign_of (n) == 0)
      set_E ();
    else
      invalid (n);
    break;

  case PZERO:
  case NZERO:
  case PINF:
    break;

  case NINF:
    invalid (n);
    break;

  case qNAN:
    qnan (n);
    break;

  case sNAN:
    invalid (n);
    break;
  }
}

void normal_fsqrt_single (int n)
{
  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } tmpd;

  tmpf.f = FR[n];         // save destination value
  dstf.f = sqrt (FR[n]);  // round toward nearest or even
  tmpd.d = dstf.f;        // convert single to double
  tmpd.d *= dstf.f;

  if (tmpf.f != tmpd.d)
    set_I ();
  if (tmpf.f &lt; tmpd.d && FPSCR_RM == 1)
    dstf.l -= 1;  // round toward zero
  if (FPSCR & ENABLE_I)
    fpu_exception_trap ();
  else
    FR[n] = dstf.f;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row310" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row310">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/eq   FRm,FRn</span>
<span>If FRn <var title="equality"></var> FRm: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="1111nnnnmmmm0100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0100</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>2</var><var></var><var>1</var><var>2/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>C</em>o<em>mp</em>are</span>
<span title="note">Arithmetically compares the two single-precision floating-point numbers in FRn
and FRm, and stores 1 in the <abbr title="Test condition bit flag">T</abbr> bit if they are equal, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Compare" class="image_filter" src="fcmpeq.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">Special Cases:
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.DN is 1, a positive denormalized number is treated as +0 and a
negative denormalized number as -0. This flush-to-zero treatment is applied before
exception detection and special case handling.</span>
<span title="section">Operation</span>
<span title="operation">void FCMP_EQ (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_single (m, n) == INVALID)
    fcmp_invalid ();
  else if (fcmp_chk_single (m, n) == EQ)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_single (int m, int n)
{
  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    return INVALID;
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    return UO;
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
        return GT;
      case NINF:
        return LT;
      default:
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        return EQ;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
        case PINF:
          return EQ;
        default:
          return LT;
      }

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        return EQ;
      default:
        return GT;
      }
    }

  if (FR[n] == FR[m])
    return EQ;
  else if (FR[n] > FR[m])
    return GT;
  else
    return LT;
}

void fcmp_invalid (void)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
    T = 0;
  else
    fpu_exception_trap ();
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row311" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row311">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/gt   FRm,FRn</span>
<span>If FRn <var title="greater than"></var> FRm: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="1111nnnnmmmm0101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">0101</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>2</var><var></var><var>1</var><var>2/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>C</em>o<em>mp</em>are</span>
<span title="note">Arithmetically compares the two single-precision floating-point numbers in FRn
and FRm, and stores 1 in the <abbr title="Test condition bit flag">T</abbr> bit if FRn > FRm, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Compare" class="image_filter" src="fcmpgt.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">For IEEE 754 conform less-than-or-equal comparison it is not sufficient to swap
the operands.  The FCMP/EQ must be used as well.</span>
<span title="section">Operation</span>
<span title="operation">void FCMP_GT (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_single (m, n) == INVALID || fcmp_chk_single (m, n) == UO)
    fcmp_invalid ();
  else if (fcmp_chk_single (m, n) == GT)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_single (int m, int n)
{
  // see description of FCMP/EQ instruction.
}

void fcmp_invalid (void)
{
  // see description of FCMP/EQ instruction.
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row312" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row312">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>float     FPUL,FRn</span>
<span>(float)FPUL <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn00101101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">00101101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Float</em>ing-point Convert from Integer</span>
<span title="note">Taking the contents of <abbr title="Floating-Point Communication Register">FPUL</abbr> as a 32-bit integer, converts this integer to a
single-precision floating-point number and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I = 1 an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of whether
or not an exception has occurred. When an exception occurs, correct exception
information is reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag, and FRn is not updated.
Appropriate processing should therefore be performed by software.</span>
<span title="section">Note</span>
<span title="note">SH2E and SH3E support only invalid operation (<abbr title="Overflow bit flag">V</abbr>) and division by zero
(<abbr title="Zero value bit flag">Z</abbr>) exception flags.</span>
<span title="section">Operation</span>
<span title="operation">void FLOAT_single (int n)
{
  union
  {
    double d;
    int l[2];
  } tmp;

  PC += 2;
  clear_cause ();

  FR[n] = FPUL; // convert from integer to float
  tmp.d = FPUL;
  if (tmp.l[1] & 0x1FFFFFFF)
    inexact();
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row313" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row313">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ftrc      FRm,FPUL</span>
<span>(long)FRm <var title="store into (right)"></var> FPUL</span>
<span id="1111mmmm00111101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">00111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Tr</em>uncate and <em>C</em>onvert to Integer</span>
<span title="note">Converts the single-precision floating-point number in FRm to a 32-bit integer,
and stores the result in <abbr title="Floating-Point Communication Register">FPUL</abbr>.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Truncate and Convert to Integer" class="image_filter" src="ftrc.svg" height="128" /></span>
<span title="section">Note</span>
<span title="note">The rounding mode is always truncation.

The original SH4 has a pipeline exception.  If the FTRC instruction is followed
by an STS <abbr title="Floating-Point Communication Register">FPUL</abbr>, Rn instruction, the latency of the FTRC instruction is reduced
to 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">#define NEG_INT_SINGLE_RANGE 0xCF000000 & 0x7FFFFFFF // -1.000000 * 2^31
#define POS_INT_SINGLE_RANGE 0x4EFFFFFF              // 1.FFFFFE * 2^30

void FTRC_single (int m)
{
  PC += 2;
  clear_cause ();

  switch (ftrc_single_type_of (m))
  {
    case NORM:
      FPUL = FR[m];  // Convert float to integer
      break;
    case PINF:
      ftrc_invalid (0, &FPUL);
      break;
    case NINF:
      ftrc_invalid (1, &FPUL);
      break;
  }
}

int ftrc_single_type_of (int m)
{
  if (sign_of (m) == 0)
  {
    if (FR_HEX[m] > 0x7F800000)
      return NINF;  // NaN
    else if (FR_HEX[m] > POS_INT_SINGLE_RANGE)
      return PINF;  // out of range, +INF
    else
      return NORM;  // +0, +NORM
  }
  else
  {
    if ((FR_HEX[m] & 0x7FFFFFFF) > NEG_INT_SINGLE_RANGE)
      return NINF;  // out of range, +INF, NaN
    else
      return NORM;  // -0, -NORM
  }
}

void ftrc_invalid (int sign, int* result)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
  {
    if (sign == 0)
      *result = 0x7FFFFFFF;
    else
      *result = 0x80000000;
  }
  else
    fpu_exception_trap ();
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row314" />
<label class="summary SH4 SH4A" for="row314">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fipr      FVm,FVn</span>
<span>inner_product (FVm, FVn) <var title="store into (right)"></var> FR[n<var title="add"></var>3]</span>
<span id="1111nnmm11101101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R3)">nn</var><var title="Source Register (R0 - R3)">mm</var><var title="Opcode Identifier">11101101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>4/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>I</em>nner <em>Pr</em>oduct</span>
<span title="note">Calculates the inner products of the 4-dimensional single-precision
floating-point vector indicated by FVn and FVm, and stores the results in
FR[n + 3].
<br /><br />
The FIPR instruction is intended for speed rather than accuracy, and therefore
the results will differ from those obtained by using a combination of FADD and
FMUL instructions. The FIPR execution sequence is as follows:
<ol type="1">
 Multiplies all terms.  The results are 28 bits long.
 Aligns these results, rounding them to fit within 30 bits.
 Adds the aligned values.
 Performs normalization and rounding.
</ol>

Special processing is performed in the following cases:
<ol type="1">
If an input value is an s<abbr title="Not a Number">NaN</abbr>, an invalid exception is generated.

If the input values to be multiplied include a combination of 0 and
infinity, an invalid exception is generated.

In cases other than the above, if the input values include a q<abbr title="Not a Number">NaN</abbr>, the
result will be a q<abbr title="Not a Number">NaN</abbr>.

In cases other than the above, if the input values include infinity:
  <ol type="a">
  If multiplication results in two or more infinities and the signs are
  different, an invalid exception will be generated.
  Otherwise, correct infinities will be stored.
  </ol>

If the input values do not include an s<abbr title="Not a Number">NaN</abbr>, q<abbr title="Not a Number">NaN</abbr>, or infinity, processing
is performed in the normal way.
</ol>
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.U/I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag, and FR[n+3] is not updated. Appropriate
processing should therefore be performed by software.</span>
<span title="section">Note</span>
<span title="note"><abbr title="Single-precision Floating-Point Vector Register 0">FV0</abbr> = { <abbr title="Single-precision Floating-Point Register 0">FR0</abbr>, <abbr title="Single-precision Floating-Point Register 1">FR1</abbr>, <abbr title="Single-precision Floating-Point Register 2">FR2</abbr>, <abbr title="Single-precision Floating-Point Register 3">FR3</abbr> }<br />
<abbr title="Single-precision Floating-Point Vector Register 4">FV4</abbr> = { <abbr title="Single-precision Floating-Point Register 4">FR4</abbr>, <abbr title="Single-precision Floating-Point Register 5">FR5</abbr>, <abbr title="Single-precision Floating-Point Register 6">FR6</abbr>, <abbr title="Single-precision Floating-Point Register 7">FR7</abbr> }<br />
<abbr title="Single-precision Floating-Point Vector Register 8">FV8</abbr> = { <abbr title="Single-precision Floating-Point Register 8">FR8</abbr>, <abbr title="Single-precision Floating-Point Register 9">FR9</abbr>, <abbr title="Single-precision Floating-Point Register 10">FR10</abbr>, <abbr title="Single-precision Floating-Point Register 11">FR11</abbr> }<br />
<abbr title="Single-precision Floating-Point Vector Register 12">FV12</abbr> = { <abbr title="Single-precision Floating-Point Register 12">FR12</abbr>, <abbr title="Single-precision Floating-Point Register 13">FR13</abbr>, <abbr title="Single-precision Floating-Point Register 14">FR14</abbr>, <abbr title="Single-precision Floating-Point Register 15">FR15</abbr> }<br /></span>
<span title="section">Operation</span>
<span title="operation">void FIPR (int m, int n)
{
  if (FPSCR_PR == 0)
  {
    PC += 2;
    clear_cause ();
    fipr (m,n);
  }
  else
    undefined_operation ();
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow exception traps</var>
  <var><br /></var>
  <var>At least one of the following results is not less than 0xFC</var>
  <var><br /></var>
  <var>(exponent of FRn) + (exponent of FRm)<br /></var>
  <var>(exponent of FR(n + 1)) + (exponent of FR(m + 1))<br /></var>
  <var>(exponent of FR(n + 2)) + (exponent of FR(m + 2))<br /></var>
  <var>(exponent of FR(n + 3)) + (exponent of FR(m + 3))<br /></var>
  <var></var>
  <var>Underflow</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row315" />
<label class="summary SH4 SH4A" for="row315">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ftrv      XMTRX,FVn</span>
<span>transform_vector (XMTRX, FVn) <var title="store into (right)"></var> FVn</span>
<span id="1111nn0111111101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R3)">nn</var><var title="Opcode Identifier">0111111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>5/8</var><var>4</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Tr</em>ansform <em>V</em>ector</span>
<span title="note">Takes the contents of floating-point registers <abbr title="Single-precision Floating-Point Extended Register 0">XF0</abbr> to <abbr title="Single-precision Floating-Point Extended Register 15">XF15</abbr> indicated by XMTRX
as a 4-row × 4-column matrix, takes the contents of floating-point
registers FR[n] to FR[n + 3] indicated by FVn as a 4-dimensional vector,
multiplies the array by the vector, and stores the results in FV[n].

<br /><img alt="Floating-point Transform Vector" class="image_filter" src="ftrv.svg" height="128" /><br />

The FTRV instruction is intended for speed rather than accuracy, and therefore
the results will differ from those obtained by using a combination of FADD and
FMUL instructions. The FTRV execution sequence is as follows:
<ol type="1">
Multiplies all terms. The results are 28 bits long.
Aligns these results, rounding them to fit within 30 bits.
Adds the aligned values.
Performs normalization and rounding.
</ol>

Special processing is performed in the following cases:
<ol type="1">
If an input value is an s<abbr title="Not a Number">NaN</abbr>, an invalid exception is generated.

If the input values to be multiplied include a combination of 0 and
infinity, an invalid operation exception is generated.

In cases other than the above, if the input values include a q<abbr title="Not a Number">NaN</abbr>, the
result will be a q<abbr title="Not a Number">NaN</abbr>.

In cases other than the above, if the input values include infinity:
  <ol type="a">
  If multiplication results in two or more infinities and the signs are
  different, an invalid exception will be generated.

  Otherwise, correct infinities will be stored.
  </ol>


If the input values do not include an s<abbr title="Not a Number">NaN</abbr>, q<abbr title="Not a Number">NaN</abbr>, or infinity, processing
is performed in the normal way.

</ol>

When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.<abbr title="Overflow bit flag">V</abbr>/O/U/I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless
of whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag, and FVn is not
updated. Appropriate processing should therefore be performed by software.</span>
<span title="section">Note</span>
<span title="note">A 4-dimensional matrix × matrix transformation can be realized by four FTRV
instructions, where every FTRV calculates a column of the result matrix.  The
resulting matrix can be set to the XMTRX registers by toggling the <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.FR bit
to switch register banks without copying them.</span>
<span title="section">Operation</span>
<span title="operation">void FTRV (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    float saved_vec[4];
    float result_vec[4];
    int saved_fpscr;
    int dst;

    PC += 2;
    clear_cause ();

    saved_fpscr = FPSCR;
    FPSCR &= ~ENABLE_VOUI;  // mask VOUI enable
    dst = 12 - n;           // select other vector than FVn

    for (int i = 0; i &lt; 4; i++)
      saved_vec[i] = FR[dst+i];

    for (int i = 0; i &lt; 4; i++)
    {
      for (int j = 0; j &lt; 4; j++)
        FR[dst+j] = XF[i+4j];

      fipr (n, dst);
      saved_fpscr |= FPSCR & (CAUSE | FLAG);
      result_vec[i] = FR[dst+3];
    }

    for (int i = 0; i &lt; 4; i++)
      FR[dst+i] = saved_vec[i];

    FPSCR = saved_fpscr;

    if (FPSCR & ENABLE_VOUI)
      fpu_exception_trap();
    else
      for (int i = 0; i &lt; 4; i++)
        FR[n+i] = result_vec[i];
  }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
  <var>Overflow</var>
  <var>Underflow</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row316" />
<label class="summary SH4A" for="row316">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsrra     FRn</span>
<span>1.0 <var title="divide"></var> sqrt (FRn) <var title="store into (right)"></var> FRn</span>
<span id="1111nnnn01111101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section">Floating-point <em>S</em>qua<em>r</em>e <em>R</em>eciprocal <em>A</em>pproximate</span>
<span title="note">Takes the approximate inverse of the arithmetic square root (absolute error is
within &plusmn;2<sup>-21</sup>) of the single-precision floating-point in FRn
and writes the result to FRn. Since the this instruction operates by
approximation, an imprecision exception is required when the input is a
normalized value. In other cases, the instruction does not require an
imprecision exception.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated. When an
exception occurs, correct exception information is reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and
<abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag, and FRn is not updated. Appropriate processing should therefore be
performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Square Reciprocal Approximate" class="image_filter" src="fsrra.svg" height="128" /></span>
<span title="section">Note</span>
<span title="note">This instruction is also supported by the SH4 variant SH7091.  Other SH4
variants such as SH7751, SH7760, SH7761 might also support it.</span>
<span title="section">Operation</span>
<span title="operation">void FSRRA (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    PC += 2;
    clear_cause();

    switch (data_type_of (n))
    {
    case NORM:
      if (sign_of (n) == 0)
      {
        set_I ();
        FR[n] = 1 / sqrt (FR[n]);
      }
      else
        invalid (n);
      break;

    case DENORM:
      if (sign_of (n) == 0)
        fpu_error ();
      else
        invalid (n);
      break;

    case PZERO:
    case NZERO:
      dz (n, sign_of (n));
      break;

    case PINF:
      FR[n] = 0;
      break;

    case NINF:
      invalid (n);
      break;

    case qNAN:
      qnan (n);
      break;

    case sNAN:
      invalid (n);
      break;
    }
  }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU error</var>
  <var>Invalid operation</var>
  <var>Division by zero</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row317" />
<label class="summary SH4A" for="row317">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsca      FPUL,DRn</span>
<span>sine (FPUL) <var title="store into (right)"></var> FRn
cosine (FPUL) <var title="store into (right)"></var> FR[n<var title="add"></var>1]</span>
<span id="1111nnn011111101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">011111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>3</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>S</em>ine And <em>C</em>osine <em>A</em>pproximate</span>
<span title="note">Calculates the sine and cosine approximations of <abbr title="Floating-Point Communication Register">FPUL</abbr> (absolute error is
within &plusmn;2<sup>-21</sup>) as single-precision floating point values, and
places the values of the sine and cosine in FRn and FR[n + 1], respectively.
Since this instruction is an approximate operation instruction, an imprecision
exception is always required (even if the input is a 0, the result is
imprecise).
<br /><br />
The input angle is specified as a signed fraction in twos complement.  The
result of sin and cos is a single-precision floating-point number.
<br />
0x7FFFFFFF to 0x00000001:
360 × 2<sup>15</sup>−360 ÷ 2<sup>16</sup> to 360 ÷ 2<sup>16</sup> degrees
<br />
0x00000000: 0 degree
<br />
0xFFFFFFFF to 0x80000000:
−360 ÷ 2<sup>16</sup> to −360 × 2<sup>15</sup> degrees</span>
<span title="section">Note</span>
<span title="note">This instruction is also supported by the SH4 variant SH7091.  Other SH4
variants such as SH7751, SH7760, SH7761 might also support it.</span>
<span title="section">Operation</span>
<span title="operation">void FSCA (int n)
{
  if (FPSCR_PR != 0)
    undefined_operation ();
  else
  {
    float angle;
    long offset = 0x00010000;
    long fraction = 0x0000FFFF;

    set_I ();
    fraction &= FPUL;  // extract sub-rotation (fraction) part
    angle = fraction;  // convert to float
    angle = 2 * M_PI * angle / offset;  // convert to radian
    FR[n] = sin (angle);
    FR[n+1] = cos (angle);
    PC += 2;
  }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Inexact</var>
</span>
</span>
</label>
<span class="section_title">Floating-Point Double-Precision Instructions (FPSCR.PR = 1)</span>
<input name="instruction" type="radio" id="row318" />
<label class="summary SH2A SH4 SH4A" for="row318">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fabs      DRn</span>
<span>DRn <var title="binary and"></var> 0x7FFFFFFFFFFFFFFF <var title="store into (right)"></var> DRn</span>
<span id="1111nnn001011101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">001011101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Abs</em>olute Value</span>
<span title="note">Clears the most significant bit of the contents of floating-point register DRn
to 0, and stores the result in DRn.</span>
<span title="section">Note</span>
<span title="note">The cause and flag fields in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.<abbr title="Procedure Register">PR</abbr> setting before this instruction.</span>
<span title="section">Operation</span>
<span title="operation">void FABS (int n)
{
  FR[n] = FR[n] & 0x7FFFFFFFF;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row319" />
<label class="summary SH2A SH4 SH4A" for="row319">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fneg      DRn</span>
<span>DRn <var title="binary xor"></var> 0x8000000000000000 <var title="store into (right)"></var> DRn</span>
<span id="1111nnn001001101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">001001101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0</var><var></var><var></var><var>0</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Neg</em>ate Value</span>
<span title="note">Inverts the most significant bit (sign bit) of the contents of floating-point
register DRn, and stores the result in DRn.</span>
<span title="section">Note</span>
<span title="note">The cause and flag fields in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> are not updated.
<br /><br />
A double-precision floating-point register DRn consists of a single-precision
floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is
the low part.  This instruction operates only on the high part and thus the
operation performed for double and single precision setting is the same.  It is
not necessary to adjust the FPSRC.<abbr title="Procedure Register">PR</abbr> setting before this instruction.</span>
<span title="section">Operation</span>
<span title="operation">void FNEG (int n)
{
  FR[n] = -FR[n];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row320" />
<label class="summary SH2A SH4 SH4A" for="row320">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fadd      DRm,DRn</span>
<span>DRn <var title="add"></var> DRm <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmm00000" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/8</var><var></var><var></var><var>7/9</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Add</em></span>
<span title="note">Arithmetically adds the two double-precision floating-point numbers in DRn and
DRm, and stores the result in DRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Add" class="image_filter" src="fadd.svg" height="300" /></span>
<span title="section">Operation</span>
<span title="operation">void FADD (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, ADD);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        break;
      default:
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case NZERO:
        zero (n, 0);
        break;
      default:
        break;
      }
      break;

    case NZERO:
      break;

    case PINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;

     case NINF:
       switch (data_type_of (n))
       {
       case PINF:
         invalid (n);
         break;
       default:
         inf (n, 1);
         break;
       }
       break;
    }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have the same sign and the exponent of at least one value is 0x7FE</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have different signs and neither has an exponent greater than 0x035</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row321" />
<label class="summary SH2A SH4 SH4A" for="row321">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsub      DRm,DRn</span>
<span>DRn <var title="subtract"></var> DRm <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmm00001" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/8</var><var></var><var></var><var>7/9</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Sub</em>tract</span>
<span title="note">Arithmetically subtracts the double-precision floating-point number in DRm from
the double-precision floating-point number in DRn, and stores the result in DRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction.  When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Subtract" class="image_filter" src="fsub.svg" height="300" /></span>
<span title="section">Operation</span>
<span title="operation">void FSUB (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case NORM:
        normal_faddsub (m, n, SUB);
        break;
      case PZERO:
      case NZERO:
        register_copy (m, n);
        FR[n] = -FR[n];
        break;
      default:
        break;
      }
      break;

    case PZERO:
      break;
      case NZERO:
        switch (data_type_of (n))
        {
        case NZERO:
          zero (n, 0);
          break;
        default:
          break;
        }
        break;

    case PINF:
      switch (data_type_of (n))
      {
      case PINF:
        invalid (n);
        break;
      default:
        inf (n, 1);
        break;
      }
      break;

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        invalid (n);
        break;
      default:
        inf (n, 0);
        break;
      }
      break;
    }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have the same sign and the exponent of at least one value is 0x7FE</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>DRn and DRm have different signs and neither has an exponent greater than 0x035</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row322" />
<label class="summary SH2A SH4 SH4A" for="row322">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fmul      DRm,DRn</span>
<span>DRn <var title="multiply"></var> DRm <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmm00010" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/8</var><var></var><var></var><var>7/9</var><var>3</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Mul</em>tiply</span>
<span title="note">Arithmetically multiplies the two double-precision floating-point numbers in
DRn and DRm, and stores the result in FRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Multiply" class="image_filter" src="fmuld.svg" height="300" /></span>
<span title="section">Operation</span>
<span title="operation">void FMUL (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)
    set_E ();
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      default:
        normal_fmul (m, n);
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n,sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      default:
        inf (n, sign_of (m) ^ sign_of (n));
        break
      }
      break;
    }
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var></var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) + (exponent of DRm) - 0x3FF is not less than 0x7FE</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) + (exponent of DRm) - 0x3FF is not more than 0x000</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row323" />
<label class="summary SH2A SH4 SH4A" for="row323">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fdiv      DRm,DRn</span>
<span>DRn <var title="divide"></var> DRm <var title="store into (right)"></var> DRn</span>
<span id="1111nnn0mmm00011" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/24</var><var></var><var></var><var>24/26</var><var>14</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Div</em>ide</span>
<span title="note">Arithmetically divides the double-precision floating-point number in DRn by the
double-precision floating-point number in DRm, and stores the result in DRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and DRn is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Divide" class="image_filter" src="fdiv.svg" height="300" /></span>
<span title="section">Operation</span>
<span title="operation">void FDIV (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    invalid (n);
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    qnan (n);
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
      case NINF:
        inf (n, sign_of (m) ^ sign_of (n));
        break;
      case PZERO:
      case NZERO:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      case DENORM:
        set_E ();
        break;
      default:
        normal_fdiv_double (m, n);
        break;
      }
      break;

    case PZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
      case NINF:
        break;
      default:
        dz (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        invalid (n);
        break;
      case PINF:
        inf (n, 1);
        break;
      case NINF:
        inf (n, 0);
        break;
      default:
        dz (FR[n], sign_of (m) ^ sign_of (n));
        break;
      }
      break;

    case DENORM:
      set_E ();
      break;

    case PINF:
    case NINF:
      switch (data_type_of (n))
      {
      case DENORM:
        set_E ();
        break;
      case PINF:
      case NINF:
        invalid (n);
        break;
      default:
        zero (n, sign_of (m) ^ sign_of (n));
        break;
      }
      break;
    }
}

void normal_fdiv_double (int m, int n)
{
  union
  {
    double d;
    int l[2];
  } dstd, tmpd;

  union
  {
    int double x;
    int l[4];
  } tmpx;

  tmpd.d = DR[n &gt;&gt; 1];   // save destination value
  dstd.d /= DR[m &gt;&gt; 1];  // round toward nearest or even
  tmpx.x = dstd.d;       // convert double to int double
  tmpx.x *= DR[m &gt;&gt; 1];

  if (tmpd.d != tmpx.x)
    set_I ();
  if (tmpd.d &lt; tmpx.x && FPSCR_RM == 1)
  {
    dstd.l[1] -= 1;  // round toward zero
    if (dstd.l[1] == 0xFFFFFFFF)
      dstd.l[0] -= 1;
  }

  check_double_exception (&DR[n &gt;&gt; 1], dstd.d);
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Division by zero</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) - (exponent of DRm) + 0x3FF is not less than 0x7FF</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow-exception traps</var>
  <var><br /></var>
  <var>(exponent of DRn) - (exponent of DRm) + 0x3FF is not more than 0x001</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row324" />
<label class="summary SH2A SH4 SH4A" for="row324">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fsqrt     DRn</span>
<span><var title="square root">DRn</var> <var title="store into (right)"></var> DRn</span>
<span id="1111nnn001101101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">001101101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/24</var><var></var><var></var><var>23/25</var><var>30</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Sq</em>uare <em>R</em>oo<em>t</em></span>
<span title="note">Finds the arithmetical square root of the double-precision floating-point number
in DRn, and stores the result in DRn.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When an exception occurs, correct
exception information is reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag and DRn is not
updated. Appropriate processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Square Root" class="image_filter" src="fsqrt.svg" height="128" /></span>
<span title="section">Operation</span>
<span title="operation">void FSQRT (int n)
{
  PC += 2;
  clear_cause ();

  switch (data_type_of (n))
  {
  case NORM:
    if (sign_of (n) == 0)
      normal_fsqrt_double (n);
    else
      invalid (n);
    break;

  case DENORM:
    if (sign_of (n) == 0)
      set_E ();
    else
      invalid (n);
    break;

  case PZERO:
  case NZERO:
  case PINF:
    break;

  case NINF:
    invalid (n);
    break;

  case qNAN:
    qnan (n);
    break;

  case sNAN:
    invalid (n);
    break;
  }
}

void normal_fsqrt_double (int n)
{
  union
  {
    double d;
    int l[2];
  } dstd, tmpd;

  union
  {
    int double x;
    int l[4];
  } tmpx;

  tmpd.d = DR[n &gt;&gt; 1];         // save destination value
  dstd.d = sqrt (DR[n &gt;&gt; 1]);  // round toward nearest or even
  tmpx.x = dstd.d;             // convert double to int double
  tmpx.x *= dstd.d;

  if (tmpd.d != tmpx.x)
    set_I ();
  if (tmpd.d &lt; tmpx.x && FPSCR_RM == 1)
  {
    dstd.l[1] -= 1;  // round toward zero
    if (dstd.l[1] == 0xFFFFFFFF)
      dstd.l[0] -= 1;
  }
  if (FPSCR & ENABLE_I)
    fpu_exception_trap();
  else
    DR[n &gt;&gt; 1] = dstd.d;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU Error</var>
  <var>Invalid Operation</var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row325" />
<label class="summary SH2A SH4 SH4A" for="row325">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/eq   DRm,DRn</span>
<span>If DRn <var title="equality"></var> DRm: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="1111nnn0mmm00100" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00100</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var>3/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>C</em>o<em>mp</em>are</span>
<span title="note">Arithmetically compares the two double-precision floating-point numbers in DRn
and DRm, and stores 1 in the <abbr title="Test condition bit flag">T</abbr> bit if they are equal, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Compare" class="image_filter" src="fcmpeq.svg" height="300" /></span>
<span title="section">Operation</span>
<span title="operation">void FCMP_EQ (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_double (m, n) == INVALID)
    fcmp_invalid ();
  else if (fcmp_chk_double (m, n) == EQ)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_double (int m, int n)
{
  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)
    return INVALID;
  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)
    return UO;
  else
    switch (data_type_of (m))
    {
    case NORM:
      switch (data_type_of (n))
      {
      case PINF:
        return GT;
      case NINF:
        return LT;
      default:
        break;
      }
      break;

    case PZERO:
    case NZERO:
      switch (data_type_of (n))
      {
      case PZERO:
      case NZERO:
        return EQ;
      default:
        break;
      }
      break;

    case PINF:
      switch (data_type_of (n))
      {
        case PINF:
          return EQ;
        default:
          return LT;
      }

    case NINF:
      switch (data_type_of (n))
      {
      case NINF:
        return EQ;
      default:
        return GT;
      }
    }

  if (DR[n &gt;&gt; 1] == DR[m &gt;&gt; 1])
    return EQ;
  else if (DR[n &gt;&gt; 1] > DR[m &gt;&gt; 1])
    return GT;
  else
    return LT;
}

void fcmp_invalid (void)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
    T = 0;
  else
    fpu_exception_trap ();
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row326" />
<label class="summary SH2A SH4 SH4A" for="row326">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcmp/gt   DRm,DRn</span>
<span>If DRn <var title="greater than"></var> DRm: 1 <var title="store into (right)"></var> T
Else: 0 <var title="store into (right)"></var> T</span>
<span id="1111nnn0mmm00101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">0</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">00101</var></span>
<span>Result <var title="store into (right)"></var> T</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>2</var><var></var><var></var><var>2</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>3</var><var></var><var></var><var>3/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>C</em>o<em>mp</em>are</span>
<span title="note">Arithmetically compares the two double-precision floating-point numbers in DRn
and DRm, and stores 1 in the <abbr title="Test condition bit flag">T</abbr> bit if DRn > DRm, or 0 otherwise.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Compare" class="image_filter" src="fcmpgt.svg" height="300" /></span>
<span title="section">Note</span>
<span title="note">For IEEE 754 conform less-than-or-equal comparison it is not sufficient to swap
the operands.  The FCMP/EQ must be used as well.</span>
<span title="section">Operation</span>
<span title="operation">void FCMP_GT (int m, int n)
{
  PC += 2;
  clear_cause ();

  if (fcmp_chk_double (m, n) == INVALID || fcmp_chk_double (m, n) == UO)
    fcmp_invalid ();
  else if (fcmp_chk_double (m, n) == GT)
    T = 1;
  else
    T = 0;
}

int fcmp_chk_double (int m, int n)
{
  // see description of FCMP/EQ instruction.
}

void fcmp_invalid (void)
{
  // see description of FCMP/EQ instruction.
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row327" />
<label class="summary SH2A SH4 SH4A" for="row327">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>float     FPUL,DRn</span>
<span>(double)FPUL <var title="store into (right)"></var> DRn</span>
<span id="1111nnn000101101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">000101101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/4</var><var></var><var></var><var>3/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>Float</em>ing-point Convert from Integer</span>
<span title="note">Taking the contents of <abbr title="Floating-Point Communication Register">FPUL</abbr> as a 32-bit integer, converts this integer to a
double-precision floating-point number and stores the result in DRn.</span>
<span title="section">Operation</span>
<span title="operation">void FLOAT_double (int n)
{
  union
  {
    double d;
    int l[2];
  } tmp;

  PC += 2;
  clear_cause ();

  DR[n &gt;&gt; 1] = FPUL; // convert from integer to double
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row328" />
<label class="summary SH2A SH4 SH4A" for="row328">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>ftrc      DRm,FPUL</span>
<span>(long)DRm <var title="store into (right)"></var> FPUL</span>
<span id="1111mmm000111101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">000111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>0/4</var><var></var><var></var><var>4/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>Tr</em>uncate and <em>C</em>onvert to Integer</span>
<span title="note">Converts the double-precision floating-point number in DRm to a 32-bit integer,
and stores the result in <abbr title="Floating-Point Communication Register">FPUL</abbr>.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Truncate and Convert to Integer" class="image_filter" src="ftrc.svg" height="128" /></span>
<span title="section">Note</span>
<span title="note">The rounding mode is always truncation.</span>
<span title="section">Operation</span>
<span title="operation">#define NEG_INT_DOUBLE_RANGE 0xC1E0000000200000 & 0x7FFFFFFFFFFFFFFF
#define POS_INT_DOUBLE_RANGE 0x41E0000000000000

void FTRC_double (int m)
{
  PC += 2;
  clear_cause ();

  switch (ftrc_double_type_of (m))
  {
    case NORM:
      FPUL = DR[m &gt;&gt; 1];  // Convert double to integer
      break;
    case PINF:
      ftrc_invalid (0, &FPUL);
      break;
    case NINF:
      ftrc_invalid (1, &FPUL);
      break;
  }
}

int ftrc_double_type_of (int m)
{
  if (sign_of (m) == 0)
  {
    if (FR_HEX[m] > 0x7FF00000
        || (FR_HEX[m] == 0x7FF00000 && FR_HEX[m+1] != 0x00000000))
      return NINF;  // NaN
    else if (DR_HEX[m &gt;&gt; 1] >= POS_INT_DOUBLE_RANGE)
      return PINF;  // out of range, +INF
    else
      return NORM;  // +0, +NORM
  }
  else
  {
    if ((DR_HEX[m &gt;&gt; 1] & 0x7FFFFFFFFFFFFFFF) >= NEG_INT_DOUBLE_RANGE)
      return NINF;  // out of range, +INF, NaN
    else
      return NORM;  // -0, -NORM
  }
}

void ftrc_invalid (int sign, int* result)
{
  set_V ();

  if ((FPSCR & ENABLE_V) == 0)
  {
    if (sign == 0)
      *result = 0x7FFFFFFF;
    else
      *result = 0x80000000;
  }
  else
    fpu_exception_trap ();
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Invalid operation</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row329" />
<label class="summary SH2A SH4 SH4A" for="row329">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcnvds    DRm,FPUL</span>
<span>double_to_float (DRm) <var title="store into (right)"></var> FPUL</span>
<span id="1111mmm010111101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Source Register (R0 - R7)">mmm</var><var title="Opcode Identifier">010111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>4</var><var></var><var></var><var>4/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>C</em>o<em>nv</em>ert <em>D</em>ouble to <em>S</em>ingle Precision</span>
<span title="note">Converts the double-precision floating-point number in DRm to a single-precision
floating-point number, and stores the result in <abbr title="Floating-Point Communication Register">FPUL</abbr>.
<br /><br />
When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable. I is set, an <abbr title="Floating Point Unit">FPU</abbr> exception trap is generated regardless of
whether or not an exception has occurred. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.enable.O/U is set, <abbr title="Floating Point Unit">FPU</abbr>
exception traps are generated on actual generation by the <abbr title="Floating Point Unit">FPU</abbr> exception source
and on the satisfaction of certain special conditions that apply to this the
instruction. When an exception occurs, correct exception information is
reflected in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.cause and <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.flag, and <abbr title="Floating-Point Communication Register">FPUL</abbr> is not updated. Appropriate
processing should therefore be performed by software.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Convert Double to Single Precision" class="image_filter" src="fcnvds.svg" height="128" /></span>
<span title="section">Operation</span>
<span title="operation">void FCNVDS (int m)
{
  if (FPSCR_PR != 1)
    undefined_operation ();
  else
  {
    PC += 2;
    clear_cause ();

    switch (data_type_of (m))
    {
    case NORM:
    case PZERO:
    case NZERO:
      normal_fcnvds (m, &FPUL);
      break;

    case DENORM:
      set_E ();

    case PINF:
      FPUL = 0x7F800000;
      break;

    case NINF:
      FPUL = 0xFF800000;
      break;

    case qNaN:
      FPUL = 0x7FBFFFFF;
      break;

    case sNaN:
      set_V ();
      if ((FPSCR & ENABLE_V) == 0)
        FPUL = 0x7FBFFFFF;
      else
        fpu_exception_trap ();
      break;
    }
  }
}

void normal_fcnvds (int m, float* result)
{
  int sign;
  float abs;

  union
  {
    float f;
    int l;
  } dstf, tmpf;

  union
  {
    double d;
    int l[2];
  } dstd;

  dstd.d = DR [m &gt;&gt; 1];

  if (dstd.l[1] & 0x1FFFFFFF))
    set_I ();

  if (FPSCR_RM == 1)
    dstd.l[1] &= 0xE0000000;  // round toward zero

  dstf.f = dstd.d;
  check_single_exception (result, dstf.f);
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU error</var>
  <var>Invalid operation</var>
  <var>Overflow</var>
  <var><br /></var>
  <var>Generation of overflow exception traps</var>
  <var><br /></var>
  <var>The exponent of DRn is not less than 0x47E</var>
  <var></var>
  <var></var>
  <var>Underflow</var>
  <var><br /></var>
  <var>Generation of underflow exception traps</var>
  <var><br /></var>
  <var>The exponent of DRn is not more than 0x380</var>
  <var></var>
  <var></var>
  <var>Inexact</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row330" />
<label class="summary SH2A SH4 SH4A" for="row330">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fcnvsd    FPUL,DRn</span>
<span>float_to_double (FPUL) <var title="store into (right)"></var> DRn</span>
<span id="1111nnn010101101" class="colorized"><var title="Opcode Identifier">1111</var><var title="Destination Register (R0 - R7)">nnn</var><var title="Opcode Identifier">010101101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>4</var><var></var><var></var><var>3/5</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>C</em>o<em>nv</em>ert <em>S</em>ingle to <em>D</em>ouble Precision</span>
<span title="note">Converts the single-precision floating-point number in <abbr title="Floating-Point Communication Register">FPUL</abbr> to a
double-precision floating-point number, and stores the result in DRn.
<br /><br /><b><i>Operation result special cases</i></b>
<br /><img alt="Floating-point Convert Single to Double Precision" class="image_filter" src="fcnvsd.svg" height="128" /></span>
<span title="section">Operation</span>
<span title="operation">void FCNVSD (int n)
{
  if (FPSCR_PR != 1)
    undefined_operation ();
  else
  {
    switch (fpul_type ())
    {
    case PZERO:
    case NZERO:
    case PINF:
    case NINF:
    case NORM:
      DR[n &gt;&gt; 1] = FPUL;  // convert float to double
      break;

    case DENORM:
      set_E ();
      break;

    case qNaN:
      qnan (n);
      break;

    case sNaN:
      invalid (n);
      break;
    }
  }
}

int fpul_type ()
{
  int abs = FPUL & 0x7FFFFFFF;
  if (abs &lt; 0x00800000)
  {
    if (FPSCR_DN == 1 || abs == 0x00000000)
    {
      if (sign_of (FPUL) == 0)
        return PZERO;
      else
        return NZERO;
    }
    else
      return DENORM;
  }
  else if (abs &lt; 0x7F800000)
    return NORM;
  else if (abs == 0x7F800000)
  {
    if (sign_of (FPUL) == 0)
      return PINF;
    else
      return NINF;
  }
  else if (abs &lt; 0x7FC00000)
    return qNaN;
  else
    return sNaN;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>FPU error</var>
  <var>Invalid operation</var>
</span>
</span>
</label>
<span class="section_title">Floating-Point Control Instructions</span>
<input name="instruction" type="radio" id="row331" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row331">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,FPSCR</span>
<span>Rm <var title="store into (right)"></var> FPSCR</span>
<span id="0100mmmm01101010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Loads the source operand into <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDSFPSCR (int m)
{
  #if SH2E || SH3E
  FPSCR = R[m] & 0x00018C60;

  #elif SH4 || SH4A || SH2A_FPU
  FPSCR = R[m] & 0x003FFFFF;

  #endif

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row332" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row332">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       FPSCR,Rn</span>
<span>FPSCR <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01101010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01101010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>2</var><var></var><var>1</var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>St</em>ore from FPU <em>S</em>ystem Register</span>
<span title="note">Stores <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSFPSCR (int n)
{
  #if SH2E || SH3E
  R[n] = FPSCR;

  #elif SH4 || SH4A || SH2A_FPU
  R[n] = FPSCR & 0x003FFFFF;

  #endif

  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row333" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row333">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,FPSCR</span>
<span>(Rm) <var title="store into (right)"></var> FPSCR, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01100110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01100110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>3</var><var></var><var>1</var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem register</span>
<span title="note">Loads the source operand into <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDSMFPSCR (int m)
{
  #if SH2E || SH3E
  FPSCR = Read_32 (R[m]) & 0x00018C60;

  #elif SH4 || SH4A || SH2A_FPU
  FPSCR = Read_32 (R[m]) & 0x003FFFFF;

  #endif

  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row334" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row334">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     FPSCR,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, FPSCR <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01100010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01100010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>St</em>ore from FPU <em>S</em>ystem Register</span>
<span title="note">Stores <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMFPSCR (int n)
{
  R[n] -= 4;

  #if SH2E || SH3E
  Write_32 (R[n], FPSCR);

  #elif SH4 || SH4A || SH2A_FPU
  Write_32 (R[n], FPSCR & 0x003FFFFF);

  #endif

  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row335" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row335">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds       Rm,FPUL</span>
<span>Rm <var title="store into (right)"></var> FPUL</span>
<span id="0100mmmm01011010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01011010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>L</em>oa<em>d</em> to FPU <em>S</em>ystem Register</span>
<span title="note">Loads the source operand into <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Communication Register">FPUL</abbr>.</span>
<span title="section">Operation</span>
<span title="operation">void LDSFPUL (int m)
{
  FPUL = R[m];
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row336" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row336">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts       FPUL,Rn</span>
<span>FPUL <var title="store into (right)"></var> Rn</span>
<span id="0000nnnn01011010" class="colorized"><var title="Opcode Identifier">0000</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01011010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>2</var><var></var><var>1</var><var>3</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>St</em>ore from FPU <em>S</em>ystem Register</span>
<span title="note">Stores <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Communication Register">FPUL</abbr> in the destination.</span>
<span title="section">Note</span>
<span title="note">The original SH4 has a pipeline exception.  If the FTRC instruction is followed
by an STS <abbr title="Floating-Point Communication Register">FPUL</abbr>, Rn instruction, the latency of the FTRC instruction is reduced
to 1 cycle.</span>
<span title="section">Operation</span>
<span title="operation">void STSFPUL (int n)
{
  R[n] = FPUL;
  PC += 2;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row337" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row337">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>lds.l     @Rm+,FPUL</span>
<span>(Rm) <var title="store into (right)"></var> FPUL, Rm<var title="add"></var>4 <var title="store into (right)"></var> Rm</span>
<span id="0100mmmm01010110" class="colorized"><var title="Opcode Identifier">0100</var><var title="Source Register (R0 - R15)">mmmm</var><var title="Opcode Identifier">01010110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>LS</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>2</var><var></var><var>1</var><var>1/2</var><var>1</var><var></var></span>
<span class="details">
<span title="section">Operation</span>
<span title="operation">void LDSMFPUL (int m)
{
  FPUL = Read_32 (R[m]);
  R[m] += 4;
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row338" />
<label class="summary SH2E SH2A_FPU SH3_FPU SH4 SH4A" for="row338">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>sts.l     FPUL,@-Rn</span>
<span>Rn<var title="subtract"></var>4 <var title="store into (right)"></var> Rn, FPUL <var title="store into (right)"></var> (Rn)</span>
<span id="0100nnnn01010010" class="colorized"><var title="Opcode Identifier">0100</var><var title="Destination Register (R0 - R15)">nnnn</var><var title="Opcode Identifier">01010010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>CO</var><var>LS</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>1</var><var></var><var>1</var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var>1</var><var>2</var><var></var><var>1</var><var>1/1</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>St</em>ore from FPU <em>S</em>ystem Register</span>
<span title="note">Stores <abbr title="Floating Point Unit">FPU</abbr> system register <abbr title="Floating-Point Communication Register">FPUL</abbr> in the destination.</span>
<span title="section">Operation</span>
<span title="operation">void STSMFPUL (int n)
{
  R[n] -= 4;
  Write_32 (R[n], FPUL);
  PC += 2;
}</span>
<span title="section">Possible Exceptions</span>
<span title="list">
  <var>Data TLB multiple-hit exception</var>
  <var>Data TLB miss exception</var>
  <var>Data TLB protection violation exception</var>
  <var>Data address error</var>
  <var>Initial page write exception</var>
</span>
</span>
</label>
<input name="instruction" type="radio" id="row339" />
<label class="summary SH4 SH4A" for="row339">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>frchg</span>
<span>If FPSCR.PR <var title="equality"></var> 0: <var title="binary not"></var>FPSCR.FR <var title="store into (right)"></var> FPSCR.FR
Else: Undefined Operation</span>
<span id="1111101111111101" class="colorized"><var title="Opcode Identifier">1111101111111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>1/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point F<em>R</em>-bit <em>Ch</em>an<em>g</em>e</span>
<span title="note">Inverts the FR bit in floating-point register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>. When the FR bit in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> is
changed, <abbr title="Single-precision Floating-Point Register 0">FR0</abbr> to <abbr title="Single-precision Floating-Point Register 15">FR15</abbr> in FPR0_BANK0 to FPR15_BANK0 and FPR0_BANK1 to FPR15_BANK1
become XR0 to XR15, and XR0 to XR15 become <abbr title="Single-precision Floating-Point Register 0">FR0</abbr> to <abbr title="Single-precision Floating-Point Register 15">FR15</abbr>. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.FR = 0,
FPR0_BANK0 to FPR15_BANK0 correspond to <abbr title="Single-precision Floating-Point Register 0">FR0</abbr> to <abbr title="Single-precision Floating-Point Register 15">FR15</abbr>, and FPR0_BANK1 to
FPR15_BANK1 correspond to XR0 to XR15. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.FR = 1, FPR0_BANK1 to
FPR15_BANK1 correspond to <abbr title="Single-precision Floating-Point Register 0">FR0</abbr> to <abbr title="Single-precision Floating-Point Register 15">FR15</abbr>, and FPR0_BANK0 to FPR15_BANK0 correspond
to XR0 to XR15.</span>
<span title="section">Operation</span>
<span title="operation">void FRCHG (void)
{
  if (FPSCR_PR == 0)
  {
    FPSCR ^= 0x00200000;  // toggle bit 21
    PC += 2;
  }
  else
    undefined_operation ();
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row340" />
<label class="summary SH2A_FPU SH4 SH4A" for="row340">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fschg</span>
<span>If FPSCR.PR <var title="equality"></var> 0: <var title="binary not"></var>FPSCR.SZ <var title="store into (right)"></var> FPSCR.SZ
Else: Undefined Operation</span>
<span id="1111001111111101" class="colorized"><var title="Opcode Identifier">1111001111111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1</var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var>1</var><var></var><var></var><var>1/4</var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>S</em>z-bit <em>Ch</em>an<em>g</em>e</span>
<span title="note">Inverts the SZ bit of the floating-point status register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>. Changing the
value of the SZ bit in <abbr title="Floating-Point Status/Control Register">FPSCR</abbr> switches the amount of data for transfer by the
FMOV instruction between one single-precision data and a pair of
single-precision data. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.SZ = 0, an FMOV instruction transfers a
single-precision number. When <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>.SZ = 1, the FMOV instruction transfers a
pair of single-precision numbers.</span>
<span title="section">Operation</span>
<span title="operation">void FSCHG (void)
{
  if (FPSCR_PR == 0)
  {
    FPSCR ^= 0x00100000;  // toggle bit 20
    PC += 2;
  }
  else
    undefined_operation ();
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row341" />
<label class="summary SH4A" for="row341">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>fpchg</span>
<span><var title="binary not"></var>FPSCR.PR <var title="store into (right)"></var> FPSCR.PR</span>
<span id="1111011111111101" class="colorized"><var title="Opcode Identifier">1111011111111101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>FE</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var><var></var></span>
<span class="details">
<span title="section"><em>F</em>loating-point <em>P</em>R-bit <em>Ch</em>an<em>g</em>e</span>
<span title="note">Inverts the <abbr title="Procedure Register">PR</abbr> bit of the floating-point status register <abbr title="Floating-Point Status/Control Register">FPSCR</abbr>. The value of
this bit selects single-precision or double-precision operation.</span>
<span title="section">Operation</span>
<span title="operation">void FPCHG (void)
{
  FPSCR ^= 0x00080000;  // toggle bit 19
  PC += 2;
}</span>
</span>
</label>
<span class="section_title">DSP Data Transfer Instructions</span>
<input name="instruction" type="radio" id="row342" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row342">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nopx</span>
<span>No operation</span>
<span id="1111000*0*0*00**" class="colorized"><var title="Opcode Identifier">1111000</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">00</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>N</em>o <em>Op</em>eration</span>
<span title="note">No access operation for X memory.</span>
</span>
</label>
<input name="instruction" type="radio" id="row343" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row343">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w    @Ax,Dx</span>
<span>(Ax) <var title="store into (right)"></var> MSW of Dx, 0 <var title="store into (right)"></var> LSW of Dx</span>
<span id="111100A*D*0*01**" class="colorized"><var title="Opcode Identifier">111100</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">01</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>X</em> Memory and DSP Register</span>
<span title="note">Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.</span>
<span title="section">Example</span>
<span title="assembly">movx.w @r4+,X0 ! Before execution: r4=0x08010000, @r4=0x5555, X0=0x12345678 
               ! After execution:  r4=0x08010002, X0=0x55550000</span>
</span>
</label>
<input name="instruction" type="radio" id="row344" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row344">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w    @Ax+,Dx</span>
<span>(Ax) <var title="store into (right)"></var> MSW of Dx, 0 <var title="store into (right)"></var> LSW of Dx, Ax<var title="add"></var>2 <var title="store into (right)"></var> Ax</span>
<span id="111100A*D*0*10**" class="colorized"><var title="Opcode Identifier">111100</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">10</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>X</em> Memory and DSP Register</span>
<span title="note">Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row345" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row345">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w    @Ax+Ix,Dx</span>
<span>(Ax) <var title="store into (right)"></var> MSW of Dx, 0 <var title="store into (right)"></var> LSW of Dx, Ax<var title="add"></var>Ix <var title="store into (right)"></var> Ax</span>
<span id="111100A*D*0*11**" class="colorized"><var title="Opcode Identifier">111100</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">11</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>X</em> Memory and DSP Register</span>
<span title="note">Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for X memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row346" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row346">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w    Da,@Ax</span>
<span>MSW of Da <var title="store into (right)"></var> (Ax)</span>
<span id="111100A*D*1*01**" class="colorized"><var title="Opcode Identifier">111100</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">1</var><var title="Ignored">*</var><var title="Opcode Identifier">01</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>X</em> Memory and DSP Register</span>
<span title="note">Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row347" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row347">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w    Da,@Ax+</span>
<span>MSW of Da <var title="store into (right)"></var> (Ax), Ax<var title="add"></var>2 <var title="store into (right)"></var> Ax</span>
<span id="111100A*D*1*10**" class="colorized"><var title="Opcode Identifier">111100</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">1</var><var title="Ignored">*</var><var title="Opcode Identifier">10</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>X</em> Memory and DSP Register</span>
<span title="note">Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row348" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row348">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movx.w    Da,@Ax+Ix</span>
<span>MSW of Da <var title="store into (right)"></var> (Ax), Ax<var title="add"></var>Ix <var title="store into (right)"></var> Ax</span>
<span id="111100A*D*1*11**" class="colorized"><var title="Opcode Identifier">111100</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">1</var><var title="Ignored">*</var><var title="Opcode Identifier">11</var><var title="Ignored">**</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>X</em> Memory and DSP Register</span>
<span title="note">Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for X memory. The source word data
is the top word of the register.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVY instruction designation area.
<br />
MSW = High-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row349" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row349">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>nopy</span>
<span>No Operation</span>
<span id="111100*0*0*0**00" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">**</var><var title="Opcode Identifier">00</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>N</em>o <em>Op</em>eration</span>
<span title="note">No access operation for Y memory.</span>
</span>
</label>
<input name="instruction" type="radio" id="row350" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row350">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w    @Ay,Dy</span>
<span>(Ay) <var title="store into (right)"></var> MSW of Dy, 0 <var title="store into (right)"></var> LSW of Dy</span>
<span id="111100*A*D*0**01" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">**</var><var title="Opcode Identifier">01</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>Y</em> Memory and DSP Register</span>
<span title="note">Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row351" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row351">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w    @Ay+,Dy</span>
<span>(Ay) <var title="store into (right)"></var> MSW of Dy, 0 <var title="store into (right)"></var> LSW of Dy, Ay<var title="add"></var>2 <var title="store into (right)"></var> Ay</span>
<span id="111100*A*D*0**10" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">**</var><var title="Opcode Identifier">10</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>Y</em> Memory and DSP Register</span>
<span title="note">Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row352" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row352">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w    @Ay+Iy,Dy</span>
<span>(Ay) <var title="store into (right)"></var> MSW of Dy, 0 <var title="store into (right)"></var> LSW of Dy, Ay<var title="add"></var>Iy <var title="store into (right)"></var> Ay</span>
<span id="111100*A*D*0**11" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">0</var><var title="Ignored">**</var><var title="Opcode Identifier">11</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>Y</em> Memory and DSP Register</span>
<span title="note">Transfers the memory source operand data to the destination register operand.
The transferred data can only be word length for Y memory. The word data is
loaded to the top word of the register and the bottom word is cleared with
zeros.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.
<br />
LSW = Low-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row353" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row353">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w    Da,@Ay</span>
<span>MSW of Da <var title="store into (right)"></var> (Ay)</span>
<span id="111100*A*D*1**01" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">1</var><var title="Ignored">**</var><var title="Opcode Identifier">01</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>Y</em> Memory and DSP Register</span>
<span title="note">Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row354" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row354">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w    Da,@Ay+</span>
<span>MSW of Da <var title="store into (right)"></var> (Ay), Ay<var title="add"></var>2 <var title="store into (right)"></var> Ay</span>
<span id="111100*A*D*1**10" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">1</var><var title="Ignored">**</var><var title="Opcode Identifier">10</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>Y</em> Memory and DSP Register</span>
<span title="note">Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row355" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row355">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movy.w    Da,@Ay+Iy</span>
<span>MSW of Da <var title="store into (right)"></var> (Ay), Ay<var title="add"></var>Iy <var title="store into (right)"></var> Ay</span>
<span id="111100*A*D*1**11" class="colorized"><var title="Opcode Identifier">111100</var><var title="Ignored">*</var><var title="A">A</var><var title="Ignored">*</var><var title="D">D</var><var title="Ignored">*</var><var title="Opcode Identifier">1</var><var title="Ignored">**</var><var title="Opcode Identifier">11</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e between <em>Y</em> Memory and DSP Register</span>
<span title="note">Transfers the register source operand data to the destination memory operand.
The transferred data can only be word length for Y memory. The source word data
is the top word of the register.</span>
<span title="section">Note</span>
<span title="note">"*" of the instruction code is MOVX instruction designation area.
<br />
MSW = High-order word of operand.</span>
</span>
</label>
<input name="instruction" type="radio" id="row356" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row356">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    @-As,Ds</span>
<span>As<var title="subtract"></var>2 <var title="store into (right)"></var> As, (As) <var title="store into (right)"></var> MSW of Ds, 0 <var title="store into (right)"></var> LSW of Ds</span>
<span id="111101AADDDD0000" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row357" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row357">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    @As,Ds</span>
<span>(As) <var title="store into (right)"></var> MSW of Ds, 0 <var title="store into (right)"></var> LSW of Ds</span>
<span id="111101AADDDD0100" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row358" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row358">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    @As+,Ds</span>
<span>(As) <var title="store into (right)"></var> MSW of Ds, 0 <var title="store into (right)"></var> LSW of Ds, As<var title="add"></var>2 <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1000" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1000</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row359" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row359">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    @As+Ix,Ds</span>
<span>(As) <var title="store into (right)"></var> MSW of Ds, 0 <var title="store into (right)"></var> LSW of DS, As<var title="add"></var>Ix <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1100" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1100</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the word data is loaded to the top word of the register and the bottom
word is cleared with zeros.  When the destination operand is a register with
guard bits, the sign is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row360" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row360">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    Ds,@-As</span>
<span>As<var title="subtract"></var>2 <var title="store into (right)"></var> As, MSW of Ds <var title="store into (right)"></var> (As)</span>
<span id="111101AADDDD0001" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row361" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row361">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    Ds,@As</span>
<span>MSW of Ds <var title="store into (right)"></var> (As)</span>
<span id="111101AADDDD0101" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row362" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row362">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    Ds,@As+</span>
<span>MSW of Ds <var title="store into (right)"></var> (As), As<var title="add"></var>2 <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1001" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1001</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row363" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row363">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.w    Ds,@As+Is</span>
<span>MSW of DS <var title="store into (right)"></var> (As), As<var title="add"></var>Is <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1101" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1101</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
word, the top word of the register is stored as the word data.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row364" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row364">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    @-As,Ds</span>
<span>As<var title="subtract"></var>4 <var title="store into (right)"></var> As, (As) <var title="store into (right)"></var> Ds</span>
<span id="111101AADDDD0010" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row365" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row365">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    @As,Ds</span>
<span>(As) <var title="store into (right)"></var> Ds</span>
<span id="111101AADDDD0110" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row366" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row366">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    @As+,Ds</span>
<span>(As) <var title="store into (right)"></var> Ds, As<var title="add"></var>4 <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1010" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1010</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row367" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row367">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    @As+Is,Ds</span>
<span>(As) <var title="store into (right)"></var> Ds, As<var title="add"></var>Is <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1110" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1110</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.  When the destination operand is a register with guard bits, the sign
is extended and stored in the guard bits.</span>
</span>
</label>
<input name="instruction" type="radio" id="row368" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row368">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    Ds,@-As</span>
<span>As<var title="subtract"></var>4 <var title="store into (right)"></var> As, Ds <var title="store into (right)"></var> (As)</span>
<span id="111101AADDDD0011" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row369" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row369">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    Ds,@As</span>
<span>Ds <var title="store into (right)"></var> (As)</span>
<span id="111101AADDDD0111" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">0111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row370" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row370">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    Ds,@As+</span>
<span>Ds <var title="store into (right)"></var> (As), As<var title="add"></var>4 <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1011" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1011</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<input name="instruction" type="radio" id="row371" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row371">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>movs.l    Ds,@As+Is</span>
<span>Ds <var title="store into (right)"></var> (As), As<var title="add"></var>Is <var title="store into (right)"></var> As</span>
<span id="111101AADDDD1111" class="colorized"><var title="Opcode Identifier">111101</var><var title="A">AA</var><var title="D">DDDD</var><var title="Opcode Identifier">1111</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>Mov</em>e <em>S</em>ingle Data between Memory and DSP Register</span>
<span title="note">Transfers the source operand data to the destination. The transferred data is a
longword.</span>
<span title="section">Note</span>
<span title="note">When one of the guard bit registers A0G and A1G is the source operand it is
sign extended and stored as a word.</span>
</span>
</label>
<span class="section_title">DSP ALU Arithmetic Operation Instructions</span>
<input name="instruction" type="radio" id="row372" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row372">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pabs      Sx,Dz</span>
<span>If Sx <var title="greater than or equal"></var> 0: Sx <var title="store into (right)"></var> Dz
If Sx <var title="less than"></var> 0: 0 <var title="subtract"></var> Sx <var title="store into (right)"></var> Dz</span>
<span id="111110**********10001000xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10001000</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Abs</em>olute</span>
<span title="note">Finds absolute values. When the Sx operand is positive, the contents of the
operand are transferred to the Dz operand. If the value is negative, the value
of the Sx operand is subtracted from 0 and stored in the Dz operand.
<br /><br />
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are updated according to the specifications of
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are updated.</span>
<span title="section">Operation</span>
<span title="operation">void pabs_sx (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    // positive value
    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;
    carry_bit = 0;
    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  }
  else
  {
    // negative value
    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;
    borrow_bit = 1;
    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  }

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    #include "fixed_pt_plus_dc_bit.c"
  }
  else
  {
    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
    #include "fixed_pt_minus_dc_bit.c"
  }
}</span>
<span title="section">Example</span>
<span title="assembly">pabs X0,                                                  
         ! After execution:  X0=0x33333333, M0=0x33333333 
pabs X1,                                                  
         ! After execution:  X1=0x22222223</span>
</span>
</label>
<input name="instruction" type="radio" id="row373" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row373">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pabs      Sy,Dz</span>
<span>If Sy <var title="greater than or equal"></var> 0: Sy <var title="store into (right)"></var> Dz
If Sy <var title="less than"></var> 0: 0 <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz</span>
<span id="111110**********1010100000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1010100000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Abs</em>olute</span>
<span title="note">Finds absolute values. When the Sy operand is positive, the contents of the
operand are transferred to the Dz operand. If the value is negative, the value
of the Sy operand is subtracted from 0 and stored in the Dz operand.
<br /><br />
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are updated according to the specifications of
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are updated.</span>
<span title="section">Operation</span>
<span title="operation">void pabs_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    // positive value
    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;
    carry_bit = 0;
    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  }
  else
  {
    // negative value
    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;
    borrow_bit = 1;
    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  }

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"

  if (DSP_ALU_SRC2G_BIT7 == 0)
  {
    #include "fixed_pt_plus_dc_bit.c"
  }
  else
  {
    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
    #include "fixed_pt_minus_dc_bit.c"
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row374" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row374">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>padd      Sx,Sy,Dz</span>
<span>Sx <var title="add"></var> Sy <var title="store into (right)"></var> Dz</span>
<span id="111110**********10110001xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Adds the contents of the Sx and Sy operands and stores the result in the Dz
operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the
specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register
are also updated.</span>
<span title="section">Note</span>
<span title="note">The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is updated depending on the state of the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> [2:0] bit immediately
before the operation.</span>
<span title="section">Operation</span>
<span title="operation">void padd (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">padd X0,Y0,A0                                                                   
              ! After execution:  X0=0x22222222, Y0=0x33333333, A0=0x0055555555</span>
</span>
</label>
<input name="instruction" type="radio" id="row375" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row375">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct padd  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx <var title="add"></var> Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********10110010xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Add</em>ition with Condition</span>
<span title="note">Conditionally adds the contents of the Sx and Sy operands and stores the result
in the Dz operand.  The instruction is executed of the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
Otherwise no operation is performed.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void padd_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG [ex2_dz_no] = DSP_ALU_DST;
    if(ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no==1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row376" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row376">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf padd  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx <var title="add"></var> Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********10110011xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Add</em>ition with Condition</span>
<span title="note">Conditionally adds the contents of the Sx and Sy operands and stores the result
in the Dz operand.  The instruction is executed of the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
Otherwise no operation is performed.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void padd_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
  break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1: DSP_ALU_SRC2 = Y1;
    break;

  case 0x2: DSP_ALU_SRC2 = M0;
    break;

  case 0x3: DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);
  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG [ex2_dz_no] = DSP_ALU_DST;
    if(ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no==1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row377" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row377">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>padd      Sx,Sy,Du
pmuls     Se,Sf,Dg</span>
<span>Sx <var title="add"></var> Sy <var title="store into (right)"></var> Du
MSW of Se <var title="multiply"></var> MSW of Sf <var title="store into (right)"></var> Dg</span>
<span id="111110**********0111eeffxxyygguu" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">0111</var><var title="Multiplier Source Register 1 (A1, X0, X1, Y0)">ee</var><var title="Multiplier Source Register 2 (A1, X0, Y0, Y1)">ff</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="Multiplier Destination Register (A0, A1, M0, M1)">gg</var><var title="ALU Destination Register (A0, A1, X0, Y0)">uu</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Adds the contents of the Sx and Sy operands and stores the result in the Du
operand. The contents of the top word of the Se and Sf operands are multiplied
as signed and the result stored in the Dg operand. These two processes are
executed simultaneously in parallel.
<br /><br />
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the results of the <abbr title="Arithmetic Logic Unit">ALU</abbr>
operation and the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of
the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated according to the results of the <abbr title="Arithmetic Logic Unit">ALU</abbr> operation.</span>
<span title="section">Note</span>
<span title="note">Since the PMULS is fixed decimal point multiplication, the operation result is
different from that of MULS even though the source data is the same.</span>
<span title="section">Operation</span>
<span title="operation">void padd_pmuls (void)
{
  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  switch (EX2_DU)
  {
  case 0x0:
    X0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x1:
    Y0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x2:
    A0 = DSP_ALU_DST;
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G = A0G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x3:
    A1 = DSP_ALU_DST;
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G = A1G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;
  }

  #include "fixed_pt_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">padd A0,M0,A0                                                                                  
              ! Before execution: X0=0x00020000, Y0=0x00030000, M0=0x22222222, A0=0x0055555555 
              ! After execution:  X0=0x00020000, Y0=0x00030000, M0=0x0000000C, A0=0x0077777777</span>
</span>
</label>
<input name="instruction" type="radio" id="row378" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row378">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>paddc     Sx,Sy,Dz</span>
<span>Sx <var title="add"></var> Sy <var title="add"></var> DC <var title="store into (right)"></var> Dz</span>
<span id="111110**********10110000xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110000</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Add</em>ition with <em>C</em>arry</span>
<span title="note">Adds the contents of the Sx and Sy operands to the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit and stores the result
in the Dz operand. The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated as the carry flag.
The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Note</span>
<span title="note">The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is updated as the carry flag after execution of the PADDC instruction
regardless of the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits.
<br /><br />
<abbr title="Condition Select bit flags (2 bits)">CS</abbr>[2:0] = ***: Always operate as Carry or Borrow mode, regardless of the status
of the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit.</span>
<span title="section">Operation</span>
<span title="operation">void paddc (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2 + DSPDCBIT;

  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;

  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_dc_always_carry.c"
}</span>
<span title="section">Example</span>
<span title="assembly">paddc X0,Y0,M0                                                                      
               ! After execution:  X0=0xB3333333, Y0=0x55555555 M0=0x08888888, DC=1 
paddc X0,Y0,M0                                                                      
               ! After execution:  X0=0x33333333, Y0=0x55555555 M0=0x88888889, DC=0</span>
</span>
</label>
<input name="instruction" type="radio" id="row379" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row379">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pclr      Dz</span>
<span>0x00000000 <var title="store into (right)"></var> Dz</span>
<span id="111110**********100011010000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">100011010000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Clears the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to
the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Zero value bit flag">Z</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is set to 1.
The <abbr title="Negative value flag">N</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are cleared to 0.</span>
<span title="section">Operation</span>
<span title="operation">void pclr (void)
{
  DSP_REG[ex2_dz_no] = 0x0;

  if (ex2_dz_no == 0)
    A0G = 0x0;
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0;
  negative_bit = 0;
  zero_bit = 1;
  overflow_bit = 0;

  #include "fixed_pt_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pclr A0                                     
        ! After execution:  A0=0x0000000000</span>
</span>
</label>
<input name="instruction" type="radio" id="row380" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row380">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pclr  Dz</span>
<span>If DC <var title="equality"></var> 1: 0x00000000 <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********100011100000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">100011100000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Cl</em>ea<em>r</em></span>
<span title="note">Conditionally clears the Dz operand.  The instruction is executed when the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>
bit is set to 1.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pclr_dct (void)
{
  if (DC == 1)
    DSP_REG[ex2_dz_no] = 0x0;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row381" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row381">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pclr  Dz</span>
<span>If DC <var title="equality"></var> 0: 0x00000000 <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********100011110000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">100011110000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Cl</em>ea<em>r</em></span>
<span title="note">Conditionally clears the Dz operand.  The instruction is executed when the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>
bit is set to 0.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pclr_dcf (void)
{
  if (DC == 0)
    DSP_REG[ex2_dz_no] = 0x0;
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row382" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row382">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pcmp      Sx,Sy</span>
<span>Sx <var title="subtract"></var> Sy</span>
<span id="111110**********10000100xxyy0000" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10000100</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="Opcode Identifier">0000</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>C</em>o<em>mp</em>are Two Data</span>
<span title="note">Subtracts the contents of the Sy operand from the Sx operand. The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the
<abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits.
The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcmp (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;

  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);

  borrow_bit = ! carry_bit;

  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;

  negative_bit = DSP_ALU_DSTG_BIT7;
  zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_minus_dc_bit.c"

}</span>
<span title="section">Example</span>
<span title="assembly">pcmp X0,                                                                      
         ! After execution:  X0=0x22222222, Y0=0x33333333 N=1, Z=0, V=0, GT=0</span>
</span>
</label>
<input name="instruction" type="radio" id="row383" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row383">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pcopy     Sx,Dz</span>
<span>Sx <var title="store into (right)"></var> Dz</span>
<span id="111110**********11011001xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">11011001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores the Sx operand in the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register
is updated according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr>
bits are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcopy_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row384" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row384">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pcopy     Sy,Dz</span>
<span>Sy <var title="store into (right)"></var> Dz</span>
<span id="111110**********1111100100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1111100100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores the Sy operand in the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register
is updated according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr>
bits are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcopy_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pcopy X0,                                                    
          ! After execution:  X0=0x55555555, A0=0x0055555555</span>
</span>
</label>
<input name="instruction" type="radio" id="row385" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row385">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pcopy Sx,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********11011010xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">11011010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Copy</em> with Condition</span>
<span title="note">Conditionally stores the Sx operand in the Dz operand.  The instruction
is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not
updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcopy_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row386" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row386">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pcopy Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********1111101000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1111101000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Copy</em> with Condition</span>
<span title="note">Conditionally stores the Sy operand in the Dz operand.  The instruction
is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not
updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcopy_sy_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row387" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row387">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pcopy Sx,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********11011011xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">11011011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Copy</em> with Condition</span>
<span title="note">Conditionally stores the Sx operand in the Dz operand.  The instruction
is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not
updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcopy_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_SRC2 = 0;
  DSP_ALU_SRC2G = 0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row388" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row388">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pcopy Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********1111101100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1111101100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Copy</em> with Condition</span>
<span title="note">Conditionally stores the Sy operand in the Dz operand.  The instruction
is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not
updated.</span>
<span title="section">Operation</span>
<span title="operation">void pcopy_sy_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row389" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row389">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pneg      Sx,Dz</span>
<span>0 <var title="subtract"></var> Sx <var title="store into (right)"></var> Dz</span>
<span id="111110**********11001001xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">11001001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Reverses the sign. Subtracts the Sx operand from 0 and stores the result in
the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the
specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register
are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pneg_sx (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pneg X0,A0                                                    
           ! After execution:  X0=0x55555555, A0=0xFFAAAAAAAB 
pneg X1,Y1                                                    
           ! After execution:  Y1=0x66666667</span>
</span>
</label>
<input name="instruction" type="radio" id="row390" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row390">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pneg      Sy,Dz</span>
<span>0 <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz</span>
<span id="111110**********1110100100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1110100100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Reverses the sign. Subtracts the Sy operand from 0 and stores the result in
the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the
specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register
are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pneg_sy (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row391" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row391">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pneg  Sx,Dz</span>
<span>If DC <var title="equality"></var> 1: 0 <var title="subtract"></var> Sx <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********11001010xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">11001010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Neg</em>ate</span>
<span title="note">Conditionally reverses the sign.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is
set to 1.  Subtracts the Sx operand from 0 and stores the result in the Dz
operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pneg_sx_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row392" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row392">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pneg  Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: 0 <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********1110101000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1110101000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Neg</em>ate</span>
<span title="note">Conditionally reverses the sign.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is
set to 1.  Subtracts the Sy operand from 0 and stores the result in the Dz
operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pneg_sy_dct (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row393" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row393">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pneg  Sx,Dz</span>
<span>If DC <var title="equality"></var> 0: 0 <var title="subtract"></var> Sx <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********11001011xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">11001011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Neg</em>ate</span>
<span title="note">Conditionally reverses the sign.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is
set to 0.  Subtracts the Sx operand from 0 and stores the result in the Dz
operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pneg_sx_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC2 = X0;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = X1;
    if (DSP_ALU_SRC2_MSB)
      DSP_ALU_SRC2G = 0xFF;
    else
      DSP_ALU_SRC2G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC2 = A0;
    DSP_ALU_SRC2G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC2 = A1;
    DSP_ALU_SRC2G = A1G;
    break;
  }

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row394" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row394">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pneg  Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: 0 <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********1110101100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1110101100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Neg</em>ate</span>
<span title="note">Conditionally reverses the sign.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is
set to 0.  Subtracts the Sy operand from 0 and stores the result in the Dz
operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pneg_sy_dcf (void)
{
  DSP_ALU_SRC1 = 0;
  DSP_ALU_SRC1G = 0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row395" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row395">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psub      Sx,Sy,Dz</span>
<span>Sx <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz</span>
<span id="111110**********10100001xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Subtracts the contents of the Sy operand from the Sx operand and stores the
result in the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according
to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr>
register are updated.</span>
<span title="section">Operation</span>
<span title="operation">void psub (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_minus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">psub X0,Y0,A0                                                                   
              ! After execution:  X0=0x55555555, Y0=0x33333333, A0=0x0022222222</span>
</span>
</label>
<input name="instruction" type="radio" id="row396" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row396">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psub  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********10100010xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sub</em>tract with Condition</span>
<span title="note">Conditionally subtracts the contents of the Sy operand from the Sx operand and
stores the result in the Dz operand.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit
is set to 1.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void psub_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row397" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row397">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psub  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx <var title="subtract"></var> Sy <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********10100011xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sub</em>tract with Condition</span>
<span title="note">Conditionally subtracts the contents of the Sy operand from the Sx operand and
stores the result in the Dz operand.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit
is set to 0.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void psub_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row398" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row398">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psub      Sx,Sy,Du
pmuls     Se,Sf,Dg</span>
<span>Sx <var title="subtract"></var> Sy <var title="store into (right)"></var> Du
MSW of Se <var title="multiply"></var> MSW of Sf <var title="store into (right)"></var> Dg</span>
<span id="111110**********0110eeffxxyygguu" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">0110</var><var title="Multiplier Source Register 1 (A1, X0, X1, Y0)">ee</var><var title="Multiplier Source Register 2 (A1, X0, Y0, Y1)">ff</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="Multiplier Destination Register (A0, A1, M0, M1)">gg</var><var title="ALU Destination Register (A0, A1, X0, Y0)">uu</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Subtracts the contents of the Sy operand from the Sx operand and stores the
result in the Du operand. The contents of the top word of the Se and Sf operands
are multiplied as signed and the result stored in the Dg operand. These two
processes are executed simultaneously in parallel.
<br /><br />
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the results of the <abbr title="Arithmetic Logic Unit">ALU</abbr>
operation and the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of
the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated according to the results of the <abbr title="Arithmetic Logic Unit">ALU</abbr> operation.</span>
<span title="section">Operation</span>
<span title="operation">void psub_pmuls (void)
{
  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  switch (EX2_DU)
  {
  case 0x0:
    X0 = DSP_ALU_DST;
    negative_bit = DSP_ALU_DST_MSB;
    zero_bit = (DSP_ALU_DST == 0);
    break;

  case 0x1:
    Y0  = DSP_ALU_DST;
    negative_bit = DSP_ALU_DST_MSB;
    zero_bit = (DSP_ALU_DST == 0);
    break;

  case 0x2:
    A0 = DSP_ALU_DST;
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G = A0G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;

  case 0x3:
    A1 = DSP_ALU_DST;
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G = A1G | MASKFFFFFF00;
    negative_bit = DSP_ALU_DSTG_BIT7;
    zero_bit = (DSP_ALU_DST == 0) & (DSP_ALU_DSTG_LSB8 == 0);
    break;
  }

  #include "fixed_pt_minus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">psub A0,M0,A0                                                                                
              ! After execution:  X0=0x00020000, Y0=0xFFFE0000, M0=0xFFFFFFF8, A0=0x55555555</span>
</span>
</label>
<input name="instruction" type="radio" id="row399" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row399">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psubc     Sx,Sy,Dz</span>
<span>Sx − Sy <var title="subtract"></var> DC <var title="store into (right)"></var> Dz</span>
<span id="111110**********10100000xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100000</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sub</em>traction with <em>C</em>arry</span>
<span title="note">Subtracts the contents of the Sy operand and the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit from the Sx operand and
stores the result in the Dz operand. The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated
as the borrow flag. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also
updated.</span>
<span title="section">Operation</span>
<span title="operation">void psubc (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2 - DSPDCBIT;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_dc_always_borrow.c"
}</span>
<span title="section">Example</span>
<span title="assembly">psubc X0,Y0,M0                                                                        
               ! After execution:  X0=0x33333333, Y0=0x55555555 M0=0xFFDDDDDDDE, DC=1 
psubc X0,Y0,M0                                                                        
               ! After execution:  X0=0x33333333, Y0=0x55555555 M0=0xFFDDDDDDDD, DC=1</span>
</span>
</label>
<input name="instruction" type="radio" id="row400" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row400">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdec      Sx,Dz</span>
<span>MSW of Sx <var title="subtract"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz</span>
<span id="111110**********10001001xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10001001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Subtracts 1 from the top word of the Sx operand, stores the result in the upper
word of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Note</span>
<span title="note">The bottom word of the destination register is ignored when the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is
updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdec_sx (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_minus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pdec X0,M0                                                  
           ! After execution:  X0=0x0052330F, M0=0x00510000 
pdec X1,X1                                                  
           ! After execution:  X1=0xFC330000</span>
</span>
</label>
<input name="instruction" type="radio" id="row401" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row401">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdec      Sy,Dz</span>
<span>MSW of Sy <var title="subtract"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz</span>
<span id="111110**********1010100100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1010100100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Subtracts 1 from the top word of the Sy operand, stores the result in the upper
word of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Note</span>
<span title="note">The bottom word of the destination register is ignored when the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is
updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdec_sy (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_minus_dc_bit.c"
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row402" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row402">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdec  Sx,Dz</span>
<span>If DC <var title="equality"></var> 1: MSW of Sx <var title="subtract"></var> 1 <var title="store into (right)"></var> MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********10001010xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10001010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Dec</em>rement by 1</span>
<span title="note">Conditionally subtracts 1 from the top word of the Sx operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdec_sx_dct (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row403" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row403">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdec  Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: MSW of Sy <var title="subtract"></var> 1 <var title="store into (right)"></var> MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********1010101000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1010101000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Dec</em>rement by 1</span>
<span title="note">Conditionally subtracts 1 from the top word of the Sy operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdec_sy_dct (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row404" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row404">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdec  Sx,Dz</span>
<span>If DC <var title="equality"></var> 0: MSW of Sx <var title="subtract"></var> 1 <var title="store into (right)"></var> MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********10001011xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10001011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Dec</em>rement by 1</span>
<span title="note">Conditionally subtracts 1 from the top word of the Sx operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdec_sx_dcf (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row405" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row405">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdec  Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: MSW of Sy <var title="subtract"></var> 1 <var title="store into (right)"></var> MSW of DZ, clear LSW of Dz
Else: nop</span>
<span id="111110**********1010101100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1010101100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Dec</em>rement by 1</span>
<span title="note">Conditionally subtracts 1 from the top word of the Sy operand, stores the result
in the upper word of the Dz operand, and clears the bottom word of the Dz
operand with zeros.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdec_sy_dcf (void)
{
  DSP_ALU_SRC2 = 0x1;
  DSP_ALU_SRC2G = 0x0;

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) && ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & ! DSP_ALU_SRC2_MSB);
  borrow_bit = ! carry_bit;
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row406" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row406">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pinc      Sx,Dz</span>
<span>MSW of Sy <var title="add"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz</span>
<span id="111110**********10011001xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Adds 1 to the top word of the Sx operand, stores the result in the upper word
of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pinc_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pinc X0,M0                                                  
           ! After execution:  X0=0x0052330F, M0=0x00530000 
pinc X1,X1                                                  
           ! After execution:  X1=0xFC350000</span>
</span>
</label>
<input name="instruction" type="radio" id="row407" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row407">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pinc      Sy,Dz</span>
<span>MSW of Sy <var title="add"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz</span>
<span id="111110**********1011100100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011100100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Adds 1 to the top word of the Sy operand, stores the result in the upper word
of the Dz operand, and clears the bottom word of the Dz operand with zeros.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pinc_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"
  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row408" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row408">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pinc  Sx,Dz</span>
<span>If DC <var title="equality"></var> 1: MSW of Sx <var title="add"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10011010xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Inc</em>rement by 1 with Condition</span>
<span title="note">Conditionally adds 1 to the top word of the Sx operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pinc_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row409" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row409">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pinc  Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: MSW of Sy <var title="add"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********1011101000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011101000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Inc</em>rement by 1 with Condition</span>
<span title="note">Conditionally adds 1 to the top word of the Sy operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pinc_sy_dct (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row410" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row410">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pinc  Sx,Dz</span>
<span>If DC <var title="equality"></var> 0: MSW of Sx <var title="add"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10011011xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Inc</em>rement by 1 with Condition</span>
<span title="note">Conditionally adds 1 to the top word of the Sx operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pinc_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row411" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row411">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pinc  Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: MSW of Sy <var title="add"></var> 1 <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********1011101100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011101100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Inc</em>rement by 1 with Condition</span>
<span title="note">Conditionally adds 1 to the top word of the Sy operand, stores the result in the
upper word of the Dz operand, and clears the bottom word of the Dz operand with
zeros. The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pinc_sy_dcf (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "integer_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row412" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row412">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdmsb     Sx,Dz</span>
<span>Sx data MSB position <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz</span>
<span id="111110**********10011101xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011101</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Finds the first position to change in the lineup of Sx operand bits and stores
the bit position in the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated
according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the
<abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdmsb_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i >= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i >= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;
  overflow_bit = 0;

  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pdmsb X0,M0                                                  
            ! After execution:  X0=0x0052330F, M0=0x00080000 
pdmsb X1,X1                                                  
            ! After execution:  X1=0x00050000</span>
</span>
</label>
<input name="instruction" type="radio" id="row413" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row413">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pdmsb     Sy,Dz</span>
<span>Sy data MSB position <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz</span>
<span id="111110**********1011110100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011110100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Finds the first position to change in the lineup of Sy operand bits and stores
the bit position in the Dz operand.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated
according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the
<abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdmsb_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i >= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i >= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;
  overflow_bit = 0;

  #include "integer_unconditional_update.c"
  #include "integer_plus_dc_bit.c"
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row414" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row414">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdmsb Sx,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx data MSB position <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10011110xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011110</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>D</em>etect <em>M</em>ost <em>S</em>ignificant <em>B</em>it with Condition</span>
<span title="note">Conditionally finds the first position to change in the lineup of Sx operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdmsb_sx_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i >= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i >= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row415" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row415">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pdmsb Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sy data MSB position <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********1011111000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011111000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>D</em>etect <em>M</em>ost <em>S</em>ignificant <em>B</em>it with Condition</span>
<span title="note">Conditionally finds the first position to change in the lineup of Sy operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdmsb_sy_dct (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i >= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i >= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row416" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row416">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdmsb Sx,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx data MSB position <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10011111xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011111</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>D</em>etect <em>M</em>ost <em>S</em>ignificant <em>B</em>it with Condition</span>
<span title="note">Conditionally finds the first position to change in the lineup of Sx operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdmsb_sx_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i >= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i >= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row417" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row417">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pdmsb Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sy data MSB position <var title="store into (right)"></var> MSW of Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********1011111100yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011111100</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>D</em>etect <em>M</em>ost <em>S</em>ignificant <em>B</em>it with Condition</span>
<span title="note">Conditionally finds the first position to change in the lineup of Sy operand
bits and stores the bit position in the Dz operand. The instruction is executed
if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pdmsb_sy_dcf (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  short int i;
  unsigned char msb, src1g;
  unsigned long src1 = DSP_ALU_SRC1;
  msb = DSP_ALU_SRC1G_BIT7;
  src1g = (DSP_ALU_SRC1G_LSB8 &lt;&lt; 1);
  for (i = 38; ((msb == (src1g &gt;&gt; 7)) && (i >= 32)); i--)
    src1g &lt;&lt;= 1;

  if (i == 31)
    for(i; ((msb == (src1 &gt;&gt; 31)) && (i >= 0)); i--)
      src1 &lt;&lt;= 1;

  DSP_ALU_DST = 0x0;
  DSP_ALU_DST_HW = (short int)(30 - i);
  if (DSP_ALU_DST_MSB)
    DSP_ALU_DSTG_LSB8 = 0xFF;
  else
    DSP_ALU_DSTG_LSB8 = 0x0;

  carry_bit = 0;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row418" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row418">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>prnd      Sx,Dz</span>
<span>Sx <var title="add"></var> 0x00008000 <var title="store into (right)"></var> Dz, clear LSW of Dz</span>
<span id="111110**********10011000xx00zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10011000</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="Opcode Identifier">00</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>R</em>ou<em>nd</em>ing</span>
<span title="note">Does rounding. Adds the immediate data 0x00008000 to the contents of the Sx
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of Dz with zeros.
<br /><br />
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void prnd_sx (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) & MASKFFFF0000;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">prnd X0,M0                                                  
           ! After execution:  X0=0x0052330F, M0=0x00520000 
prnd X1,X1                                                  
           ! After execution:  X1=0xFC350000</span>
</span>
</label>
<input name="instruction" type="radio" id="row419" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row419">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>prnd      Sy,Dz</span>
<span>Sy <var title="add"></var> 0x00008000 <var title="store into (right)"></var> Dz, clear LSW of Dz</span>
<span id="111110**********1011100000yyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">1011100000</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>R</em>ou<em>nd</em>ing</span>
<span title="note">Does rounding. Adds the immediate data 0x00008000 to the contents of the Sy
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of Dz with zeros.
<br /><br />
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void prnd_sy (void)
{
  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC1 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = M1;
    break;
  }

  if (DSP_ALU_SRC1_MSB)
    DSP_ALU_SRC1G = 0xFF;
  else
    DSP_ALU_SRC1G = 0x0;

  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) & MASKFFFF0000;
  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) & ! DSP_ALU_DST_MSB)
              | (DSP_ALU_SRC1_MSB & DSP_ALU_SRC2_MSB);
  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;
  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "fixed_pt_plus_dc_bit.c"
}</span>
</span>
</label>
<span class="section_title">DSP ALU Logical Operation Instructions</span>
<input name="instruction" type="radio" id="row420" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row420">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pand      Sx,Sy,Dz</span>
<span>Sx <var title="binary and"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz</span>
<span id="111110**********10010101xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10010101</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Does an AND of the upper word of the Sx operand and the upper word of the Sy
operand, stores the result in the upper word of the Dz operand, and clears the
bottom word of the Dz operand with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed. The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated
according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of
the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Note</span>
<span title="note">The bottom word of the destination register and the guard bits are ignored when
the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is updated.</span>
<span title="section">Operation</span>
<span title="operation">void pand (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW & DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pand X0,Y0,A0                                                                  
              ! After execution:  X0=0x33333333, Y0=0x55555555 A0=0x0011110000</span>
</span>
</label>
<input name="instruction" type="radio" id="row421" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row421">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pand  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx <var title="binary and"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10010110xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10010110</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel Logical <em>And</em></span>
<span title="note">Conditionally does an AND of the upper word of the Sx operand and the upper word
of the Sy operand, stores the result in the upper word of the Dz operand, and
clears the bottom word of the Dz operand with zeros. When Dz is a register that
has guard bits, the guard bits are also zeroed.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pand_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW & DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no==1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row422" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row422">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pand  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx <var title="binary and"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10010111xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10010111</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel Logical <em>And</em></span>
<span title="note">Conditionally does an AND of the upper word of the Sx operand and the upper word
of the Sy operand, stores the result in the upper word of the Dz operand, and
clears the bottom word of the Dz operand with zeros. When Dz is a register that
has guard bits, the guard bits are also zeroed.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pand_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW & DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no==1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row423" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row423">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>por       Sx,Sy,Dz</span>
<span>Sx <var title="binary or"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz</span>
<span id="111110**********10110101xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110101</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Takes the OR of the top word of the Sx operand and the top word of the Sy
operand, stores the result in the top word of the Dz operand, and clears the
bottom word of Dz with zeros. When Dz is a register that has guard bits, the
guard bits are also zeroed.   The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated
according to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of
the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Note</span>
<span title="note">The bottom word of the destination register and the guard bits are ignored when
the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is updated.</span>
<span title="section">Operation</span>
<span title="operation">void por (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">por X0,Y0,A0                                                                  
             ! After execution:  X0=0x33333333, Y0=0x55555555 A0=0x127777789A</span>
</span>
</label>
<input name="instruction" type="radio" id="row424" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row424">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct por   Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx <var title="binary or"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10110110xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110110</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel Logical <em>Or</em></span>
<span title="note">Conditionally takes the OR of the top word of the Sx operand and the top word
of the Sy operand, stores the result in the top word of the Dz operand, and
clears the bottom word of Dz with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit
is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void por_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // /*  */
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row425" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row425">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf por   Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx <var title="binary or"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10110111xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10110111</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel Logical <em>Or</em></span>
<span title="note">Conditionally takes the OR of the top word of the Sx operand and the top word
of the Sy operand, stores the result in the top word of the Dz operand, and
clears the bottom word of Dz with zeros. When Dz is a register that has guard
bits, the guard bits are also zeroed.  The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit
is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void por_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // /*  */
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row426" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row426">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pxor      Sx,Sy,Dz</span>
<span>Sx <var title="binary xor"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz</span>
<span id="111110**********10100101xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100101</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Takes the exclusive OR of the top word of the Sx operand and the top word of the
Sy operand, stores the result in the top word of the Dz operand, and clears the
bottom word of Dz with zeros. When Dz is a register that has guard bits, the
guard bits are also zeroed.  The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according
to the specifications for the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr>
register are also updated.</span>
<span title="section">Note</span>
<span title="note">The bottom word of the destination register and the guard bits are ignored when
the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is updated.</span>
<span title="section">Operation</span>
<span title="operation">void pxor (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  carry_bit = 0x0;
  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = (DSP_ALU_DST_HW == 0);
  overflow_bit = 0x0;

  #include "logical_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pxor X0,Y0,A0                                                                  
              ! After execution:  X0=0x33333333, Y0=0x55555555 A0=0x0066660000</span>
</span>
</label>
<input name="instruction" type="radio" id="row427" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row427">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pxor  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1: Sx <var title="binary xor"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10100110xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100110</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel Logical E<em>x</em>clusive <em>Or</em></span>
<span title="note">Conditionally takes the exclusive OR of the top word of the Sx operand and the
top word of the Sy operand, stores the result in the top word of the Dz operand,
and clears the bottom word of Dz with zeros. When Dz is a register that has
guard bits, the guard bits are also zeroed.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pxor_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row428" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row428">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pxor  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0: Sx <var title="binary xor"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
Else: nop</span>
<span id="111110**********10100111xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10100111</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel Logical E<em>x</em>clusive <em>Or</em></span>
<span title="note">Conditionally takes the exclusive OR of the top word of the Sx operand and the
top word of the Sy operand, stores the result in the top word of the Dz operand,
and clears the bottom word of Dz with zeros. When Dz is a register that has
guard bits, the guard bits are also zeroed.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pxor_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1;
    break;
  }

  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<span class="section_title">DSP Fixed Decimal Point Multiplication Instructions</span>
<input name="instruction" type="radio" id="row429" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row429">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pmuls     Se,Sf,Dg</span>
<span>MSW of Se <var title="multiply"></var> MSW of Sf <var title="store into (right)"></var> Dg</span>
<span id="111110**********0100eeff0000gg00" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">0100</var><var title="Multiplier Source Register 1 (A1, X0, X1, Y0)">ee</var><var title="Multiplier Source Register 2 (A1, X0, Y0, Y1)">ff</var><var title="Opcode Identifier">0000</var><var title="Multiplier Destination Register (A0, A1, M0, M1)">gg</var><var title="Opcode Identifier">00</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Mul</em>tiply <em>S</em>igned by Signed</span>
<span title="note">The contents of the top word of the Se and Sf operands are multiplied as signed
and the result stored in the Dg operand. The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the
<abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Since PMULS is fixed decimal point multiplication, the operation result is
different from that of MULS even though the source data is the same.</span>
<span title="section">Operation</span>
<span title="operation">void pmuls (void)
{
  switch (ee)  // Se Operand selection bit (ee)
  {
  case 0x0:
    DSP_M_SRC1 = X0;
    break;

  case 0x1:
    DSP_M_SRC1 = X1;
    break;

  case 0x2:
    DSP_M_SRC1 = Y0;
    break;

  case 0x3:
    DSP_M_SRC1 = A1;
    break;
  }

  switch (ff)  // Sf Operand selection bit (ff)
  {
  case 0x0:
    DSP_M_SRC2 = Y0;
    break;

  case 0x1:
    DSP_M_SRC2 = Y1;
    break;

  case 0x2:
    DSP_M_SRC2 = X0;
    break;

  case 0x3:
    DSP_M_SRC2 = A1;
    break;
  }

  if ((SBIT == 1) && (DSP_M_SRC1 == 0x8000) && (DSP_M_SRC2 == 0x8000))
    DSP_M_DST = 0x7FFFFFFF;  // overflow protection
  else
    DSP_M_DST= ((long)(short)DSP_M_SRC1 * (long)(short)DSP_M_SRC2) &lt;&lt; 1;

  if (DSP_M_DST_MSB)
    DSP_M_DSTG_LSB8 = 0xFF;
  else
    DSP_M_DSTG_LSB8 = 0x0;

  switch (gg)  // Dg Operand selection bit (gg)
  {
  case 0x0:
    M0 = DSP_M_DST;
    break;

  case 0x1:
    M1 = DSP_M_DST;
    break;

  case 0x2:
    A0 = DSP_M_DST;
    if (DSP_M_DSTG_LSB8 == 0x0)
      A0G=0x0;
    else
      A0G = 0xFFFFFFFF;
    break;

  case 0x3:
    A1 = DSP_M_DST;
    if (DSP_M_DSTG_LSB8 == 0x0)
      A1G = 0x0;
    else
      A1G = 0xFFFFFFFF;
    break;
  }
}</span>
<span title="section">Example</span>
<span title="assembly">pmuls X0,Y0,M0                                                                   
               ! After execution:  X0=0x00010000, Y0=0x00020000, M0=0x00000004   
pmuls X1,Y1,A0                                                                   
               ! After execution:  X1=0xFFFE2222, Y1=0x0001AAAA, A0=0xFFFFFFFFFC</span>
</span>
</label>
<span class="section_title">DSP Shift Operation Instructions</span>
<input name="instruction" type="radio" id="row430" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row430">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psha      Sx,Sy,Dz</span>
<span>If Sy <var title="greater than or equal"></var> 0: Sx <var title="shift bits left"></var> Sy <var title="store into (right)"></var> Dz
If Sy <var title="less than"></var> 0: Sx <var title="shift bits right"></var> Sy <var title="store into (right)"></var> Dz</span>
<span id="111110**********10010001xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10010001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Arithmetically shifts the contents of the Sx or Dz operand and stores the result
in the Dz operand. The amount of the shift is specified by the Sy operand.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void psha (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 & MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW & MASK003F;
    if (cnt > 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;
    if (cnt > 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "shift_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">sha  X0,Y0,A0                                                   
a0                                                              
              ! After execution:  X0=0x88888888, Y0=0x00020000, 
a0                                                              
psha X0,Y0,X0                                                   
              ! After execution:  X0=0x19999999, Y0=0xFFFE0000</span>
</span>
</label>
<input name="instruction" type="radio" id="row431" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row431">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psha  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1 <var title="binary and"></var> Sy <var title="greater than or equal"></var> 0: Sx <var title="shift bits left"></var> Sy <var title="store into (right)"></var> Dz
If DC <var title="equality"></var> 1 <var title="binary and"></var> Sy <var title="less than"></var> 0: Sx <var title="shift bits right"></var> Sy <var title="store into (right)"></var> Dz
If DC <var title="equality"></var> 0: nop</span>
<span id="111110**********10010010xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10010010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sh</em>ift <em>A</em>rithmetically with Condition</span>
<span title="note">Conditionally arithmetically shifts the contents of the Sx operand and
stores the result in the Dz operand. The amount of the shift is specified by
the Sy operand.  When the shift amount is positive, it shifts left. When the
shift amount is negative, it shifts right.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void psha_dct (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 & MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW & MASK003F;
    if (cnt > 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;
    if (cnt > 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row432" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row432">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psha  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0 <var title="binary and"></var> Sy <var title="greater than or equal"></var> 0: Sx <var title="shift bits left"></var> Sy <var title="store into (right)"></var> Dz
If DC <var title="equality"></var> 0 <var title="binary and"></var> Sy <var title="less than"></var> 0: Sx <var title="shift bits right"></var> Sy <var title="store into (right)"></var> Dz
If DC <var title="equality"></var> 1: nop</span>
<span id="111110**********10010011xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10010011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sh</em>ift <em>A</em>rithmetically with Condition</span>
<span title="note">Conditionally arithmetically shifts the contents of the Sx operand and
stores the result in the Dz operand. The amount of the shift is specified by
the Sy operand.  When the shift amount is positive, it shifts left. When the
shift amount is negative, it shifts right.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void psha_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    DSP_ALU_SRC1G = A1G;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK007F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK007F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK007F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2 = M1 & MASK007F0000;
    break;
  }

  if (DSP_ALU_SRC2_MSB)
    DSP_ALU_SRC2G = 0xFF;
  else
    DSP_ALU_SRC2G = 0x0;

  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = DSP_ALU_SRC2_HW & MASK003F;
    if (cnt > 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;
    if (cnt > 32)
    {
      printf ("\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\n", cnt);
      exit ();
    }

    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"

  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = DSP_ALU_DST;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G = A0G | MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G = A1G | MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row433" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row433">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psha      #imm,Dz</span>
<span>If imm <var title="greater than or equal"></var> 0: Dz <var title="shift bits left"></var> imm <var title="store into (right)"></var> Dz
If imm <var title="less than"></var> 0: Dz <var title="shift bits right"></var> imm <var title="store into (right)"></var> Dz</span>
<span id="111110**********00000iiiiiiizzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">00000</var><var title="Unsigned Immediate Data (7 bits)">iiiiiii</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Arithmetically shifts the contents of the Dz operand and stores the result in
the Dz operand. The amount of the shift is specified by the immediate value.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void psha_imm (void)
{
  unsigned short tmp_imm;
  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];

  switch (ex2_dz_no)
  {
    case 0x0:
      DSP_ALU_SRC1G = A0G;
      break;

    case 0x1:
      DSP_ALU_SRC1G = A1G;
      break;

    default:
      if (DSP_ALU_SRC1_MSB)
        DSP_ALU_SRC1G = 0xFF;
      else
        DSP_ALU_SRC1G = 0x0;
  }

  tmp_imm = ((EX2_LW &gt;&gt; 4) & MASK0000007F); // bit[10:4]

  if ((tmp_imm & MASK0040) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 32
    char cnt = tmp_imm & MASK003F;
    if (cnt > 32)
    {
      printf ("\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\n", tmp_imm);
      exit ();
    }

    DSP_ALU_DST = DSP_ALU_SRC1 &lt;&lt; cnt;
    DSP_ALU_DSTG = ((DSP_ALU_SRC1G &lt;&lt; cnt)
                   | (DSP_ALU_SRC1 &gt;&gt; (32 - cnt))) & MASK000000FF;
    carry_bit = (DSP_ALU_DSTG & MASK00000001) == 0x1;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 32
    char cnt = (~tmp_imm & MASK003F) + 1;
    if (cnt > 32)
    {
      printf ("\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\n", tmp_imm);
      exit ();
    }

    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)
    {
      // MSB copy
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; 8) | (DSP_ALU_SRC1G &lt;&lt; (32 - 8));
      DSP_ALU_DST = (long)DSP_ALU_DST &gt;&gt; (cnt - 8);
    }
    else
      DSP_ALU_DST = (DSP_ALU_SRC1 &gt;&gt; cnt) | (DSP_ALU_SRC1G &lt;&lt; (32 - cnt));

    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1 &gt;&gt; cnt) & MASK00000001) == 0x1;
  }

  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);

  #include "fixed_pt_overflow_protection.c"
  #include "fixed_pt_unconditional_update.c"
  #include "shift_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pshl #7,A1                                   
           ! After execution:  A1=0xAA800000</span>
</span>
</label>
<input name="instruction" type="radio" id="row434" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row434">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pshl      Sx,Sy,Dz</span>
<span>If Sy <var title="greater than or equal"></var> 0: Sx <var title="shift bits left"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
If Sy <var title="less than"></var> 0: Sx <var title="shift bits right"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz</span>
<span id="111110**********10000001xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10000001</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Logically shifts the top word contents of the Sx operand, stores the result in
the top word of the Dz operand, and clears the bottom word of the Dz operand
with zeros. When Dz is a register that has guard bits, the guard bits are also
zeroed. The amount of the shift is specified by the Sy operand. When the shift
amount is positive, it shifts left. When the shift amount is negative, it
shifts right.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pshl (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 & MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW & MASK001F;
    if (cnt > 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;
    if (cnt > 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = DSP_ALU_DST_HW == 0;
  overflow_bit = 0x0;

  #include "shift_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">pshl X0,Y0,A0                                                   
a0                                                              
              ! After execution:  X0=0x22222222, Y0=0x00030000, 
a0                                                              
pshl X1,Y1,X1                                                   
              ! After execution:  X1=0x33330000, Y1=0xFFFE0000</span>
</span>
</label>
<input name="instruction" type="radio" id="row435" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row435">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct pshl  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 1 <var title="binary and"></var> Sy <var title="greater than or equal"></var> 0: Sx <var title="shift bits left"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
If DC <var title="equality"></var> 1 <var title="binary and"></var> Sy <var title="less than"></var> 0: Sx <var title="shift bits right"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
If DC <var title="equality"></var> 0: nop</span>
<span id="111110**********10000010xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10000010</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sh</em>ift <em>L</em>ogically with Condition</span>
<span title="note">Conditionally logically shifts the top word contents of the Sx operand, stores
the result in the top word of the Dz operand, and clears the bottom word of the
Dz operand with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the Sy operand. When
the shift amount is positive, it shifts left. When the shift amount is negative,
it shifts right.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pshl_dct
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 & MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW & MASK001F;
    if (cnt > 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;
    if (cnt > 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  if (DC == 1)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row436" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row436">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf pshl  Sx,Sy,Dz</span>
<span>If DC <var title="equality"></var> 0 <var title="binary and"></var> Sy <var title="greater than or equal"></var> 0: Sx <var title="shift bits left"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
If DC <var title="equality"></var> 0 <var title="binary and"></var> Sy <var title="less than"></var> 0: Sx <var title="shift bits right"></var> Sy <var title="store into (right)"></var> Dz, clear LSW of Dz
If DC <var title="equality"></var> 1: nop</span>
<span id="111110**********10000011xxyyzzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">10000011</var><var title="ALU Source Register 1 (A0, A1, X0, X1)">xx</var><var title="ALU Source Register 2 (M0, M1, Y0, Y1)">yy</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>Sh</em>ift <em>L</em>ogically with Condition</span>
<span title="note">Conditionally logically shifts the top word contents of the Sx operand, stores
the result in the top word of the Dz operand, and clears the bottom word of the
Dz operand with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the Sy operand. When
the shift amount is positive, it shifts left. When the shift amount is negative,
it shifts right.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits are not updated.</span>
<span title="section">Operation</span>
<span title="operation">void pshl_dcf (void)
{
  switch (EX2_SX)
  {
  case 0x0:
    DSP_ALU_SRC1 = X0;
    break;

  case 0x1:
    DSP_ALU_SRC1 = X1;
    break;

  case 0x2:
    DSP_ALU_SRC1 = A0;
    break;

  case 0x3:
    DSP_ALU_SRC1 = A1;
    break;
  }

  switch (EX2_SY)
  {
  case 0x0:
    DSP_ALU_SRC2 = Y0 & MASK003F0000;
    break;

  case 0x1:
    DSP_ALU_SRC2 = Y1 & MASK003F0000;
    break;

  case 0x2:
    DSP_ALU_SRC2 = M0 & MASK003F0000;
    break;

  case 0x3:
    DSP_ALU_SRC2  = M1 & MASK003F0000;
    break;
  }

  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt;= 16
    char cnt = DSP_ALU_SRC2_HW & MASK001F;
    if (cnt > 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\n", cnt);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;
    if (cnt > 16)
    {
      printf ("\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\n", cnt);
      exit ();
    }

    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  if (DC == 0)
  {
    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
    if (ex2_dz_no == 0)
      A0G = 0x0;  // clear Guard bits
    else if (ex2_dz_no == 1)
      A1G = 0x0;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row437" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row437">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>pshl      #imm,Dz</span>
<span>If imm <var title="greater than or equal"></var> 0: Dz <var title="shift bits left"></var> imm <var title="store into (right)"></var> Dz, clear LSW of Dz
If imm <var title="less than"></var> 0: Dz <var title="shift bits right"></var> imm, clear LSW of Dz</span>
<span id="111110**********00010iiiiiiizzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">00010</var><var title="Unsigned Immediate Data (7 bits)">iiiiiii</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span>Update <var title="store into (right)"></var> DC</span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Logically shifts the top word contents of the Dz operand, stores the result in
the top word of the Dz operand, and clears the bottom word of the Dz operand
with zeros. When Dz is a register that has guard bits, the guard bits
are also zeroed. The amount of the shift is specified by the immediate value.
When the shift amount is positive, it shifts left. When the shift amount is
negative, it shifts right.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register is updated according to the specifications for
the <abbr title="Condition Select bit flags (2 bits)">CS</abbr> bits. The <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are also updated.</span>
<span title="section">Operation</span>
<span title="operation">void pshl_imm (void)
{
  unsigned short tmp_imm;
  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];
  switch (ex2_dz_no)
  {
  case 0x0:
    DSP_ALU_SRC1G = A0G;
    break;

  case 0x1:
    DSP_ALU_SRC1G = A1G;
    break;

  default:
    if (DSP_ALU_SRC1_MSB)
      DSP_ALU_SRC1G = 0xFF;
    else
      DSP_ALU_SRC1G = 0x0;
  }

  tmp_imm = ((EX2_LW &gt;&gt; 4) & MASK0000003F); // bit[9:4]
  if ((tmp_imm & MASK0020) == 0)
  {
    // Left Shift 0 &lt;= cnt &lt; 16
    char cnt = tmp_imm & MASK001F;
    if (cnt > 16)
    {
      printf ("\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\n", tmp_imm);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &lt;&lt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &lt;&lt; cnt) & MASK8000) == 0x8000;
  }
  else
  {
    // Right Shift 0 &lt; cnt &lt;= 16
    char cnt = (~tmp_imm & MASK001F) + 1;
    if (cnt > 16)
    {
      printf ("\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\n", tmp_imm);
      exit ();
    }
    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &gt;&gt; cnt--;
    carry_bit = ((DSP_ALU_SRC1_HW &gt;&gt; cnt) & MASK0001) == 0x1;
  }

  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;
  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW
  if (ex2_dz_no == 0)
    A0G = 0x0;  // clear Guard bits
  else if (ex2_dz_no == 1)
    A1G = 0x0;

  negative_bit = DSP_ALU_DST_MSB;
  zero_bit = DSP_ALU_DST_HW == 0;
  overflow_bit = 0x0;

  #include "shift_dc_bit.c"
}</span>
<span title="section">Example</span>
<span title="assembly">psha #-5,A1                                     
            ! After execution:  A1=0xFD55555555</span>
</span>
</label>
<span class="section_title">DSP System Control Instructions</span>
<input name="instruction" type="radio" id="row438" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row438">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>plds      Dz,MACH</span>
<span>Dz <var title="store into (right)"></var> MACH</span>
<span id="111110**********111011010000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">111011010000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores the Dz operand in the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.</span>
<span title="section">Operation</span>
<span title="operation">void plds_mach (void)
{
  MACH = DSP_REG[ex2_dz_no];
}</span>
<span title="section">Example</span>
<span title="assembly">plds A0,MACH                                                       
             !  After execution:  A0=0x123456789A, MACH=0x3456789A</span>
</span>
</label>
<input name="instruction" type="radio" id="row439" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row439">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>plds      Dz,MACL</span>
<span>Dz <var title="store into (right)"></var> MACL</span>
<span id="111110**********111111010000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">111111010000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores the Dz operand in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.</span>
<span title="section">Operation</span>
<span title="operation">void plds_macl (void)
{
  MACL = DSP_REG[ex2_dz_no];
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row440" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row440">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct plds  Dz,MACH</span>
<span>If DC <var title="equality"></var> 1: Dz <var title="store into (right)"></var> MACH
Else: nop</span>
<span id="111110**********111011100000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">111011100000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>L</em>oa<em>d</em> <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the Dz operand in the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.</span>
<span title="section">Operation</span>
<span title="operation">void plds_mach_dct (void)
{
  if (DC == 1)
    MACH = DSP_REG[ex2_dz_no];
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row441" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row441">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct plds  Dz,MACL</span>
<span>If DC <var title="equality"></var> 1: Dz <var title="store into (right)"></var> MACL
Else: nop</span>
<span id="111110**********111111100000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">111111100000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>L</em>oa<em>d</em> <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the Dz operand in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.</span>
<span title="section">Operation</span>
<span title="operation">void plds_macl_dct (void)
{
  if (DC == 1)
    MACL = DSP_REG[ex2_dz_no];
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row442" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row442">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf plds  Dz,MACH</span>
<span>If DC <var title="equality"></var> 0: Dz <var title="store into (right)"></var> MACH
Else: nop</span>
<span id="111110**********111011110000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">111011110000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>L</em>oa<em>d</em> <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the Dz operand in the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.</span>
<span title="section">Operation</span>
<span title="operation">void plds_mach_dcf (void)
{
  if (DC == 0)
    MACH = DSP_REG[ex2_dz_no];
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row443" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row443">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf plds  Dz,MACL</span>
<span>If DC <var title="equality"></var> 0: Dz <var title="store into (right)"></var> MACL
Else: nop</span>
<span id="111110**********111111110000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">111111110000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>L</em>oa<em>d</em> <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the Dz operand in the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX, and MOVY can be designated in parallel, their execution may
take two cycles.</span>
<span title="section">Operation</span>
<span title="operation">void plds_macl_dcf (void)
{
  if (DC == 0)
    MACL = DSP_REG[ex2_dz_no];
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row444" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row444">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psts      MACH,Dz</span>
<span>MACH <var title="store into (right)"></var> Dz</span>
<span id="111110**********110011010000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">110011010000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores the contents of the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register in the Dz operand.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void psts_mach (void)
{
  DSP_REG[ex2_dz_no] = MACH;
  if (ex2_dz_no == 0)
  {
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G |= MASKFFFFFF00;
  }
  else if (ex2_dz_no == 1)
  {
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G |= MASKFFFFFF00;
  }
}</span>
<span title="section">Example</span>
<span title="assembly">psts MACH,A0                                                      
             ! After execution:  A0=0xFF88888888, MACH=0x88888888</span>
</span>
</label>
<input name="instruction" type="radio" id="row445" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row445">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>psts      MACL,Dz</span>
<span>MACL <var title="store into (right)"></var> Dz</span>
<span id="111110**********110111010000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">110111010000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"></span>
<span title="note">Stores the contents of the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register in the Dz operand.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void psts_macl (void)
{
  DSP_REG[ex2_dz_no] = MACL;
  if (ex2_dz_no == 0)
  {
    A0G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A0G |= MASKFFFFFF00;
  }
  else if (ex2_dz_no == 1)
  {
    A1G = DSP_ALU_DSTG & MASK000000FF;
    if (DSP_ALU_DSTG_BIT7)
      A1G |= MASKFFFFFF00;
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row446" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row446">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psts  MACH,Dz</span>
<span>If DC <var title="equality"></var> 1: MACH <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********110011100000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">110011100000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>St</em>ore <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the contents of the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register in the Dz operand.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void psts_mach_dct (void)
{
  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = MACH;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row447" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row447">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dct psts  MACL,Dz</span>
<span>If DC <var title="equality"></var> 1: MACL <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********110111100000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">110111100000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>St</em>ore <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the contents of the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register in the Dz operand.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 1.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void psts_macl_dct (void)
{
  if (DC == 1)
  {
    DSP_REG[ex2_dz_no] = MACL;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row448" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row448">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psts  MACH,Dz</span>
<span>If DC <var title="equality"></var> 0: MACH <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********110011110000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">110011110000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>St</em>ore <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the contents of the <abbr title="Multiply and ACcumulate High (word)">MACH</abbr> register in the Dz operand.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void psts_mach_dcf (void)
{
  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = MACH;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
<input name="instruction" type="radio" id="row449" />
<label class="summary SH1_DSP SH2_DSP SH3_DSP" for="row449">
<span class="cpu_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span>dcf psts  MACL,Dz</span>
<span>If DC <var title="equality"></var> 0: MACL <var title="store into (right)"></var> Dz
Else: nop</span>
<span id="111110**********110111110000zzzz" class="colorized"><var title="Opcode Identifier">111110</var><var title="Ignored">**********</var><var title="Opcode Identifier">110111110000</var><var title="ALU Destination Register (A0, A1, M0, M1, X0, X1, Y0, Y1)">zzzz</var></span>
<span></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="cycle_grid"><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var></var><var>1</var></span>
<span class="details">
<span title="section"><em>P</em>arallel <em>St</em>ore <em>S</em>ystem Register</span>
<span title="note">Conditionally stores the contents of the <abbr title="Multiply and ACcumulate Low (word)">MACL</abbr> register in the Dz operand.
The instruction is executed if the <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr> bit is set to 0.
The <abbr title="DSP (Digital Signal Processor) Condition bit flag">DC</abbr>, <abbr title="Negative value flag">N</abbr>, <abbr title="Zero value bit flag">Z</abbr>, <abbr title="Overflow bit flag">V</abbr>, and <abbr title="Signed Greater Than bit flag">GT</abbr> bits of the <abbr title="DSP (Digital Sound Processor) Status Register">DSR</abbr> register are not updated.</span>
<span title="section">Note</span>
<span title="note">Though PSTS, MOVX and MOVY can be designated in parallel, their execution may
take 2 cycles.</span>
<span title="section">Operation</span>
<span title="operation">void psts_macl_dcf (void)
{
  if (DC == 0)
  {
    DSP_REG[ex2_dz_no] = MACL;
    if (ex2_dz_no == 0)
    {
      A0G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A0G |= MASKFFFFFF00;
    }
    else if (ex2_dz_no == 1)
    {
      A1G = DSP_ALU_DSTG & MASK000000FF;
      if (DSP_ALU_DSTG_BIT7)
        A1G |= MASKFFFFFF00;
    }
  }
}</span>
</span>
</label>
</body>
</html>
